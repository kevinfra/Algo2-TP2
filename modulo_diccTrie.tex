\section{Módulo Diccionario String($\alpha$)}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{Diccionario(String,$\alpha$)}.

\textbf{géneros}: \TipoVariable{diccString($\alpha$)}.

Se representa mediante un árbol n-ario con invariante de trie

~

\subsubsection{Operaciones básicas de Diccionario String($\alpha$)}

\InterfazFuncion{CrearDiccionario}{}{}
{res $=_{obs}$ vacío()}
[$O(1)$]
[Crea un diccionario vacío.]
[]

~



\InterfazFuncion{Definido?}{\In{d}{diccString$(\alpha)$}, \In{c}{string})}{bool}
[true]
{$res$ $\igobs$ def?($d$, $c$)}
[$O(|n_m|)$]
[Devuelve true si la clave está definida en el diccionario y false en caso contrario.]
[]

~

\InterfazFuncion{Definir}{\Inout{d}{diccString$(\alpha)$}, \In{c}{string}, \In{s}{$\alpha$}}{}
[$ d \igobs d_0 $]
{$ d \igobs$ definir($c$, $s$, $d_0$)}
[$O(|n_m| + copy(s))$ ]
[Define la clave $c$ con el significado $s$]
[Almacena una copia de $s$.]

~

\InterfazFuncion{Obtener}{\In{d}{diccString$(\alpha)$}, \In{c}{string}}{$\alpha$}
[def?($c$, $d$)]
{alias($res$ $\igobs$ obtener($c$, $d$))}
[$O(|n_m|)$]
[Devuelve el significado correspondiente a la clave $c$.]
[Devuelve el significado almacenado en el diccionario, por lo que $res$ es modificable si y sólo si $d$ lo es.]

~

\InterfazFuncion{Borrar}{\Inout{d}{diccString($\alpha$)}, \In{c}{string}}{}
[$ d \igobs d_0 \land $ def?($d$, $c$)]
{$ d \igobs$ borrar($d_0$, $c$)}
[$O(|n_m|)$]
[Borra la clave $c$ del diccionario.]
[]

~

\pagebreak

\subsubsection{Representación de Diccionario String($\alpha$)}

\begin{Estructura}{ Diccionario String($\alpha$)}[estr]
	\begin{Tupla}[estr]
		\tupItem{raiz}{arreglo(puntero(Nodo))}%
		\tupItem{listaIterable}{lista(puntero(Nodo))}%
	\end{Tupla}

	~

	\begin{Tupla}[Nodo]
		\tupItem{arbolTrie}{arreglo(puntero(Nodo))}%
		\tupItem{\\
					info}{$\alpha$}%
		\tupItem{\\
					infoValida}{bool}%
		\tupItem{\\
					infoEnLista}{iterador(listaIterable)}
	\end{Tupla}

\end{Estructura}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\begin{enumerate}
	\item Raiz es la raiz del arbol con invariante de trie y es un arreglo de 27 posiciones.
	\item Cada uno de los elementos de la lista tiene que ser un puntero a un Nodo del trie.
	\item Nodo es una tupla que contiene un arreglo de 27 posiciones con un puntero a otro Nodo en cada posicion
	,un elemento info que es el alfa que contiene esa clave del arbol, y un elemento iterador que es un puntero
	a un nodo de la lista enlazada.
	\item El iterador a la lista enlazada de cada nodo tiene que apuntar al elemento de la lista que apunta al 
	mismo Nodo.

\end{enumerate}

\pagebreak

\Rep[estr][e]
	\\
	($\forall c$: diccString($(\alpha)$))()

\Rep[estr][e]{
	\\
	tamaño(raiz)==27 $\land$
	\\
	($\forall i$ $\in$ [0..tamaño(raiz)($c$ $\in$ computadoras($e$.topologia) $\Leftrightarrow$ \\
	\- ( \\
	\- \- ($\exists cd$: compuDCNet)
	(está?($cd$, $e$.vectorCompusDCNet) $\land$ ($cd$.pc = puntero($c$)) $\land$ \\
	\- \- ($\exists s$: string)(def?($s$, $e$.diccCompusDCNet) $\land$ ($s$ = $c$.ip))) \\
	\- ) \\
	) $\yluego$\\
	($\forall cd$: compuDCNet)(está?($cd$, $e$.vectorCompusDCNet) $\Leftrightarrow$ \\
	\- ($\exists s$: string)(($s$ = $cd$.pc$\rightarrow$ip) $\land$
		def?($s$, $e$.diccCompusDCNet) $\yluego$ \\
	\- obtener($s$, $e$.diccCompusDCNet) = puntero($cd$)) \\
	) $\yluego$\\
	($\exists cd$: compuDCNet)(está?($cd$, $e$.vectorCompusDCNet) $\yluego$ \\
	*($cd$.pc) = compuQueMásEnvió($e$.vectorCompusDCNet) $\land$ $e$.laQueMásEnvió = puntero($cd$)) $\yluego$\\
	($\forall cd_1$: compuDCNet)(está?($cd_1$, $e$.vectorCompusDCNet) $\implies$ \\
	\- ($\forall p_1$: paquete)($p_1$ $\in$ $cd_1$.conjPaquetes $\implies$ \\
	\- \- ($\forall cd_2$: compuDCNet)((está?($cd_2$, $e$.vectorCompusDCNet)
		$\land$ $cd_1$ $\neq$ $cd_2$) $\implies$ \\
	\- \- \- ($\forall p_2$: paquete)($p_2$ $\in$ $cd_2$.conjPaquetes $\implies$
		$p_1$.id $\neq$ $p_2$.id) \\
	\- \- ) \\
	\- ) \\
	) $\yluego$ \\
	($\forall cd$: compuDCNet)(está?($cd$, $e$.vectorCompusDCNet) $\implies$ \\
	\- ( \\
	\- \- ($\forall p$: paquete)($p$ $\in$ $cd$.conjPaquetes $\Leftrightarrow$ \\
	\- \- \- ( \\
	\- \- \- \- (($p$.origen $\in$ computadoras($e$.topologia) $\land$ $p$.destino
		$\in$ computadoras($e$.topologia) $\land$ \\
	\- \- \- \- $p$.destino $\neq$ *($cd$.pc)) $\yluego$ \\
	\- \- \- \- ($\exists sc$: secu(compu))($sc$ $\in$
		caminosMinimos($e$.topologia, $p$.origen, $p$.destino) $\land$
		está(*($cd$.pc), $sc$))) $\land$ \\
	\- \- \- \- ($\exists n$: nat)
		((def?($n$, $cd$.diccPaquetesDCNet) $\land$ $p$.id = $n$) $\yluego$ \\
	\- \- \- \- \- ($\exists pdn$: paqueteDCNet)($pdn$ $\in$ $e$.conjPaquetesDCNet $\land$ Siguiente($pdn$.it) = $p$ $\land$ \\
	\- \- \- \- \- \- (($p$.origen = *($cd$.pc) $\land$ $pdn$.recorrido = *($cd$.pc) $\puntito$ <>) $\lor$ \\
	\- \- \- \- \- \- ($p$.origen $\neq$ *($cd$.pc) $\land$
		$pdn$.recorrido $\in$ caminosMinimos($e$.topologia, $p$.origen,
		*($cd$.pc)))) $\land$ \\
	\- \- \- \- \- \- Siguiente(obtener($n$, $cd$.diccPaquetesDCNet)) = $pdn$ \\
	\- \- \- \- \- ) \\
	\- \- \- \- ) \\
	\- \- \- ) \\
	\- \- ) $\yluego$ \\
	\- \- ($\neg$vacía?($cd$.colaPaquetesDCNet) $\Leftrightarrow$ \\
	\- \- \- ($\exists p$: paquete)(($p$ $\in$ $cd$.conjPaquetes) $\land$
		($p$ = paqueteMásPrioridad($cd$.conjPaquetes)) $\land$ \\
	\- \- \- \- ($\exists pdn$: paqueteDCNet)(($pdn$ $\in$
		$e$.conjPaquetesDCNet) $\land$ (Siguiente($pdn$.it) = $p$) $\land$ \\
	\- \- \- \-	(Siguiente(proximo($cd$.colaPaquetesDCNet)) = $pdn$)) \\
	\- \- \- ) \\
	\- \- ) $\yluego$ \\
	\- \- ($cd$.enviados $\geq$ enviadosCompu(*($cd$.pc), $e$.vectorCompusDCNet)) $\land$\\
	\- \- ($\neg$HaySiguiente?(cd.paqueteAEnviar))
	\- ) \\
	)
}\mbox{}

\tadOperacion{compuQueMásEnvió}{secu(compuDCNet)/scd}{compu}{$\neg$vacía?($scd$)}
\tadOperacion{maxEnviado}{secu(compuDCNet)/scd}{nat}{$\neg$vacía?($scd$)}
\tadOperacion{enviaronK}{secu(compuDCNet),nat}{conj(compu)}{}
\tadOperacion{paqueteMásPrioridad}{conj(paquete)/cp}{paquete}{$\neg \emptyset?(cp)$}
\tadOperacion{paquetesConPrioridadK}{conj(paquete),nat}{conj(paquete)}{}
\tadOperacion{altaPrioridad}{conj(paquetes)/cp}{nat}{$\neg \emptyset?(cp)$}
\tadOperacion{enviadosCompu}{compu,secu(compuDCNet)}{nat}{}
\tadOperacion{aparicionesCompu}{compu,conj(nat)/cn,dicc(nat,itConj(paqueteDCNet))/dp}{nat}{claves($dp$) $\subseteq$ $cn$}

~

\tadAxioma{compuQueMásEnvió($scd$)}{dameUno(enviaronK($scd$, maxEnviado($scd$)))}
\tadAxioma{maxEnviado($scd$)}{
	\IF vacía?(fin($scd$)) THEN
		prim($scd$).enviados
	ELSE
		max(prim($scd$), maxEnviado(fin($scd$)))
	FI
}
\tadAxioma{enviaronK($scd$, $k$)}{
	\IF vacía?($scd$) THEN
		$\emptyset$
	ELSE {
		\IF prim($scd$).enviados = $k$ THEN
			Ag(*(prim($scd$).pc), enviaronK(fin($scd$), $k$))
		ELSE
			enviaronK(fin($scd$), $k$)
		FI
		}
	FI
}
\tadAxioma{paqueteMásPrioridad($dcn$, $cp$)}{dameUno(paquetesConPrioridadK($cp$, altaPrioridad($cp$)))}

\tadAxioma{altaPrioridad($cp$)}{
	\IF $\emptyset$?(sinUno($cp$)) THEN
		dameUno($cp$).prioridad
	ELSE
		min(dameUno($cp$).prioridad, altaPrioridad(sinUno($cp$)))
	FI
}

\tadAxioma{paquetesConPrioridadK($cp$, $k$)}{
	\IF $\emptyset$?($cp$) THEN
		$\emptyset$
	ELSE {
		\IF dameUno($cp$).prioridad = $k$ THEN
			 Ag(dameUno($cp$), paquetesConPrioridadK(sinUno($cp$), $k$))
		ELSE
			paquetesConPrioridadK(sinUno($cp$), $k$)
		FI
		}
	FI
}

\tadAxioma{enviadosCompu($c$, $scd$)}{
	\IF vacía?($scd$) THEN
		0
	ELSE {
			\IF prim($scd$) = $c$ THEN
				enviadosCompu($c$, fin($scd$))
			ELSE {
				aparicionesCompu($c$, claves(prim($scd$).diccPaquetesDCNet), \\
				prim($scd$).diccPaquetesDCNet) + enviadosCompu($c$, fin($scd$))
				}
			FI
		}
	FI
}

\tadAxioma{aparicionesCompu($c$, $cn$, $dpd$)}{
	\IF	$\emptyset$?($cn$) THEN
		0
	ELSE {
			\IF está?($c$, Siguiente(obtener(dameUno($cn$), $dpd$)).recorrido) THEN
				1 + aparicionesCompu($c$, sinUno($cn$), $dpd$)
			ELSE {
				aparicionesCompu($c$, sinUno($cn$), $dpd$)
				}
			FI
		}
	FI
}

\pagebreak

\subsubsection{Funci\'on de Abstracci\'on}

\Abs[estr]{dcnet}[e]{dcn}{
red($dcn$) = $e$.topología $\land$ \\
($\forall cdn$: compuDCNet)(está?($cdn$, $e$.vectorCompusDCNet) $\impluego$ \\
\- enEspera($dcn$, *($cdn$.pc)) = $cdn$.conjPaquetes $\land$ \\
\- cantidadEnviados($dcn$, *($cdn$.pc)) = $cdn$.enviados $\land$ \\
\- ($\forall p$: paquete)($p$ $\in$ $cdn$.conjPaquetes $\impluego$ \\
\- \- caminoRecorrido($dcn$, $p$) = Siguiente(obtener($p$.id,
	$cdn$.diccPaquetesDCNet)).recorrido \\
\- ) \\
)
}

\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{crearDiccionario}{}{estr}'
	
    arreglo(puntero(Nodo)): res.raiz $\leftarrow$ CrearArreglo(27) '\ote{1}'
	nat: i $\leftarrow$ 0 '\ote{1}' 
    while i < long(res.raiz) do '\ote{1}'
    	res.raiz[i] $\leftarrow$ null '\ote{1}'
    end while '\ote{1}'
    res.listaIterable $\leftarrow$ Vacia() '\ote{1}'

'\ofi{O(1)}'

'\alg{definido?}{\In{d}{diccString($\alpha$)}, \In{c}{string}}{bool}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	nat: letra $\leftarrow$ posicion(c[0]) '\ote{1}'
	puntero(Nodo): arr $\leftarrow$ d.raiz[letra] '\ote{1}'
	while(i < longitud(c) and not arr = null) do '\ote{1}'
		i $\leftarrow$ i + 1 '\ote{1}'
		letra $\leftarrow$ posicion(c[i]) '\ote{1}'
		arr $\leftarrow$ (*arr).arbolTrie[letra] '\ote{1}'
	end while '\ote{$|n_m|$}'
	if(i=longitud(c)) then '\ote{1}'
		res $\leftarrow$ (*arr).infoValida '\ote{1}'
	else
		res $\leftarrow$ false '\ote{1}'
	end if
	
'\ofi{O(|n_m|)}'

\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{definir}{\Inout{d}{diccString($\alpha$)}, \In{c}{string}, \In{s}{$\alpha$}}{}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	nat: letra $\leftarrow$ posicion(c[0]) '\ote{1}'
	if (d.raiz[letra] = null) then '\ote{1}'
		Nodo: nuevo '\ote{1}'
		arreglo(puntero(Nodo)): nuevo.arbolTrie $\leftarrow$ CrearArrelgo(27) '\ote{1}'
		nuevo.infoValida $\leftarrow$ false '\ote{1}'
		d.raiz[letra] $\leftarrow$ puntero(nuevo) '\ote{1}'
	end if
	puntero(Nodo): arr $\leftarrow$ d.raiz[letra] '\ote{1}'
	while(i < longitud(c)) do '\ote{1}'
		i $\leftarrow$ i + 1 '\ote{1}'
		letra $\leftarrow$ posicion(c[i]) '\ote{1}'
		if (arr.arbolTrie[letra] = null) then '\ote{1}'
			Nodo: nuevoHijo '\ote{1}'
			arreglo(puntero(Nodo)): nuevoHijo.arbolTrie $\leftarrow$ CrearArrelgo(27) '\ote{1}'
			nuevoHijo.infoValida $\leftarrow$ false '\ote{1}'
			arr.arbolTrie[letra] $\leftarrow$ puntero(nuevoHijo) '\ote{1}'	
		end if			
		arr $\leftarrow$ (*arr).arreglo[letra] '\ote{1}' '\ote{1}'
	end while '\ote{$|n_m|$}'
    (*arr).info $\leftarrow$ s '\ote{copy(s)}'
    if(not (*arr).infoValida = true) then '\ote{1}'
    	itLista(puntero(Nodo)) it $\leftarrow$ AgregarAdelante(d.listaIterable,null) '\ote{1}'
    	(*arr).infoValida $\leftarrow$ true '\ote{1}'
    	(*arr).infoEnLisa $\leftarrow$ it '\ote{1}'
    	siguiente(it) $\leftarrow$ puntero(*arr) '\ote{1}'
    end if
    	
'\ofi{O(|n_m| + copy(s))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{obtener}{\In{d}{diccString($\alpha$)}, \In{c}{string}}{$\alpha$}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	nat: letra $\leftarrow$ posicion(c[0]) '\ote{1}'
	puntero(Nodo): arr $\leftarrow$ d.raiz[letra] '\ote{1}'
	while(i < longitud(c)) do '\ote{1}'
		i $\leftarrow$ i + 1 '\ote{1}'
		letra $\leftarrow$ posicion(c[i]) '\ote{1}'
		arr $\leftarrow$ (*arr).arbolTrie[letra] '\ote{1}'
	end while '\ote{$|n_m|$}'
	res $\leftarrow$ (*arr).info '\ote{1}'
	
'\ofi{O(|n_m|)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{borrar}{\Inout{d}{diccString($\alpha$)}, \In{c}{string}}{}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	nat: letra $\leftarrow$ posicion(c[0]) '\ote{1}'
	puntero(Nodo): arr $\leftarrow$ d.raiz[letra] '\ote{1}'
	pila(puntero(Nodo)): pil $\leftarrow$ Vacia() '\ote{1}'
	while(i < longitud(c)) do '\ote{1}'
		i $\leftarrow$ i + 1 '\ote{1}'
		letra $\leftarrow$ posicion(c[i]) '\ote{1}'
		arr $\leftarrow$ (*arr).arbolTrie[letra] '\ote{1}'
		Apilar(pil,arr) '\ote{1}'
	end while '\ote{$|n_m|$}'
	if (tieneHermanos(arr)) then '\ote{1}'
		(*arr).infoValida $\leftarrow$ false '\ote{1}'
	else
		i $\leftarrow$ 1 '\ote{1}'
		puntero(Nodo): del $\leftarrow$ tope(pil) '\ote{1}'
		del $\leftarrow$ null '\ote{1}'
		Desapilar(pil) '\ote{1}'
		while(i< longitud(c) and not(tieneHermanosEInfo(*tope(pil)))) do '\ote{1}'
			del $\leftarrow$ tope(pil) '\ote{1}'
			del $\leftarrow$ null '\ote{1}'
			Desapilar(pil) '\ote{1}'
			i $\leftarrow$ i + 1 '\ote{1}'
		end while '\ote{$|n_m|$}'
		if(i = longitud(c)) then '\ote{1}'
			d.raiz[posicion(c[0])] $\leftarrow$ null '\ote{1}'
		end if
	end if

'\ofi{O(|n_m|)}'

\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{tieneHermanos}{\In{nodo}{puntero(Nodo)}}{bool}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	nat: l $\leftarrow$ longitud((*nodo).arbolTrie)) '\ote{1}'
	while(i< l and not(*nodo).arbolTrie[i] = null) do '\ote{1}'
		i $\leftarrow$ i + 1 '\ote{1}'
	end while '\ote{1}' 
	res $\leftarrow$ i < l '\ote{1}'

'\ofi{O(1)}'

\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{tieneHermanosEInfo}{\In{nodo}{puntero(Nodo)}}{bool}'

	res $\leftarrow$ tieneHermanos(nodo) and (*nodo).infoValida = true '\ote{1}'

'\ofi{O(1)}'

\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{posicion}{\In{ch}{char}}{nat}'

	if(ch=a) then '\ote{1}'
		res $\leftarrow$ 0 '\ote{1}'
	else if (ch=b) then '\ote{1}'
		res $\leftarrow$ 1 '\ote{1}'
	else if(ch=c) then '\ote{1}'
		res $\leftarrow$ 2 '\ote{1}'
	else if(ch=d) then '\ote{1}'
		res $\leftarrow$ 3 '\ote{1}'
	else if(ch=e) then '\ote{1}'
		res $\leftarrow$ 4 '\ote{1}'
	else if(ch=f) then '\ote{1}'
		res $\leftarrow$ 5 '\ote{1}'
	else if(ch=g) then '\ote{1}'
		res $\leftarrow$ 6 '\ote{1}'
	else if(ch=h) then '\ote{1}'
		res $\leftarrow$ 7 '\ote{1}'
	else if(ch=i) then '\ote{1}'
		res $\leftarrow$ 8 '\ote{1}'
	else if(ch=j) then '\ote{1}'
		res $\leftarrow$ 9 '\ote{1}'
	else if(ch=k) then '\ote{1}'
		res $\leftarrow$ 10 '\ote{1}'
	else if(ch=l) then '\ote{1}'
		res $\leftarrow$ 11 '\ote{1}'
	else if (ch=m) then '\ote{1}'
		res $\leftarrow$ 12 '\ote{1}'
	else if(ch=n) then '\ote{1}'
		res $\leftarrow$ 13 '\ote{1}'
	else if(ch=\~n) then '\ote{1}'
		res $\leftarrow$ 14 '\ote{1}'
	else if(ch=o) then '\ote{1}'
		res $\leftarrow$ 15 '\ote{1}'
	else if(ch=p) then '\ote{1}'
		res $\leftarrow$ 16 '\ote{1}'
	else if(ch=q) then '\ote{1}'
		res $\leftarrow$ 17 '\ote{1}'
	else if(ch=r) then '\ote{1}'
		res $\leftarrow$ 18 '\ote{1}'
	else if(ch=s) then '\ote{1}'
		res $\leftarrow$ 19 '\ote{1}'
    else if(ch=t) then '\ote{1}'
		res $\leftarrow$ 20 '\ote{1}'
    else if(ch=u) then '\ote{1}'
		res $\leftarrow$ 21 '\ote{1}'
    else if(ch=v) then '\ote{1}'
		res $\leftarrow$ 22 '\ote{1}'
	else if(ch=w) then '\ote{1}'
		res $\leftarrow$ 23 '\ote{1}'
	else if(ch=x) then '\ote{1}'
		res $\leftarrow$ 24 '\ote{1}'
    else if(ch=y) then '\ote{1}'
		res $\leftarrow$ 25 '\ote{1}'
	else
		res $\leftarrow$ 26 '\ote{1}'
	end if

'\ofi{O(1)}'

\end{lstlisting}