\section{Módulo Diccionario Nat Fijo}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{Diccionario(nat, $\alpha$ )}.

\textbf{géneros}: \TipoVariable{DiccNat($\alpha$)}, \TipoVariable{itDiccNat($\alpha$)}.

\subsubsection{Operaciones básicas de DiccNat($\alpha$)}

\InterfazFuncion{crearDiccionario}{\In{v}{vector(tupla(clave : nat, significado :  $\alpha$))}}{DiccNat($\alpha$)}
[true]
{(($\forall$ $t$ : tupla(nat, $\alpha$)) esta?($t$, v)) $\Rightarrow$ ((definido?(t.clave, res))
	$\land_L$ obtener(t.clave,res) $=_{obs}$ t.significado) $\land$ cantClaves(res) $=_{obs}$ longitud(v)}
[$O(n^2 + copy(\alpha) * n)$ donde n es el largo del vector]
[Agrega las tuplas de clave-significado pasadas por parametro al diccionario $d$]
[Los elementos pasados por parámetros se copian al diccionario]

~

\InterfazFuncion{redefinir}{\Inout{d}{DiccNat($\alpha$), \In{n}{nat}, \In{a}{$\alpha$}}}{}
[definido?(n,d)]
{obtener(n,d) $=_{obs}$ a}
[$O(i)$ donde i es 1 en el caso promedio y longitud(d) en el peor caso.]
[]

~

\InterfazFuncion{obtener}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{puntero($\alpha$)}
[true]
{res $=_{obs}$ obtener(n,d)}
[$O(1)$ en caso promedio, $O(n)$ en peor caso]
[Devuelve un puntero al significado de la clave pasada por parametro. Si no está definido, devuelve NULL]
[El puntero va ser una referencia al significado almacenado en el diccionario]

~

\InterfazFuncion{definido?}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{bool}
[true]
{res $=_{obs}$ def?(a,d)}
[$O(1)$ en caso promedio, $O(n)$ en peor caso]
[Dice si está definida una clave en el diccionario]
[]

~

\InterfazFuncion{cantClaves}{\In{d}{DiccNat($\alpha$)}}{Nat}
[true]
{res $=_{obs} \ \# claves$($d$)}
[$O(1)$]
[Devuelve la cantidad de claves definidas en el diccionario.]
[]

~

\InterfazFuncion{OrdenadoPorClave}{\In{d}{DiccNat($\alpha$)}}{vector(tupla(nat,puntero($\alpha$)))}
[true]
{$\forall$ n : nat (def?(n,d) $\Leftarrow$ esta?((n, obtener(n,d)), res)) $\land$ estaOrdenado(res)}
[$O(1)$]
[Devuelve el vector ordenado de manera creciente según el natural de la clave]
[La informacion a la que apunta la segunda parte de la tupla es una referencia al significado correspondiente de la primera parte de la tupla]

~

\subsubsection{Operaciones básicas del iterador}

Este iterador permite recorrer la tabla de hash sobre la que est\'{a} implementado el diccionario para obtener cada clave con su respectivo significado sin modificar ning\'{u}n dato del diccionario.

\InterfazFuncion{CrearIt}{\In{d}{DiccNat($\alpha$)}}{itDiccNat($\alpha$)}
[true]
{alias(esPermutación(SecuSuby($res$), $d$)) $\land$ vacia?(Anteriores($res$))}
[$\Theta(1)$]
[crea un iterador bidireccional del diccionario, de forma tal que HayAnterior evalúe a false (i.e.,
que se pueda recorrer los elementos aplicando iterativamente Siguiente).]
[El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función
EliminarSiguiente. Además, anteriores(res) y siguientes(res) podrían cambiar completamente ante cualquier
operación que modifique d sin utilizar las funciones del iterador.]

~

\InterfazFuncion{HaySiguiente}{\In{it}{itDiccNat($\alpha$)}}{bool}
[true]
{res $=_{obs}$ haySiguiente?($it$)}
[$\Theta(1)$]
[devuelve true si y sólo si en el iterador todavía quedan elementos para avanzar.]
[]

~

\InterfazFuncion{Siguiente}{\In{it}{itDiccNat($\alpha$)}}{tupla(nat,$\alpha$)}
[haySiguiente?(it)]
{alias(res $=_{obs}$ Siguiente($it$))}
[$\Theta(1)$]
[devuelve el elemento siguiente del iterador.]
[res.significado es modificable si y sólo si it es modificable. En cambio, res.clave no es modificable.]

~

\InterfazFuncion{SiguienteSignificado}{\In{it}{itDiccNat($\alpha$)}}{$\alpha$}
[haySiguiente?(it)]
{alias(res $=_{obs}$ haySiguiente?($it$).significado)}
[$\Theta(1)$]
[devuelve el significado del elemento siguiente del iterador]
[res es modificable si y sólo si it es modficable.]

~

\InterfazFuncion{Avanzar}{\Inout{it}{itDiccNat($\alpha$)}}{}
[it $=$ it$_0$ $\land$ haySiguiente?(it)]
{it $=_{obs}$ avanzar(it$_0$)}
[$\Theta(1)$]
[avanza a la posicion siguiente del iterador.]
[]

~

\subsubsection{Especificación de las operaciones auxiliares utilizadas en la interfaz}

\begin{tad}{\tadNombre{DiccNat($\alpha$) extendido}}
	\tadExtiende{Diccionario(nat,$\alpha$)}
	\textbf{otras operaciones (no exportadas)}

	\tadOperacion{esPermutacion?}{secu(tupla(nat,$\alpha$)), diccNat($\alpha$)}{bool}{}
	\tadOperacion{secuADiccNat}{secu(tupla(nat,$\alpha$))}{diccNat($\alpha$)}{}

	\textbf{axiomas}

	\tadAxioma{esPermutacion?(s,d)}{d = secuADiccNat $\land$ $\#$claves = long(s)}
	\tadAxioma{secuADiccNat(s)}{\IF vacia?(s) THEN vacio ELSE definir(prim(s).clave, prim(s).significado, secuADiccNat(fin(s))) FI }
\end{tad}

\pagebreak

\subsection{Representación de DiccNat($\alpha$)}

\begin{Estructura}{DiccNat}[estr]
	\begin{Tupla}[estr]
		\tupItem{tabla}{vector(lista(tupla(clave : nat, significado : $\alpha$)))}
		\tupItem{\\ listaIterable}{lista(puntero(tupla(clave : nat, significado : $\alpha$)))}
		\tupItem{\\ vectorOrdenClaves}{vector(tupla(clave : nat, significado : puntero($\alpha$)))}
	\end{Tupla}
\end{Estructura}

\begin{enumerate}
	\item No existe dos veces el mismo nat en dos posiciones distintas del vector.
	\item La suma del largo de todas las listas enlazadas que salen del vector, tiene que ser igual al largo del vector.
	\item Toda tupla de la tabla es apuntado por un elemento de listaIterable.
	\item El largo de listaIterable es igual al largo del vector.
	\item El vectorOrdenClaves tiene todas las claves de la tabla, el largo es igual al largo de la lista y los punteros van al significado de la clave correspondiente en la tabla
\end{enumerate}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\Rep[estr][e]{
	\\
	($\forall$ $l_1$, $l_2$ : lista(tupla(nat, $\alpha$))) (( (esta?($l_1$,e.tabla) $\land$ esta?($l_2$, e.tabla)) $\\$
	\- \- $\Rightarrow$ ($\forall$ $t_1$,$t_2$ : tupla(nat, $\alpha$) esta?($t_1$,l) $\land$ esta?($t_2$,l))) $\\$
	\- \- $\Rightarrow_{L}$	($\forall$ $n_1$, $n_2$ : nat) $n_1 =_{obs} t_1$.clave $\land n_2 =_{obs} \ t_2$.clave $\land$ $t_1$ $\not =$ $t_2$) $\Rightarrow$ $n_1 \not = n_2$
	$\\ \land \\$
	largosDeListas(e.tabla) $=_{obs}$ longitud(e.tabla)
	$\\ \land \\$
	($\forall$ l : lista(tupla(nat, $\alpha$)))(esta?(l, e.tabla)
		\\ $\Rightarrow$ ($\forall$ t : tupla(nat, $\alpha$))(esta?(t, l)
		\\ $\Rightarrow$ ($\exists$ p : puntero($\alpha$)($\&$t $=_{obs}$ p $\land$ esta?(p, e.listaIterable)))))
	$\\ \land \\$
	long(e.tabla) $=_{obs}$ long(e.listaIterable)
	$\\ \land \\$
	long(e.vectorOrdenClaves) $=_{obs}$ long(e.tabla) $\land$ ($\forall$ l : lista(tupla(nat, $\alpha$)))(esta?(l, e.tabla)
		\\ $\Rightarrow$ ($\forall$ t : tupla(nat, $\alpha$)) (esta?(t, l) \\ $\Rightarrow$ ($\forall$ n : nat) (n $=_{obs}$ t.clave)) \\$\Rightarrow_L$
		($\exists$ p : puntero($\alpha$)) ($\&$t.significado $=_{obs}$ p) $\land$ esta?((t.clave, p), e.vectorOrdenClaves))
}\mbox{}

\tadOperacion{largosDeListas}{secu(secu(tupla(nat,$\alpha$)))}{nat}{}

~

\tadAxioma{largoDeListas($vector$)}{
	\IF vacía?($vector$)) THEN
		0
	ELSE
		longitud(prim($vector$)) + largoDeLista(fin($vector$))
	FI
}

\subsubsection{Funci\'on de Abstracci\'on}

\Abs[estr]{Diccionario}[e]{dicc}{
	($\forall$ $l$ : lista(tupla(nat, $\alpha$))) ((esta?($l$,e.tabla) $\\$
	\- \- $\Rightarrow$ ($\forall$ $t$ : tupla(nat, $\alpha$)) esta?($t$,l) $\\$
	\- $\Rightarrow_{L}$ ($\forall$ $n$ : nat) $n =_{obs} t$.clave $\Leftrightarrow$ $\\$ def?($n$, dicc) $\land_L$ obtener($n$, dicc) $=_{obs}$ $t$.significado))
}

\subsection{Representaci\'on del iterador de DiccNat}

\begin{Estructura}{itDiccNat($\alpha$)}[itDiccNat donde itDiccNat es $\newline$ \- \- \- \- itLista(tupla(nat,$\alpha$))]

\end{Estructura}

\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{crearDiccionario}{\In{v}{vector(tupla(clave : nat, significado :  $\alpha$))}}{estr}'

		nat : i $\leftarrow$ 0 '\ote{1}'
		while i < longitud(v) do '\ote{1}'
			AgregarAtras(res.tabla, vacia()) '\ote{1}'
		end while '\ote{1}'
		i $\leftarrow$ 0 '\ote{1}'
		while i < longitud(v) do '\ote{1}'
			nat : k $\leftarrow$ v[i].clave mod longitud(v) '\ote{1}'
			AgregarAtras(res.tabla[k], v[i]) '\ote{copy($\alpha$)}'
			nat : q $\leftarrow$ longitud(res.tabla[k]) '\ote{i}'
			AgregarAtras(res.listaIterable, puntero(res.tabla[k][q-1])) '\ote{1}'
			i++ '\ote{1}'
		end while '\ote{n * copy($\alpha$) }'

		i $\leftarrow$ 0 '\ote{1}'
		while i < longitud(res.vectorOrdenClaves) do '\ote{1}'
			nat : j $\leftarrow$ i '\ote{1}'
			while j > 0 $\land$ res.vectorOrdenClaves[j] <
										res.vectorOrdenClaves[j-1]) do '\ote{1}'
				tupla(nat, puntero($\alpha$)) : temp $\leftarrow$ res.vectorOrdenClaves[j] '\ote{1}'
				res.vectorOrdenClaves[j] $\leftarrow$ res.vectorOrdenClaves[j-1] '\ote{1}'
				res.vectorOrdenClaves[j-1] $\leftarrow$ temp '\ote{1}'
				j-- '\ote{1}'
			end while '\ote{i}'
			i++ '\ote{1}'
		end while '\ote{$\sum_{i=0}^{longitud(res.vectorOrdenClaves)}$ i}'


'\ofi{O(n^2 + n * copy(\alpha)))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{redefinir}{\Inout{d}{DiccNat($\alpha$)}, \In{n}{nat}, \In{a}{$\alpha$}}{}'

	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	while i < longitud(d[k]) '\ote{1}'
		IF d.tabla[k][i].clave $=_{obs}$ n THEN '\ote{1}'
			d.tabla[k][i].significado $\leftarrow$ a '\ote{i}'
			i $\leftarrow$ longitud(d[k]) '\ote{1}'
		ELSE
			i++ '\ote{1}'
		FI
	end while '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{obtener}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{puntero($\alpha$)}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	res $\leftarrow$ NULL '\ote{1}'
	while 1 < longitud(d[k]) do '\ote{1}'
		IF d.tabla[k][i].clave $=_{obs}$ n THEN '\ote{i}'
			res $\leftarrow$ *d.tabla[k][i].significado '\ote{i}'
			i $\leftarrow$ longitud(d[k]) '\ote{1}'
		ELSE
			i++ '\ote{1}'
		FI
	end for '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{definido?}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{bool}'

	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	res $\leftarrow$ false '\ote{1}'
	while i < longitud(d[k]) do '\ote{1}'
		IF d.tabla[k][i].clave $=_{obs}$ n THEN '\ote{i}'
			res $\leftarrow$ true '\ote{1}'
			i $\leftarrow$ longitud(d.tabla[k]) '\ote{1}'
		FI
		i++ '\ote{1}'
	end while '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{cantClaves}{\In{d}{DiccNat($\alpha$)}}{nat}'

	res $\leftarrow$ longitud(d) '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{OrdenadoPorClave}{\In{d}{DiccNat($\alpha$)}}{vector(tupla(nat, $\alpha$))}'

	res $\leftarrow$ d.vectorOrdenClaves '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{CrearIt}{\In{d}{DiccNat($\alpha$)}}{itDiccNat($\alpha$)}'

	res $\leftarrow$ crearIt(d.listaIterable) '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{HaySiguiente}{\In{it}{itDiccNat($\alpha$)}}{bool}'

	res $\leftarrow$ HaySiguiente(it)

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{Siguiente}{\In{it}{itDiccNat($\alpha$)}}{tupla(nat,$\alpha$)}'

	res $\leftarrow$ Siguiente(it)

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{Avanzar}{\Inout{it}{itDiccNat($\alpha$)}}{}'

	res $\leftarrow$ Avanzar(it)

'\ofi{O(1)}'
\end{lstlisting}
