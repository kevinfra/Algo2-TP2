\section{Módulo Diccionario Nat Fijo}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{Diccionario(nat, $\alpha$ )}.

\textbf{géneros}: \TipoVariable{DiccNat($\alpha$)}.

\subsubsection{Operaciones básicas de DiccNat($\alpha$)}

\InterfazFuncion{crearDiccionario}{\In{v}{vector(tupla(clave : nat, significado :  $\alpha$))}}{DiccNat($\alpha$)}
[true]
{(($\forall$ $t$ : tupla(nat, $\alpha$)) esta?($t$, v)) $\Rightarrow$ ((definido?(t.clave, res))
	$\land_L$ obtener(t.clave,res) $=_{obs}$ t.significado) $\land$ cantClaves(res) $=_{obs}$ longitud(v)}
[$O(copy(\alpha) * n)$ donde n es el largo del vector]
[Agrega las tuplas de clave-significado pasadas por parametro al diccionario $d$]
[Los elementos pasados por parámetros se copian al diccionario]

~

\InterfazFuncion{redefinir}{\Inout{d}{DiccNat($\alpha$), \In{n}{nat}, \In{a}{$\alpha$}}}{}
[definido?(n,d)]
{obtener(n,d) $=_{obs}$ a}
[$O(i)$ donde i es 1 en el caso promedio y longitud(d) en el peor caso.]
[]

~

\InterfazFuncion{obtener}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{puntero($\alpha$)}
[true]
{res $=_{obs}$ obtener(n,d)}
[$O(1)$ en caso promedio, $O(n)$ en peor caso]
[Devuelve un puntero al significado de la clave pasada por parametro. Si no está definido, devuelve NULL]
[El puntero va ser una referencia al significado almacenado en el diccionario]

~

\InterfazFuncion{definido?}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{bool}
[true]
{res $=_{obs}$ def?(a,d)}
[$O(1)$ en caso promedio, $O(n)$ en peor caso]
[Dice si está definida una clave en el diccionario]
[]

~

\InterfazFuncion{cantClaves}{\In{d}{DiccNat($\alpha$)}}{Nat}
[true]
{res $=_{obs} \ \# claves$($d$)}
[$O(1)$]
[Devuelve la cantidad de claves definidas en el diccionario.]
[]

~

\InterfazFuncion{copiar}{\In{d}{DiccNat($\alpha$)}}{DiccNat($\alpha$)}
[true]
{res $=_{obs}$ d}
[$O(n^2 * i * copy(\alpha))$, donde $n$ es el tamaño del DiccNat e $i$ es un valor entre $0$ y $n$ pero que en el caso promedio es $1$]
[Genera una copia nueva del diccionario.]
[]

~

\pagebreak

\subsubsection{Representación de DiccNat($\alpha$)}

\begin{Estructura}{DiccNat($\alpha$)}[estr donde estr es $\newline$ \- \- \- \- vector(lista(tupla $<$clave : nat, significado : $\alpha>$))]

\end{Estructura}

\begin{enumerate}
	\item No existe dos veces el mismo nat en dos posiciones distintas del vector
	\item La suma del largo de todas las listas enlazadas que salen del vector, tiene que ser igual al largo del vector
\end{enumerate}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\Rep[estr][e]{
	\\
			($\forall$ $l_1$, $l_2$ : lista(tupla(nat, $\alpha$))) (( (esta?($l_1$,estr) $\land$ esta?($l_2$, estr)) $\\$
			\- \- $\Rightarrow$ ($\forall$ $t_1$,$t_2$ : tupla(nat, $\alpha$) esta?($t_1$,l) $\land$ esta?($t_2$,l))) $\\$
			\- \- $\Rightarrow_{L}$	($\forall$ $n_1$, $n_2$ : nat) $n_1 =_{obs} t_1$.clave $\land n_2 =_{obs} \ t_2$.clave $\land$ $t_1$ $\not =$ $t_2$) $\Rightarrow$ $n_1 \not = n_2$ $\\$
			$\land$ $\\$
			largosDeListas(estr) $=_{obs}$ longitud(estr)
}\mbox{}

\tadOperacion{largosDeListas}{secu(secu(tupla(nat,$\alpha$)))}{nat}{}

~

\tadAxioma{largoDeListas($vector$)}{
	\IF vacía?($vector$)) THEN
		0
	ELSE
		longitud(prim($vector$)) + largoDeLista(fin($vector$))
	FI
}

\subsubsection{Funci\'on de Abstracci\'on}

\Abs[estr]{Diccionario}[e]{dicc}{
	($\forall$ $l$ : lista(tupla(nat, $\alpha$))) ((esta?($l$,estr) $\\$
	\- \- $\Rightarrow$ ($\forall$ $t$ : tupla(nat, $\alpha$)) esta?($t$,l) $\\$
	\- $\Rightarrow_{L}$ ($\forall$ $n$ : nat) $n =_{obs} t$.clave $\Leftrightarrow$ $\\$ def?($n$, dicc) $\land_L$ obtener($n$, dicc) $=_{obs}$ $t$.significado))
}
\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{crearDiccionario}{\In{v}{vector(tupla(clave : nat, significado :  $\alpha$))}}{estr}'

		nat : i $\leftarrow$ 0 '\ote{1}'
		while i < longitud(v) do '\ote{1}'
			AgregarAtras(res, vacia()) '\ote{i}'
		end while '\ote{$\sum_{i=0}^{n}$ i}'
		i $\leftarrow$ 0 '\ote{1}'
		while i < longitud(v) do '\ote{1}'
			nat : k $\leftarrow$ v[i].clave mod longitud(v) '\ote{1}'
			AgregarAtras(res[k], v[i]) '\ote{copy($\alpha$)}'
			i++ '\ote{1}'
		end while '\ote{n * copy($\alpha$)}'

'\ofi{O(n^2 + n * copy(\alpha)))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{redefinir}{\Inout{d}{DiccNat($\alpha$)}, \In{n}{nat}, \In{a}{$\alpha$}}{}'

	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	while i < longitud(d[k]) '\ote{1}'
		IF d[k][i].clave $=_{obs}$ n THEN '\ote{1}'
			d[k][i].significado $\leftarrow$ a '\ote{i}'
			i $\leftarrow$ longitud(d[k]) '\ote{1}'
		ELSE
			i++ '\ote{1}'
		FI
	end while '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{obtener}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{puntero($\alpha$)}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	res $\leftarrow$ NULL '\ote{1}'
	while 1 < longitud(d[k]) do '\ote{1}'
		IF d[k][i].clave $=_{obs}$ n THEN '\ote{i}'
			res $\leftarrow$ *d[k][i].significado '\ote{i}'
			i $\leftarrow$ longitud(d[k]) '\ote{1}'
		ELSE
			i++ '\ote{1}'
		FI
	end for '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{definido?}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{bool}'

	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	res $\leftarrow$ false '\ote{1}'
	while i < longitud(d[k]) do '\ote{1}'
		IF d[k][i].clave $=_{obs}$ n THEN '\ote{i}'
			res $\leftarrow$ true '\ote{1}'
			i $\leftarrow$ longitud(d[k]) '\ote{1}'
		FI
		i++ '\ote{1}'
	end while '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{cantClaves}{\In{d}{DiccNat($\alpha$)}}{nat}'

	res $\leftarrow$ longitud(d) '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{copiar}{\In{d}{DiccNat($\alpha$)}}{DiccNat($\alpha$)}'

	nat : k $\leftarrow$ 0 '\ote{1}'
	while k < longitud(d) do '\ote{1}'
		AgregarAtras(res, vacia()) '\ote{k}'
		nat : i $\leftarrow$ 0 '\ote{1}'
		while i < long(d[k]) do '\ote{1}'
			AgregarAtras(res[k], d[k][i]) '\ote{copy($\alpha$)}'
			i++ '\ote{1}'
		end while '\ote{i}'
		k++ '\ote{1}'
	end while '\ote{n * k  * i}'

'\ofi{O(n^2 * i * copy(\alpha))} %donde $i$ es 1 en caso promedio y $k$ crece en funcion de $n$ hasta llegar a $n$}'
\end{lstlisting}
