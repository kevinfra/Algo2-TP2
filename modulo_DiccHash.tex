\section{Módulo Diccionario Nat Fijo}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{Diccionario(nat, $\alpha$ )}.

\textbf{géneros}: \TipoVariable{DiccNat($\alpha$)}.

\subsubsection{Operaciones básicas de DiccNat($\alpha$)}

\InterfazFuncion{crearDiccionario}{\In{v}{vector(tupla(clave : nat, significado :  $\alpha$))}}{DiccNat($\alpha$)}
[true]
{(($\forall$ $t$ : tupla(nat, $\alpha$)) esta?($t$, v)) $\Rightarrow$ ((definido?(t.clave, res))
	$\land_L$ obtener(t.clave,res) $=_{obs}$ t.significado) $\land$ cantClaves(res) $=_{obs}$ longitud(v)}
[$O(copy(\alpha) * n)$ donde n es el largo del vector]
[Agrega las tuplas de clave-significado pasadas por parametro al diccionario $d$]
[Los elementos pasados por parámetros se copian al diccionario]

~

\InterfazFuncion{redefinir}{\Inout{d}{DiccNat($\alpha$), \In{n}{nat}, \In{a}{$\alpha$}}}{}
[definido?(n,d)]
{obtener(n,d) $=_{obs}$ a}
[$O(i)$ donde i es 1 en el caso promedio y longitud(d) en el peor caso.]
[]

~

\InterfazFuncion{obtener}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{puntero($\alpha$)}
[true]
{res $=_{obs}$ obtener(n,d)}
[$O(1)$ en caso promedio, $O(n)$ en peor caso]
[Devuelve un puntero al significado de la clave pasada por parametro. Si no está definido, devuelve NULL]
[El puntero va ser una referencia al significado almacenado en el diccionario]

~

\InterfazFuncion{definido?}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{bool}
[true]
{res $=_{obs}$ def?(a,d)}
[$O(1)$ en caso promedio, $O(n)$ en peor caso]
[Dice si está definida una clave en el diccionario]
[]

~

\InterfazFuncion{cantClaves}{\In{d}{DiccNat($\alpha$)}}{Nat}
[true]
{res $=_{obs} \ \# claves$($d$)}
[$O(1)$]
[Devuelve la cantidad de claves definidas en el diccionario.]
[]

~

\InterfazFuncion{copiar}{\In{d}{DiccNat($\alpha$)}}{DiccNat($\alpha$)}
[true]
{res $=_{obs}$ d}
[$O(n^2 * i * copy(\alpha))$, donde $n$ es el tamaño del DiccNat e $i$ es un valor entre $0$ y $n$ pero que en el caso promedio es $1$]
[Genera una copia nueva del diccionario.]
[]

~

\subsubsection{Operaciones básicas del iterador}

Este iterador permite recorrer la tabla de hash sobre la que est\'{a} implementado el diccionario para obtener cada clave con su respectivo significado sin modificar ning\'{u}n dato del diccionario.

\InterfazFuncion{CrearIt}{\In{d}{DiccNat($\alpha$)}}{itDiccNat($\alpha$)}
[true]
{alias(esPermutación(SecuSuby($res$), $d$)) $\land$ vacia?(Anteriores($res$))}
[$\Theta(1)$]
[crea un iterador bidireccional del diccionario, de forma tal que HayAnterior evalúe a false (i.e.,
que se pueda recorrer los elementos aplicando iterativamente Siguiente).]
[El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función
EliminarSiguiente. Además, anteriores(res) y siguientes(res) podrían cambiar completamente ante cualquier
operación que modifique d sin utilizar las funciones del iterador.]

~

\InterfazFuncion{HaySiguiente}{\In{it}{itDiccNat($\alpha$)}}{bool}
[true]
{res $=_{obs}$ haySiguiente?($it$)}
[$\Theta(1)$]
[devuelve true si y sólo si en el iterador todavía quedan elementos para avanzar.]
[]

~

\InterfazFuncion{HayAnterior}{\In{it}{itDiccNat($\alpha$)}}{bool}
[true]
{res $=_{obs}$ hayAnterior?($it$)}
[$\Theta(1)$]
[devuelve true si y sólo si en el iterador todavía quedan elementos para retroceder.]
[]

~

\InterfazFuncion{Siguiente}{\In{it}{itDiccNat($\alpha$)}}{tupla(nat,$\alpha$)}
[haySiguiente?(it)]
{alias(res $=_{obs}$ Siguiente($it$))}
[$\Theta(1)$]
[devuelve el elemento siguiente del iterador.]
[res.significado es modificable si y sólo si it es modificable. En cambio, res.clave no es modificable.]

~


\InterfazFuncion{SiguienteClave}{\In{it}{itDiccNat($\alpha$)}}{nat}
[haySiguiente?(it)]
{alias(res $=_{obs}$ haySiguiente?($it$).clave)}
[$\Theta(1)$]
[devuelve la clave del elemento siguiente del iterador.]
[res no es modificable]

~

\InterfazFuncion{SiguienteSignificado}{\In{it}{itDiccNat($\alpha$)}}{$\alpha$}
[haySiguiente?(it)]
{alias(res $=_{obs}$ haySiguiente?($it$).significado)}
[$\Theta(1)$]
[devuelve el significado del elemento siguiente del iterador]
[res es modificable si y sólo si it es modficable.]

~

\InterfazFuncion{Anterior}{\In{it}{itDiccNat($\alpha$)}}{tupla(nat,$\alpha$)}
[hayAnterior?(it)]
{alias(res $=_{obs}$ Anterior($it$))}
[$\Theta(1)$]
[devuelve el elemento anterior del iterador.]
[res.significado es modificable si y sólo si it es modificable. En cambio, res.clave no es modificable.]

~

\InterfazFuncion{AnteriorClave}{\In{it}{itDiccNat($\alpha$)}}{nat}
[hayAnterior?(it)]
{alias(res $=_{obs}$ haySiguiente?($it$).clave)}
[$\Theta(1)$]
[devuelve la clave del elemento anterior del iterador]
[res no es modificable.]

~

\InterfazFuncion{AnteriorSignificado}{\In{it}{itDiccNat($\alpha$)}}{$\alpha$}
[hayAnterior?(it)]
{alias(res $=_{obs}$ haySiguiente?($it$).significado)}
[$\Theta(1)$]
[devuelve el significado del elemento anterior del iterador]
[res es modificable si y sólo si it es modficable.]

~

\InterfazFuncion{Avanzar}{\Inout{it}{itDiccNat($\alpha$)}}{}
[it $=$ it$_0$ $\land$ haySiguiente?(it)]
{it $=_{obs}$ avanzar(it$_0$)}
[$\Theta(1)$]
[avanza a la posicion siguiente del iterador.]
[]

~

\InterfazFuncion{Retroceder}{\Inout{it}{itDiccNat($\alpha$)}}{}
[it $=$ it$_0$ $\land$ hayAnterior?(it)]
{it $=_{obs}$ hayAnterior?(it$_0$)}
[$\Theta(1)$]
[retrocede a la posicion anterior del iterador.]
[]

~

\subsubsection{Especificación de las operaciones auxiliares utilizadas en la interfaz}

\begin{tad}{\tadNombre{DiccNat($\alpha$) extendido}}
	\tadExtiende{Diccionario(nat,$\alpha$)}
	\textbf{otras operaciones (no exportadas)}

	\tadOperacion{esPermutacion?}{secu(tupla(nat,$\alpha$)), diccNat($\alpha$)}{bool}{}
	\tadOperacion{secuADiccNat}{secu(tupla(nat,$\alpha$))}{diccNat($\alpha$)}{}

	\textbf{axiomas}

	\tadAxioma{esPermutacion?(s,d)}{d = secuADiccNat $\land$ $\#$claves = long(s)}
	\tadAxioma{secuADiccNat(s)}{\IF vacia?(s) THEN vacio ELSE definir(prim(s).clave, prim(s).significado, secuADiccNat(fin(s))) FI }
\end{tad}

\pagebreak

\subsection{Representación de DiccNat($\alpha$)}

\begin{Estructura}{DiccNat($\alpha$)}[estr donde estr es $\newline$ \- \- \- \- vector(lista(tupla $<$clave : nat, significado : $\alpha>$))]

\end{Estructura}

\begin{enumerate}
	\item No existe dos veces el mismo nat en dos posiciones distintas del vector
	\item La suma del largo de todas las listas enlazadas que salen del vector, tiene que ser igual al largo del vector
\end{enumerate}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\Rep[estr][e]{
	\\
			($\forall$ $l_1$, $l_2$ : lista(tupla(nat, $\alpha$))) (( (esta?($l_1$,estr) $\land$ esta?($l_2$, estr)) $\\$
			\- \- $\Rightarrow$ ($\forall$ $t_1$,$t_2$ : tupla(nat, $\alpha$) esta?($t_1$,l) $\land$ esta?($t_2$,l))) $\\$
			\- \- $\Rightarrow_{L}$	($\forall$ $n_1$, $n_2$ : nat) $n_1 =_{obs} t_1$.clave $\land n_2 =_{obs} \ t_2$.clave $\land$ $t_1$ $\not =$ $t_2$) $\Rightarrow$ $n_1 \not = n_2$ $\\$
			$\land$ $\\$
			largosDeListas(estr) $=_{obs}$ longitud(estr)
}\mbox{}

\tadOperacion{largosDeListas}{secu(secu(tupla(nat,$\alpha$)))}{nat}{}

~

\tadAxioma{largoDeListas($vector$)}{
	\IF vacía?($vector$)) THEN
		0
	ELSE
		longitud(prim($vector$)) + largoDeLista(fin($vector$))
	FI
}

\subsubsection{Funci\'on de Abstracci\'on}

\Abs[estr]{Diccionario}[e]{dicc}{
	($\forall$ $l$ : lista(tupla(nat, $\alpha$))) ((esta?($l$,estr) $\\$
	\- \- $\Rightarrow$ ($\forall$ $t$ : tupla(nat, $\alpha$)) esta?($t$,l) $\\$
	\- $\Rightarrow_{L}$ ($\forall$ $n$ : nat) $n =_{obs} t$.clave $\Leftrightarrow$ $\\$ def?($n$, dicc) $\land_L$ obtener($n$, dicc) $=_{obs}$ $t$.significado))
}
\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{crearDiccionario}{\In{v}{vector(tupla(clave : nat, significado :  $\alpha$))}}{estr}'

		nat : i $\leftarrow$ 0 '\ote{1}'
		while i < longitud(v) do '\ote{1}'
			AgregarAtras(res, vacia()) '\ote{i}'
		end while '\ote{$\sum_{i=0}^{n}$ i}'
		i $\leftarrow$ 0 '\ote{1}'
		while i < longitud(v) do '\ote{1}'
			nat : k $\leftarrow$ v[i].clave mod longitud(v) '\ote{1}'
			AgregarAtras(res[k], v[i]) '\ote{copy($\alpha$)}'
			i++ '\ote{1}'
		end while '\ote{n * copy($\alpha$)}'

'\ofi{O(n^2 + n * copy(\alpha)))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{redefinir}{\Inout{d}{DiccNat($\alpha$)}, \In{n}{nat}, \In{a}{$\alpha$}}{}'

	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	while i < longitud(d[k]) '\ote{1}'
		IF d[k][i].clave $=_{obs}$ n THEN '\ote{1}'
			d[k][i].significado $\leftarrow$ a '\ote{i}'
			i $\leftarrow$ longitud(d[k]) '\ote{1}'
		ELSE
			i++ '\ote{1}'
		FI
	end while '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{obtener}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{puntero($\alpha$)}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	res $\leftarrow$ NULL '\ote{1}'
	while 1 < longitud(d[k]) do '\ote{1}'
		IF d[k][i].clave $=_{obs}$ n THEN '\ote{i}'
			res $\leftarrow$ *d[k][i].significado '\ote{i}'
			i $\leftarrow$ longitud(d[k]) '\ote{1}'
		ELSE
			i++ '\ote{1}'
		FI
	end for '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{definido?}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{bool}'

	nat : k $\leftarrow$ n mod longitud(d) '\ote{1}'
	nat : i $\leftarrow$ 0 '\ote{1}'
	res $\leftarrow$ false '\ote{1}'
	while i < longitud(d[k]) do '\ote{1}'
		IF d[k][i].clave $=_{obs}$ n THEN '\ote{i}'
			res $\leftarrow$ true '\ote{1}'
			i $\leftarrow$ longitud(d[k]) '\ote{1}'
		FI
		i++ '\ote{1}'
	end while '\ote{i}'

'\ofi{O(i)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{cantClaves}{\In{d}{DiccNat($\alpha$)}}{nat}'

	res $\leftarrow$ longitud(d) '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{copiar}{\In{d}{DiccNat($\alpha$)}}{DiccNat($\alpha$)}'

	nat : k $\leftarrow$ 0 '\ote{1}'
	while k < longitud(d) do '\ote{1}'
		AgregarAtras(res, vacia()) '\ote{k}'
		nat : i $\leftarrow$ 0 '\ote{1}'
		while i < long(d[k]) do '\ote{1}'
			AgregarAtras(res[k], d[k][i]) '\ote{copy($\alpha$)}'
			i++ '\ote{1}'
		end while '\ote{i}'
		k++ '\ote{1}'
	end while '\ote{n * k  * i}'

'\ofi{O(n^2 * i * copy(\alpha))} %donde $i$ es 1 en caso promedio y $k$ crece en funcion de $n$ hasta llegar a $n$}'
\end{lstlisting}
