\section{Módulo Diccionario Nat Fijo}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{Diccionario(nat, $\alpha$ )}.

\textbf{géneros}: \TipoVariable{DiccNat($\alpha$)}.

\subsubsection{Operaciones básicas de DiccNat($\alpha$)}

\InterfazFuncion{crearDiccionario}{\In{v}{vector(tupla(clave : nat, significado :  $\alpha$))}}{DiccNat($\alpha$)}
[true]
{(($\forall$ $t$ : tupla(nat, $\alpha$)) $t$ esta?(v)) $\Rightarrow$ ((definido?(t.clave, res))
	$\land_L$ obtener(t.clave,res) $=_{obs}$ t.significado) $\land$ nClaves(res) $=_{obs}$ longitud(v)}
[$O(copy(a)) + O(Cd)$ donde Cd es el numero de claves de d]
[Agrega una clave $n$ con el significado $a$ al diccionario $d$]
[Los elementos pasados por parámetros se copian al diccionario]

~

\InterfazFuncion{obtener}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{puntero($\alpha$)}
[true]
{res $=_{obs}$ obtener(n,d)}
[$O(1)$ en caso promedio, $O(n)$ en peor caso]
[Devuelve un puntero al significado de la clave pasada por parametro. Si no está definido, devuelve NULL]
[El puntero va ser una referencia al significado almacenado en el diccionario]

~

\InterfazFuncion{definido?}{\In{n}{nat}, \In{d}{DiccNat($\alpha$)}}{bool}
[true]
{res $=_{obs}$ def?(a,d)}
[$O(1)$ en caso promedio, $O(n)$ en peor caso]
[Dice si está definida una clave en el diccionario]
[]

~

\InterfazFuncion{nClaves}{\In{d}{DiccNat($\alpha$)}}{Nat}
[true]
{res $=_{obs}$ $ \# claves$($d$)}
[$O(1)$]
[Mueve un agente dentro del campus y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{copiar}{\In{d}{DiccNat($\alpha$)}}{DiccNat($\alpha$)}
[true]
{res $=_{obs}$ d}
[$O(n*(copy(k)))$ , donde K son los valores del tipo $\alpha$ pertenecientes al diccionario y n es $\#$Claves(d)]
[Genera una copia nueva del diccionario.]
[]

~

\pagebreak

\subsubsection{Representación de DiccNat($\alpha$)}

\begin{Estructura}{DiccNat($\alpha$)}[estr donde estr es $\newline$ \- \- \- \- vector(lista(tupla $<$clave : nat, significado : $\alpha>$))]

\end{Estructura}

\begin{enumerate}
	\item No existe dos veces el mismo nat en dos posiciones distintas del vector
	\item La suma del largo de todas las listas enlazadas que salen del vector, tiene que ser igual al largo del vector
\end{enumerate}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\Rep[estr][e]{
	\\
			($\forall$ $l_1$, $l_2$ : lista(tupla(nat, $\alpha$))) (( (esta?($l_1$,estr) $\land$ esta?($l_2$, estr)) $\\$
			\- \- $\Rightarrow$ ($\forall$ $t_1$,$t_2$ : tupla(nat, $\alpha$) esta?($t_1$,l) $\land$ esta?($t_2$,l))) $\\$
			\- \- $\Rightarrow_{L}$	($\forall$ $n_1$, $n_2$ : nat) $n_1 =_{obs} t_1$.clave $\land n_2 =_{obs} \ t_2$.clave $\land$ $t_1$ $\not =$ $t_2$) $\Rightarrow$ $n_1 \not = n_2$ $\\$
			$\land$ $\\$
			largosDeListas(estr) $=_{obs}$ longitud(estr)
}\mbox{}

\tadOperacion{largosDeListas}{secu(secu(tupla(nat,$\alpha$)))}{nat}{}

~

\tadAxioma{largoDeListas($vector$)}{
	\IF vacía?($vector$)) THEN
		0
	ELSE
		longitud(prim($vector$)) + largoDeLista(fin($vector$))
	FI
}

\subsubsection{Funci\'on de Abstracci\'on}

\Abs[estr]{Diccionario}[e]{dicc}{
	($\forall$ $l$ : lista(tupla(nat, $\alpha$))) ((esta?($l$,estr) $\\$
	\- \- $\Rightarrow$ ($\forall$ $t$ : tupla(nat, $\alpha$)) esta?($t$,l) $\\$
	\- $\Rightarrow_{L}$ ($\forall$ $n$ : nat) $n =_{obs} t$.clave $\Leftrightarrow$ $\\$ def?($n$, dicc) $\land_L$ obtener($n$, dicc) $=_{obs}$ $t$.significado))
}
\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{crearDiccionario}{\In{v}{vector(tupla(clave : nat, significado :  $\alpha$))}}{estr}'

		nat : i $\leftarrow$ 0 '\ote{1}'
		while i < long(v) do '\ote{1}'
			AgregarAtras(res, vacia()) '\ote{i}'
		end while '\ote{$\sum_{i=0}^{n}$ i}'
		i $\leftarrow$ 0 '\ote{1}'
		while i < long(v) do '\ote{1}'
			nat : k $\leftarrow$ v[i].clave mod long(v) '\ote{1}'
			AgregarAtras(res[k], v[i]) '\ote{copy($\alpha$)}'
			i++ '\ote{1}'
		end while '\ote{n * copy($\alpha$)}'

'\ofi{O(n^2 + n * copy(\alpha)))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iCrearPaquete}{\Inout{dcn}{dcnet}, \In{p}{paquete}}{}'

	puntero(compuDCNet): compudcnet $\leftarrow$
		Significado(dcn.diccCompusDCNet, p.origen.ip) '\ote{L}'
	itConj(paquete): itPaq $\leftarrow$ AgregarRapido(compudcnet$\rightarrow$conjPaquetes, p) '\ote{1}'
	lista(compu): recorr $\leftarrow$ AgregarAtras(Vacia(), p.origen) '\ote{1}'
	paqueteDCNet: paqDCNet $\leftarrow$ <itPaq, recorr> '\ote{1}'

	itConj(paqueteDCNet): itPaqDCNet $\leftarrow$
		AgregarRapido(dcn.conjPaquetesDCNet, paqDCNet) '\ote{1}'
	Definir(compudcnet$\rightarrow$diccPaquetesDCNet, p.id, itPaqDCNet) '\ote{log(k)}'
	Encolar(compudcnet$\rightarrow$colaPaquetesDCNet, p.prioridad, itPaqDCNet) '\ote{log(k)}'

'\ofi{O(log(k) + L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iAvanzarSegundo}{\Inout{dcn}{dcnet}}{}'

	nat: maxEnviados $\leftarrow$ 0
	nat: i $\leftarrow$ 0 '\ote{1}'
	while i < Longitud(dcn.vectorCompusDCNet) do '\ote{1}'
		if($\neg$EsVacia?(dcn.vectorCompusDCNet[i].colaPaquetesDCNet)) then
			dcn.vectorCompusDCNet[i].paqueteAEnviar $\leftarrow$
				Desencolar(dcn.vectorCompusDCNet[i].colaPaquetesDCNet) '\ote{log(k)}'
		end if
		i++ '\ote{1}'
	end while '\ote{n * log(k)}'

	i $\leftarrow$ 0 '\ote{1}'
	while i < Longitud(dcn.vectorCompusDCNet) do '\ote{1}'
		if(HaySiguiente?(dcn.vectorCompusDCNet[i].paqueteAEnviar)) then '\ote{1}'

			dcn.vectorCompusDCNet[i].enviados++ '\ote{1}'
			if(dcn.vectorCompusDCNet[i].enviados > maxEnviados) then '\ote{1}'
				dcn.laQueMasEnvio $\leftarrow$ puntero(dcn.vectorCompusDCNet[i]) '\ote{1}'
			end if

			paquete: pAEnviar $\leftarrow$
				Siguiente(Siguiente(dcn.vectorCompusDCNet[i].paqueteAEnviar).it) '\ote{1}'
			itConj(lista(compu)): itercaminos $\leftarrow$
				CrearIt(CaminosMinimos(dcn.topologia,
				*(dcn.vectorCompusDCNet[i].pc), pAEnviar.destino)) '\ote{1}'
			compu: siguientecompu $\leftarrow$ Siguiente(itercaminos)[1] '\ote{1}'

			if(pAEnviar.destino $\neq$ siguientecompu) then '\ote{1}'

				compuDCNet: siguientecompudcnet $\leftarrow$
					*(Obtener(dcn.diccCompusDCNet, siguientecompu.ip)) '\ote{L}'

				itConj(paquete): itpaquete $\leftarrow$
					AgregarRapido(siguientecompudcnet.conjPaquetes, pAEnviar) '\ote{1}'

				itConj(paqueteDCNet): paqAEnviar $\leftarrow$
					Obtener(dcn.vectorCompusDCNet[i].diccPaquetesDCNet,
					pAEnviar.id) '\ote{log(k)}'

				AgregarAtras(Siguiente(paqAEnviar).recorrido, siguientecompu) '\ote{1}'

				Encolar(siguientecompudcnet.colaPaquetesDCNet,
					pAEnviar.prioridad, paqAEnviar) '\ote{log(k)}'
				Definir(siguientecompudcnet.diccPaquetesDCNet,
					pAEnviar.id, paqAEnviar) '\ote{log(k)}'
			end if

			Borrar(dcn.vectorCompusDCNet[i].diccPaquetesDCNet,
				Siguiente(dcn.vectorCompusDCNet[i].paqueteAEnviar$\rightarrow$it).id) '\ote{log(k)}'
			EliminarSiguiente(Siguiente(dcn.vectorCompusDCNet[i].paqueteAEnviar).it)
				'\ote{1}'
			EliminarSiguiente(dcn.vectorCompusDCNet[i].paqueteAEnviar) '\ote{1}'

			dcn.vectorCompusDCNet[i].paqueteAEnviar $\leftarrow$ CrearIt(Vacio()) '\ote{1}'

		end if
		i++ '\ote{1}'
	end while '\ote{n * (L + log(k))}'

'\ofi{O(n * (L + log(k)))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{Red}{\In{dcn}{dcnet}}{red}'

	res $\leftarrow$ dcn.topologia '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{CaminoRecorrido}{\In{dcn}{dcnet}, \In{p}{paquete}}{lista(compu)}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	while i < Longitud(dcn.vectorCompusDCNet) do '\ote{1}'
		if Definido?(dcn.vectorCompusDCNet[i].diccPaquetesDCNet, p.id) then '\ote{log(k)}'
			res $\leftarrow$ Siguiente(Obtener(dcn.vectorCompusDCNet[i].diccPaquetesDCNet,
				p.id)).recorrido '\ote{log(k)}'
		end if
		i++ '\ote{1}'
	end while '\ote{n * log(k)}'

'\ofi{O(n * log(k))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{CantidadEnviados}{\In{dcn}{dcnet}, \In{c}{compu}}{nat}'

	res $\leftarrow$ Obtener(dcn.diccCompusDCNet, c.ip)$\rightarrow$enviados '\ote{L}'

'\ofi{O(L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{EnEspera}{\In{dcn}{dcnet}, \In{c}{compu}}{nat}'

	res $\leftarrow$ Obtener(dcn.diccCompusDCNet, c.ip)$\rightarrow$conjPaquetes '\ote{L}'

'\ofi{O(L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{PaqueteEnTransito}{\In{dcn}{dcnet}, \In{p}{paquete}}{bool}'

	res $\leftarrow$ false
	nat: i $\leftarrow$ 0 '\ote{1}'
	while i < Longitud(dcn.vectorCompusDCNet) do '\ote{1}'
		if Definido?(dcn.vectorCompusDCNet[i].diccPaquetesDCNet, p.id) then '\ote{log(k)}'
			res $\leftarrow$ true '\ote{1}'
		end if
		i++ '\ote{1}'
	end while '\ote{n * log(k)}'

'\ofi{O(n * log(k))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{LaQueMasEnvio}{\In{dcn}{dcnet}}{compu}'

	res $\leftarrow$ *(dcn.laQueMasEnvio$\rightarrow$pc) '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{$\puntito$ $=_i$ $\puntito$}{\In{dcn_1}{dcnet}, \In{dcn_2}{dcnet}}{bool}'

	bool: boolTopo $\leftarrow$ $dcn_1$.topologia = $dcn_2$.topologia '\ote{n + $L^2$}'
	bool: boolVec $\leftarrow$ $dcn_1$.vectorCompusDCNet = $dcn_2$.vectorCompusDCNet '\ote{n * k * (k + n)}'
	bool: boolConj $\leftarrow$ $dcn_1$.conjPaquetesDCNet = $dcn_2$.conjPaquetesDCNet '\ote{$k^3$ * (k + n)}'
	bool: boolMasEnvio $\leftarrow$ *($dcn_1$.laQueMasEnvio) = *($dcn_2$.laQueMasEnvio) '\ote{1}'

	res $\leftarrow$ boolTopo $\land$ boolVec $\land$ boolTrie $\land$ boolConj $\land$ boolMasEnvio '\ote{1}'

'\ofi{O(n * k^3 * (k + n))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{$\puntito$ $=_{compudcn}$ $\puntito$}{\In{c_1}{compuDCNet}, \In{c_2}{compuDCNet}}{bool}'

	bool: boolPC $\leftarrow$ *($c_1$.pc) = *($c_2$.pc) '\ote{1}'
	bool: boolConj $\leftarrow$ $c_1$.conjPaquetes = $c_1$.conjPaquetes '\ote{$k^2$}'
	bool: boolAVL $\leftarrow$ true '\ote{1}'
	bool: boolCola $\leftarrow$ true '\ote{1}'
	bool: boolPaq $\leftarrow$ Siguiente($c_1$.paqueteAEnviar) $=_{paqdcn}$ Siguiente($c_2$.paqueteAEnviar)
		'\ote{n}'
	bool: boolEnviados $\leftarrow$ $c_1$.enviados = $c_2$.enviados '\ote{1}'

	if boolConj then '\ote{1}'
		itConj: $itconj_1$ $\leftarrow$ CrearIt($c_1$.conjPaquetes) '\ote{1}'
		while HaySiguiente?($itconj_1$) do '\ote{1}'
			if Definido?($c_2$.diccPaquetesDCNet, Siguiente($itconj_1$)).id then '\ote{log(n)}'
				if $\neg$(Siguiente(Obtener($c_1$.diccPaquetesDCNet, Siguiente($itconj_1$).id))
					$=_{paqdcn}$
					Siguiente(Obtener($c_1$.diccPaquetesDCNet, Siguiente($itconj_1$).id)))
					then '\ote{n}'
					boolAVL $\leftarrow$ false '\ote{1}'
				end if
			else
				boolAVL $\leftarrow$ false '\ote{1}'
			end if
			Avanzar($itconj_1$) '\ote{1}'
		end while '\ote{n * k}'
	end if

	if EsVacia($c_1$.colaPrioridad) then '\ote{1}'
		if $\neg$EsVacia($c_2$.colaPrioridad) then '\ote{1}'
			boolCola $\leftarrow$ false '\ote{1}'
		end if
	else
		if EsVacia($c_1$.colaPrioridad) then '\ote{1}'
			boolCola $\leftarrow$ false '\ote{1}'
		else
			if $\neg$(Siguiente(Proximo($c_1$.colaPrioridad)) $=_{paqdcn}$
				Siguiente(Proximo($c_2$.colaPrioridad))) then '\ote{n}'
				boolCola $\leftarrow$ false '\ote{1}'
			end if
		end if
	end if

	res $\leftarrow$ boolPC $\land$ boolConj $\land$ boolAVL $\land$ boolCola $\land$ boolPaq $\land$ boolEnviados '\ote{1}'

'\ofi{O(k^2 + n * k) = O(k * (k + n))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{$\puntito$ $=_{paqdcn}$ $\puntito$}{\In{p_1}{paqueteDCNet}, \In{p_2}{paqueteDCNet},}{bool}'

	bool: boolPaq $\leftarrow$ Siguiente($p_1$.it) = Siguiente($p_2$.it) '\ote{1}'
	bool: boolRecorrido $\leftarrow$ $p_1$.recorrido = $p_2$.recorrido '\ote{n}'

	res $\leftarrow$ boolPaq $\land$ boolRecorrido '\ote{1}'

'\ofi{O(n)}'
\end{lstlisting}
