\section{Módulo CampusSeguro}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{CampusSeguro}.

\textbf{géneros}: \TipoVariable{campusSeguro}.

\subsubsection{Operaciones básicas de CampusSeguro}

\InterfazFuncion{comenzarRastrillaje}{\In{c}{campus}, \In{d}{diccNat(agente,datosAgente)}}{campusSeguro}
[($\forall a$ : agente) (def?($a$,$d$) $\Rightarrow_L$ (posVálida(obtener($a$,$d$)) $\land$ $\neg$ocupada?(obtener($a$,$d$,$c$))) $\land$ ($\forall a, a2$ : agente) ((def?($a$,$d$) $\land$ def?($a2$,$d$) $\land a \neq a2$) $\Rightarrow_L$ obtener($a$,$d$) $\neq$ obtener($a2$,$d$))]
{res $=_{obs}$ comenzarRastrillaje(c,d)}
[$O((f*c) + N_a)$]
[Crea un nuevo campusSeguro tomando un campus y un diccionario con agentes.]
[Se genera aliasing campus y en el diccionario que se pasan por parametro.]

~

\InterfazFuncion{ingresarEstudiante}{\In{e}{nombre}, \In{p}{posición}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land e \not\in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)) $\land$ esIngreso?($p$,campus($cs$)) $\land$ $\neg$estaOcupada?($p$,$cs$)]
{$cs =_{obs}$ ingresarEstudiante($e$,$p$,$cs_o$)}
[$O(|n_m|)$]
[Ingresa un nuevo estudiante al campusSeguro]
[]

~

\InterfazFuncion{ingresarHippie}{\In{h}{nombre}, \In{p}{posición}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land h \not\in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)) $\land$ esIngreso?($p$,campus($cs$)) $\land$ $\neg$estaOcupada?($p$,$cs$)]
{$cs =_{obs}$ ingresarHippie($h$,$p$,$cs_o$)}
[$O(|n_m|)$]
[Ingresa un nuevo hippie el campusSeguro]
[]

~

\InterfazFuncion{moverEstudiante}{\In{e}{nombre}, \In{dir}{dirección}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land e \in$ estudiantes($cs$) $\land$ (seRetira($e$,$dir$,$cs$) $\lor$ \\
(posValida(proxPosicion(posEstudianteYHippie($e$,$cs$),$dir$,campus($cs$)), campus($cs$)) $\land$ $\neg$estaOcupada?(proxPosicion(posEstudianteYHippie($e$,$cs$),$dir$,campus($cs$)),$cs$)]
{$cs =_{obs}$ moverEstudiante($e$,$dir$,$cs_o$)}
[$O(|n_m|)$]
[Mueve un estudiante dentro del campus o lo hace salir y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{moverHippie}{\In{h}{nombre}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land h \in$ hippies($cs$) $\land$ $\neg$todasOcupadas?(vecinos(posEstudianteYHippie($h$,$cs$),campus($cs$)), $cs$)]
{$cs =_{obs}$ moverHippie($h$,$d$,$cs_o$}
[$O(|n_m|) + O(N_e)$]
[Mueve un hippie dentro del campus y se actualizan los atrapados, sanciones(si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{moverAgente}{\In{a}{agente}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land a \in$ agentes($cs$) $\land_L$ cantSanciones($a$,$cs$) $\leq 3 \land$ \\
$\neg$todasOcupadas?(vecinos(posEstudianteYHippie($h$,$cs$),campus($cs$)),$cs$)]
{$cs =_{obs}$ moverAgente($a$,$cs_o$)}
[$O(|n_m|) + O(log(N_a)) + O(N_h)$]
[Mueve un agente dentro del campus y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{campus}{\In{cs}{campusSeguro}}{campus}
[true]
{$res =_{obs}$ campus($cs$)}
[$O(1)$]
[Devuelve el campus del campusSeguro.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{estudiantes}{\In{cs}{campusSeguro}}{itDiccString(nombre, posicion)}
[true]
{$res =_{obs}$ estudiantes($cs$)}
[$O(1)$]
[Devuelve el conjunto de los estudiantes que estan en el campus.]
[$res$ es un iterador no modificable.]

~

\InterfazFuncion{hippies}{\In{cs}{campusSeguro}}{itDiccString(nombre, posicion)}
[true]
{$res =_{obs}$ hippies($cs$)}
[$O(1)$]
[Devuelve el conjunto de los hippies que estan en el campus.]
[$res$ es un iterador no modificable.]

~

\InterfazFuncion{agentes}{\In{cs}{campusSeguro}}{itDiccNat(agente,datosAgente)}
[true]
{$res =_{obs}$ agentes($cs$)}
[$O(1)$]
[Devuelve un iterador al diccionario de los agentes que estan en el campus.]
[$res$ es un interador no modificable.]

~

\InterfazFuncion{posEstudianteYHippie}{\In{id}{nombre}, \In{cs}{campusSeguro}}{posición}
[$id \in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)]
{$res =_{obs}$ posEstudianteYHippie($id$,$cs$)}
[$O(|n_m|)$, donde $|m_n|$ es la longitud mas larga entre todos los nombres.]
[Devuelve la posicion del estudiante o hippie.]
[]

~

\InterfazFuncion{posAgente}{\In{a}{agente}, \In{cs}{campusSeguro}}{posición}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ posAgente($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la posicion del agente pasado como parametro.]
[]

~

\InterfazFuncion{cantSanciones}{\In{a}{agente}, \In{cs}{campusSeguro}}{nat}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ cantSanciones($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la cantidad de sanciones que posee el agente pasado como parametro.]
[]

~

\InterfazFuncion{cantHippiesAtrapados}{\In{a}{agente}, \In{cs}{campusSeguro}}{nat}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ cantHippiesAtrapados($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la cantidad de hippies que atrapo el agente pasado como parametro.]
[]

~

\InterfazFuncion{másVigilante}{\In{cs}{campusSeguro}}{agente}
[true]
{$res =_{obs}$ másVigilante($cs$)}
[$O(1)$]
[Devuelve la placa del agente que ha atrapado mas hippies.]
[]

~

\InterfazFuncion{conMismasSanciones}{\In{a}{agente}, \In{cs}{campusSeguro}}{conj(agentes)}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ conMismasSanciones($a$,$cs$)}
[$O(1)$ en el caso promedio.]
[Devuelve el conjunto de los agentes que tienen el mismo numero de sanciones que el agente pasado como parametro.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{conKSanciones}{\In{k}{nat}, \In{cs}{campusSeguro}}{conj(agentes)}
[true]
{$res =_{obs}$ conKSanciones($k$,$cs$)}
[$O(N_a)$ la primera vez que se la llama y $O(log(N_a))$ en futuras llamadas mientras no ocurran sanciones.]
[Devuelve el conjuto de agenes que tienen k sanciones.]
[$res$ es una referencia no modificable.]

~
\pagebreak

\subsubsection{Representación de campusSeguro}

\begin{Estructura}{campusSeguro}[estr]
	\begin{Tupla}[estr]
		\tupItem{campus}{campus}%
		\tupItem{\\ personalAS}{diccNat(agente,datosAgente)}%
		\tupItem{\\ posicionesAgente}{vector(As)}%
		\tupItem{\\ masVigilante}{As}%
		\tupItem{\\ listaMismasSanc}{lista(kSanc)}%
		\tupItem{\\ arregloMismasSanc}{arreglo(itLista(kSanc))}
		\tupItem{\\ mismasSancModificado}{bool}
		\tupItem{\\ hippies}{dicString(nombre,posicion)}%
		\tupItem{\\ estudiantes}{dicString(nombre, posicion)}%
		\tupItem{\\ posicionesHippies}{vector(nombre)}
		\tupItem{\\ posicionesEstudiantes}{vector(nombre)}
	\end{Tupla}

	~

	\begin{Tupla}[datosAgente]
		\tupItem{posicion}{posicion}%
		\tupItem{\\ cantSanc}{nat}%
		\tupItem{\\ cantAtrapados}{nat}%
		\tupItem{\\ itMismasSanc}{itLista(kSanc)}%
		\tupItem{\\ itConjMismasSanc}{itConj(agente)}%
	\end{Tupla}

	~

	\begin{Tupla}[As]
		\tupItem{agente}{agente}%
		\tupItem{datos}{itDiccNat(agente,datosAgente)}%
	\end{Tupla}

	~

	\begin{Tupla}[kSanc]
		\tupItem{sanc}{nat}
		\tupItem{agentes}{conj(agente)}
	\end{Tupla}

\end{Estructura}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\begin{enumerate}
	%done nro1
	\item Las posiciones de todos los agentes son posiciones validas del campus.
	%done nro2
	\item Las posiciones de los hippies son posiciones validas del campus.
	%done nro3
	\item Las posiciones de los estudiantes son posiciones validas del campus.
	%done nro4
	\item Las posiciones de los agentes son distintas a las posiciones de los hippies.
	%done nro5
	\item Las posiciones de los estudiantes son distintas a las posiciones de los hippies.
	%done nro6
	\item Las posiciones de los agentes son distintas a las posiciones de los estudiantes.
	%done nro7
	\item El agente masVigilante esta definido en personalAs y tiene la mayor cantidad de sanciones.
	%done nro8
	\item Para todo nombre que esta definido en el diccionario de hippies no puede estar definido en el diccionario de estudiantes y viceversa.
	%done nro9
	\item La cantidad de elementos que tiene posicionesAgente, posicionesHippies y posicionesEstudiantes es la cantidad de coordenadas que tiene el campus.
	%done nro10
	\item Los agentes de posicionesAgente son los mismos que los de personalAs y viceversa.
	%done nro11
	\item La posicion de todos los agentes de posicionesAgente se mapea con la posicion que tienen en personalAs y viceversa.

	%DONE habia puntero, ahora hay iterador nro12
	\item Las posiciones en posicionesAgente que no tienen agente tienen un agente tienen un iterador en el que ver si hay siguiente da false.
	
	%done nro13
	\item La dimension del campus es mayor que la cantidad de estudiantes, hippies, agentes y obstaculos.
	%done nro14
	\item La longitud de listaMismasSanc es la cantidad de sanciones diferentes que hay.
	% nro15
	\item Para cada cantidad de sanciones distinta hay un nodo en listaMismasSanc con esa cantidad de sanciones.
	% nro16
	\item listaMismasSanc esta ordenada por cantidad de sanciones.
	% nro17
	\item En cada nodo de listaMismasSanc va a estar el conjunto de todos los agentes que tienen la cantidad de sanciones indicada en el nodo.

	%DONE nro18
	\item Cada agente que esta en personalAS esta en el conjunto de un nodo que tiene su misma cantidad de sanciones de la lista listaMismasSanciones y viceversa.

	%DONE nro19
	\item Cada agente de personalAS tiene un iterador valido, itMismasSanc, que apunta al nodo de la lista listaMismasSanc que tiene la misma cantidad de sanciones que ese agente, y otro iterador valido, itConjMismasSanc, que apunta si mismo en el conjunto agentes del nodo de listaMismasSanc que posee su misma cantidad de sanciones.
	%done nro20
	\item Si mismasSancModificado es falso, arregloMismasSanc tiene misma cantidad de elementos que listaMismasSanc, y cada elemento apunta a un nodo de listaMismasSanc, respetando el orden de listaMismasSanc.
	%done nro21
	\item Los hippies de posicionesHippies son los mismos que los del dicString hippies.
	%done nro22
	\item Las posiciones en posicionesHippies que no tienen un hippie poseen el caracter de espacio " ".
	%done nro23
	\item La posiciones de todos los hippies en posicionesHippies se mapea con la posicion que tienen en el diccString hippies y viceversa
	%done nro24
	\item Los estudiantes de posicionesEstudiantes son los mismos que los del dicString estudiantes.
	%done nro25
	\item Las posiciones en posicionesEstudiantes que no tienen un estudiante poseen el caracter de espacio " ".
	%done nro26
	\item La posiciones de todos los estudiantes en posicionesEstudiantes se mapea con la posicion que tienen en el diccString estudiantes y viceversa
	

\end{enumerate}

\pagebreak

\Rep[estr][e]{
	% nro1
	($\forall a$: nat)(def?($a$, $e$.personalAS) $\Rightarrow_L$ posValida(Obtener($a$,$e$.personalAS).posicion, e.campus) $\land$ $\neg$ocupada?(Obtener($a$,$e$.personalAS).posicion),e.campus)
	\\
	$\land$
	\\ %nro2
	($\forall h$: string)(def?($h$, $e$.hippies) $\Rightarrow_L$ posValida(Obtener($h$,$e$.hippies), e.campus) $\land$ $\neg$ocupada?(Obtener($h$, $e$.hippies)),e.campus)
	\\
	$\land$
	\\%nro3
	($\forall est$: string)(def?($est$, $e$.estudiantes) $\Rightarrow_L$ posValida(Obtener($est$, $e$.estudiantes), e.campus) $\land$ $\neg$ocupada?(Obtener($est$, $e$.estudiantes)), e.campus)
	\\
	$\land$
	\\%nro4
	($\forall a$: nat)($\forall h$: string) def?($a$, $e$.personalAS) $\land$ def?($h$, $e$.hippies) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).posicion $\neq$ Obtener($h$, $e$.hippies)
	\\
	$\land$
	\\%nro5
	($\forall est$: string)($\forall h$: string) def?($est$,$e$.estudiantes) $\land$ def?($h$,$e$.hippies) $\Rightarrow_L$ Obtener($est$,$e$.estudiantes) $\neq$ Obtener($h$, $e$.hippies)
	\\
	$\land$
	\\%nro6
	($\forall a$: nat)($\forall est$: string) def?($a$, $e$.personalAS) $\land$ def?($est$, $e$.estudiantes) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).posicion $\neq$ Obtener($est$, $e$.estudiantes)
	\\
	$\land$
	\\%nro7
	def?(masVigilante.agente, $e$.personalAS) $\land_L$ HaySiguiente(masVigilante.datos) $\land_L$ Obtener(masVigilante.agente, $e$.personalAS) = Siguiente(masVigilante.datos)
	\\
	$\land$
	\\%nro7 (2da parte)
	($\forall a$: nat)(def?($a$, $e$.personalAS) $\land$ HaySiguiente(masVigilante.datos)) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).cantSanc $\leq$ Siguiente(masVigilante.datos).cantSanc
	\\
	$\land$
	\\%nro8
	($\forall h$: string) def?($h$, $e$.hippies) $\Rightarrow$ $\neg$def?($h$, $e$.estudiantes)
	\\
	$\land$
	\\%nro8 (2da parte)
	($\forall est$: string) def?($est$, $e$.estudiantes) $\Rightarrow$ $\neg$def?($est$, $e$.hippies)
	\\
	$\land$
	\\%nro9
	longitud($e$.posicionesAgente) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\%nro9 (2)
	longitud($e$.posicionesHippies) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\%nro9 (3)
	longitud($e$.posicionesEstudiantes) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\%nro10 y nro11  fue modificado, habia punteros, ahora hay iterador
	($\forall a$: nat) def?($a$, $e$.personalAS) $\Leftrightarrow_L$ ($\exists i$: nat) $i <$ longitud($e$.posicionesAgente) $\land_L$ $e$.posicionesAgente[$i$].agente = $a$ $\land$ Siguiente($e$.posicionesAgente[$i$].datos) = Obtener($a$, $e$.personalAS) $\land$ ($i$ $/$ columnas($e$.campus)) = Obtener($a$, $e$.personalAS).posicion.y $\land$ ($i$ $mod$ columnas($e$.campus)) = Obtener($a$, $e$.personalAS).posicion.x
	\\
	$\land$
	\\%nro12  fue modificado, habia punteros, ahora hay iterador
	($\forall i$: nat) $i <$ longitud($e$.posicionesAgente) $\Leftrightarrow_L$ $\neg$HaySiguiente($e$.posicionesAgente[$i$].datos) $\lor$ ($\exists! a$: nat) def?($a$, $e$.personalAS) $\land_L$ Siguiente($e$.posicionesAgente[$i$].datos) = Obtener($a$, $e$.personalAS)
	\\
	$\land$
	\\%nro13
	$\#$claves($e$.personalAS) $+$ $\#$claves($e$.hippies) $+$ $\#$claves($e$.estudiantes) $+$ $\#$Obstaculos($e$.campus) $\leq$ filas($e$.campus)*columnas($e$.campus)
	\\
	$\land$
	\\%nro14
	long($e$.listaMismasSanc) = $\#$SancionesDistintas($e$.personalAS)
	\\
	$\land$
	\\%nro15
	($\forall$ sanc: nat)(sanc $\in$ conjSanciones(claves($e$.personalAS), $e$.personalAS) $\Rightarrow$ ($\exists$ nodo: kSanc)(esta?(nodo, $e$.listaMismasSanc) $\land$ nodo.sanc = sanc))
	\\
	$\land$
	\\%nro16
	ordenada?($e$.listaMismasSanc)
	\\
}\mbox{} %aca termina el scope del break, si no termina aca sigue por la eternidad en la misma pagina (no pasa a la siguiente)
	$\land$
	\\%nro17
	($\forall$ nodo: kSanc)(esta?(nodo, $e$.listaMismasSanc) $\Rightarrow_L$ agentes(nodo) $=$ agentesKSanc($e$.personalAS, claves($e$.personalAS), sanc(kSanc)))
	\\
	$\land$
	\\%nro18 + nro19
	($\forall$ $a$: nat)(def?$a$, $e$.personalAS) $\Rightarrow_L$ (HaySiguiente(Obtener($a$, $e$.personalAS).itMismasSanc) $\land_L$ Siguiente(Obtener($a$, $e$.personalAS).itMismasSanc).sanc = Obtener($a$, $e$.personalAS).cantSanc) $\land$ (HaySiguiente(Obtener($a$, $e$.personalAS).itConjMismasSanc) $\land_L$ Siguiente(Obtener($a$, $e$.personalAS).itConjMismasSanc) = $a$) $\land$ ($\exists!$ nodo: kSanc) (esta?(nodo, $e$.listaMismasSanc) $\land_L$ Siguiente(Obtener($a$, $e$.personalAS).itMismasSanc = nodo $\land$ Pertenece?(nodo,	Siguiente(Obtener($a$, $e$.personalAS).itConjMismasSanc)) = Pertenece?(nodo, a)
	\\
	$\land$
	\\%nro20
	$\neg$$e$.mismasSancModificado $\Rightarrow$ (long($e$.listaMismasSanc) = long(vectorMismasSanc) $\land_L$ mismosNodos($e$.listaMismasSanc, $e$.vectorMismasSanc))
	\\
	$\land$
	\\%nro21 + nro22
	($\forall$ i: nat)(i < longitud($e$.posicionesHippies) $\Leftrightarrow_L$ posicionesHippies[i] = " " $\lor$ ($\exists!$ h: string)(def?(h, $e$.hippies) $\land_L$ h = posicionesHippies[i]
	\\
	$\land$
	\\%nro23
	($\forall$ h: string)(def?(h, $e$.hippies) $\Leftrightarrow_L$ ($\exists!$ i: nat)(i < longitud($e$.posicionesHippies) $\land_L$ $e$.posicionesHippies[i] = obtener(h, $e$.hippies) $\land$ (i / columnas($e$.campus) = obtener(h, $e$.hippies).x) $\land$ (i mod columnas($e$.campus) = obtener(h, $e$.hippies).y)))
	\\
	$\land$
	\\%nro24 + nro25
	($\forall$ i: nat)(i < longitud($e$.posicionesEstudiantes) $\Leftrightarrow_L$ posicionesEstudiantes[i] = " " $\lor$ ($\exists!$ e: string)(def?(e, $e$.estudiantes) $\land_L$ e = posicionesEstudiantes[i]
	\\
	$\land$
	\\%nro26
	($\forall$ est: string)(def?(est, $e$.estudiantes) $\Leftrightarrow_L$ ($\exists!$ i: nat)(i < longitud($e$.posicionesEstudiantes) $\land_L$ $e$.posicionesEstudiantes[i] = Obtener(est, $e$.estudiantes) $\land$ (i / columnas($e$.campus) = Obtener(est, $e$.estudiantes).x) $\land$ (i mod columnas($e$.campus) = Obtener(est, $e$.estudiantes).y)))
	\\
	\\
\tadOperacion{$\#$Obstaculos}{campus}{nat}{}
\tadOperacion{$\#$ObstaculosAux}{nat,nat,campus}{nat}{}
\tadOperacion{$\#$SancionesDistintas}{diccNat(agente, datosAgente)}{nat}{}
\tadOperacion{conjSanciones}{conj(nat), diccNat(agente,datosAgente)}{conj(nat)}{}
\tadOperacion{cantAgentes}{secu(kSanc)}{nat}{}
\tadOperacion{ordenada?}{secu(kSanc)}{bool}{}
\tadOperacion{agentesKSanc}{diccNat(agente, datosAgente), conj(agente), nat}{conj(agente)}{}
\tadOperacion{mismosNodos}{secu(kSanc)/lista, secu(itLista(kSanc))/vec}{bool}{long(lista) = long(vec)}

~

\tadAxioma{$\#$Obstaculos(c)}{
	$\#$ObstaculosAux(filas($c$)$-1$, columnas($c$)$-1$, $c$)
}
\tadAxioma{$\#$ObstaculosAux(f,col,c)}{
	\IF ($f=0 \land col=0$) THEN	$\beta$(ocupada?(<$f$,$col$>, $c$)
	ELSE{
		\IF ($f \neq 0 \land col = 0$) THEN $\#$ObstaculosAux($f-1$, columnas($c$)$-1$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
		ELSE{
			\IF ($f = 0 \land col \neq 0$) THEN $\#$ObstaculosAux(filas($c$),$col-1$,$c$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
			ELSE{
				$\#$ObstaculosAux($f-1$, $col-1$, $c$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
			}
			FI
		}
		FI
	}
	FI
}
\tadAxioma{$\#$SancionesDistintas(d)}{
	$\#$conjSanciones(Claves($d$),$d$)
}
\tadAxioma{conjSanciones(c,d)}{
	\IF $\neg\emptyset$($c$) THEN $\emptyset$
	ELSE{
		Ag(Obtener(DameUno($c$),$d$).cantSanc, conjSanciones(SinUno($c$,$d$)))
	}
	FI
}
\tadAxioma{cantAgentes(s)}{
	\IF $s = <>$ THEN 0
	ELSE {
		Long(prim($s$).vectorAgente) + cantAgentes(fin($s$))
	}
	FI
}
\tadAxioma{ordenada?(lista)}{
	\IF vacia?(lista) THEN true
	ELSE{
		\IF vacia?(fin(lista)) THEN true
		ELSE{
			\IF sanc(prim(lista)) < sanc(prim(fin(lista))) THEN ordenada?(fin(lista))
			ELSE false
			FI
		}
		FI
	}
	FI
}
\tadAxioma{agentesKSanc(dicc, claves, k)}{
	\IF $\emptyset$?(claves) THEN $\emptyset$
	ELSE{
		\IF cantSanc(obtener(prim(claves), dicc)) = k THEN
			Ag(prim(claves), agentesKSanc(dicc, fin(claves), k))
		ELSE
			agentesKSanc(dicc, fin(claves), k)
		FI
	}
	FI
}
\tadAxioma{mismosNodos(lista, vec)}{
	\IF vacia?(lista) THEN true
	ELSE{
		\IF prim(lista) = Siguiente(prim(vec)) THEN
			mismosNodos(fin(lista), fin(vec))
		ELSE
			false
		FI
	}
	FI
}

\subsubsection{Función de Abstracción}
\Abs[estr]{campusSeguro}[e]{cs}{
$e$.campus $=$ campus($cs$)
\\
$\land$
\\
$e$.estudiantes $=$ estudiantes($cs$)
\\
$\land$
\\
$e$.hippies $=$ hippies($cs$)
\\
$\land$
\\
$e$.personalAS $=$ agentes($cs$)
\\
$\land$
\\
($\forall a$: nat) (def?($a$, $e$.personalAS) $\Rightarrow_L$ posAgente($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).posicion $\land$ cantSanciones($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).cantSanc $\land$cantHippiesAtrapados($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).cantAtrapados)
\\
$\land$
\\
($\forall id$: string) (def?($id$, $e$.estudiantes) $\land_L$ Obtener($id$, $e$.estudiantes) = posEstudianteYHippie(cs)) $\lor$ (def?($id$, $e$.hippies) $\land_L$ Obtener($id$, $e$.hippies) = posEstudianteYHippie(cs))
}

\pagebreak

\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{icomenzarRastrillaje}{\In{c}{campus}, \In{d}{diccNat(agente, datosAgente)}}{estr}'

	res.campus $\leftarrow$ c $\emph{(1)}$ '\ote{1}'
	res.listaMismasSanc $\leftarrow$ generarListaMismasSanc(d) '\ote{$N_a$}'
	res.personalAS $\leftarrow$ d $\emph{(2)}$ '\ote{1}'
	res.posicionesAgente $\leftarrow$ vectorizarPos(d,filas(c),columnas(c)) '\ote{(f$*$c) + $N_a$}'
	res.masVigilante $\leftarrow$ menorPlaca(d) '\ote{$N_a$}'
	res.mismasSancModificado $\leftarrow$ true '\ote{1}'
	res.hippies $\leftarrow$ Vacio() '\ote{1}'
	res.estudiantes $\leftarrow$ Vacio() '\ote{1}'
	res.posicionesHippies $\leftarrow$ Vacio() '\ote{1}'
	res.posicionesEstudiantes $\leftarrow$ Vacio '\ote{1}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	while i $<$ filas(c)*columnas(c) do '\ote{1}'
		AgregarAtras(res.posicionesHippies, " ") '\ote{1}'
		AgregarAtras(res.posicionesEstudiantes, " ") '\ote{1}'
		i $\leftarrow$ i$+1$
	end while '\ote{(f*c)}'

'\ofi{O(N_a) + O(N_a) + O((f*c) + N_a) + O((f*c)) = O((f*c) + N_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~

\InterfazFuncion{vectorizarPos}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{vectorizarPos}{\In{d}{diccNat(agente, datosAgente)}, \In{f}{nat}, \In{c}{nat}}{vector(AS)}'
	res $\leftarrow$ Vacia() '\ote{1}'
	nat: i $\leftarrow$ 0 '\ote{1}'
	itDiccNat(agente, datosAgente): it $\leftarrow$ CrearIt(d) '\ote{1}'

	while i $<$ f$*$c do '\ote{1}'
		AgregarAtras(res, tupla(0,NULL)) '\ote{f$*$c}'
		i $\leftarrow$ i$+1$ '\ote{1}'
	end while '\ote{(f$*$c)}'

	while HaySiguiente(it) do '\ote{1}'
		res[Siguiente(it).significado.posicion.y $*$ c $+$
				Siguiente(it).significado.posicion.x] $\leftarrow$
			$\leftarrow$ tupla(Siguiente(it).clave, puntero(Siguiente(it).significado)) '\ote{1}'
	end while '\ote{$N_a$}'

'\ofi{O((f*c) + N_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~

\InterfazFuncion{menorPlaca}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{menorPlaca}{\In{d}{diccNat(agente, datosAgente)}}{AS}'
	itDiccNat(agente, datosAgente): it $\leftarrow$ CrearIt(d) '\ote{1}'
	nat: placaMenor $\leftarrow$ Siguiente(it).clave '\ote{1}'
	puntero(datosAgente): punt $\leftarrow$ puntero(Siguiente(it).datosAgente '\ote{1}'
	while HaySiguiente(d) do '\ote{1}'
		if Siguiente(it).clave < placaMenor	then '\ote{1}'
			placaMenor $\leftarrow$ Siguiente(it).clave '\ote{1}'
			punt $\leftarrow$ puntero(Siguiente(it).datosAgente) '\ote{1}'
		end if '\ote{1}'
		Avanzar(it) '\ote{1}'
	end while '\ote{$N_a$}'

	res.agente $\leftarrow$ placaMenor '\ote{1}'
	res.datos $\leftarrow$ punt '\ote{1}'

'\ofi{O(N_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{generarListaMismasSanc}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{generarListaMismasSanc}{\Inout{d}{diccNat(agente, datosAgente)}}{lista(kSanc)}'
	itDiccNat(agente, datosAgente): itDic $\leftarrow$ CrearIt(d) '\ote{1}'
	res $\leftarrow$ Vacia() '\ote{1}'
	AgregarAdelante(res, tupla(0,Vacio())) '\ote{1 (esta vacío el vector)}'
	itLista(kSanc): itL $\leftarrow$ CrearIt(res) '\ote{1}'

	while HaySiguiente(itDic) do '\ote{1}'
		itConj(agente): itC $\leftarrow$ AgregarRapido(res.agentes, Siguiente(itDic).clave) '\ote{1}'
		Siguiente(itDic).significado.itConjMismasSanc $\leftarrow$ itC '\ote{1}'
		Siguiente(itDic).significado.itMismasSanc $\leftarrow$ itL '\ote{1}'
		Avanzar(itDic) '\ote{1}'
	end while '\ote{$N_a$}'

'\ofi{O(N_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iIngresarEstudiante}{\In{e}{nombre}, \In{pos}{posicion}, \Inout{cs}{estr} } {}'
	if todasOcupadas?(vecinos(pos, $cs$.campus), $cs$ AND
	AND AlMenosUnAgente(vecinos(pos, $cs$.campus) then '\ote{1}'
		conj(As): conjAgParaSanc $\leftarrow$ AgParaPremSanc(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
		SancionarAgentes(conjAgParaSanc, $cs$) '\ote{1}'
	end if '\ote{1}'

	if CantHippiesVecinos(vecinos(pos, $cs$.campus), $cs$)$< 2$  then '\ote{$|n_m|$}'
		Definir($cs$.estudiantes, e, pos) '\ote{$|n_m|$}'
		$cs$.posicionesEstudiantes[pos.y * Columnas($cs$.campus) + pos.x] $\leftarrow$ e '\ote{1}'
	else
		Definir($cs$.hippies, e, pos) '\ote{$|n_m|$}'
		$cs$.posicionesHippies[pos.y * Columnas($cs$.campus) + pos.x] $\leftarrow$ e '\ote{1}'
	end if '\ote{$|n_m| + |n_m|$}'

	conj(nombre, posicion): conjHippiesRodEst $\leftarrow$
		$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'

	if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'

		while HaySiguiente(itHEst) do '\ote{1}'
			Definir($cs$.estudiantes, Siguiente(itHEst).nombre,
				Siguiente(itHEst).posicion) '\ote{$|n_m|$}'
			Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHEst).posicion.x] $\leftarrow$
			$\leftarrow$ $cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] '\ote{1}'

			$cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] $\leftarrow$ " " '\ote{1}'

			Avanzar(itHEst) '\ote{1}'
		end while '\ote{$2|n_m|$}'
	end if '\ote{$4 * 2|n_m|$}'

	conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
		$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'
		while HaySiguiente(itHAs) do '\ote{1}'
			Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itHAs).y*Columnas($cs$.campus) +
		+ Siguiente(itHAs).x] $\leftarrow$ " " '\ote{1}'
			Avanzar(itHAs) '\ote{1}'
		end while '\ote{$4|n_m|$}'
	end if '\ote{$4|n_m|$}'

	conj(nombre, posicion): conjEstRodHip $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosHippies(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjEstRodHip) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itEstH $\leftarrow$ CrearIt(conjEstRodHip) '\ote{1}'
		while HaySiguiente(itEstH) do '\ote{1}'
			Eliminar($cs$.estudiantes, Siguiente(itEstH).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ " " '\ote{1}'

			Definir($cs$.hippies, Siguiente(itEstH).nombre,
				Siguiente(itEstH).posicion) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ Siguiente(itEstH).nombre '\ote{1}'

			Avanzar(itHAs) '\ote{1}'
		end while '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'

	conj(posicion): conjEstRodAs $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjEstRodAs) $> 0$ then '\ote{1}'
		itConj(posicion): itEstAs $\leftarrow$ CrearIt(conjEstRodAs) '\ote{1}'

		while HaySiguiente(itEstAs) do '\ote{1}'
			if todasOcupadas?(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$ AND
			AND AlMenosUnAgente(vecinos(Siguiente(itEstAs), $cs$.campus) then '\ote{1}'
				conj(As): conjAgParaSanc $\leftarrow$
					$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$) '\ote{1}'
				SancionarAgentes(conjAgParaSanc, $cs$) '\ote{1}'
			end if '\ote{1}'
		end while '\ote{4}'

	end if '\ote{4}'

'\ofi{O(2|n_m|) + O(4*2|n_m|) + O(4|n_m|) + O(4*2|n_m|) = O(22|n_m|) = O(|n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{EstudiantesRodeadosAs}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{EstudiantesRodeadosAs}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio()

	while HaySiguiente(itC) do '\ote{1}'
		if TodasOcupadas?(vecinos(Siguiente(itC), $cs$), $cs$) AND
		AND AlMenosUnAgente(vecinos(Siguiente(itC), $cs$), $cs$) then '\ote{1}'
		AgregarRapido(res, Siguiente(itC)) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{4}'

'\ofi{O(4) = O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{EstudiantesRodeadosHippies}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{EstudiantesRodeadosHippies}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(nombre, posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesEstudiantes[Siguiente(itC).y*Colummnas($cs$.campus) +
		+ Siguiente(itC).x] $\neq$ " " AND
		AND TodasOcupadas?(vecinos(Siguiente(itC), $cs$.campus), $cs$) AND
		AND HippiesAtrapando(vecinos(Siguiente(itC), $cs$.campus), $cs$) then '\ote{1}'
		AgregarRapido(res,
			tupla($cs$.posicionesEstudiantes[Siguiente(itC).y*Columnas($cs$.campus) +
			+ Siguiente(itC).x], Siguiente(itC)) '\ote{1}'

	end while '\ote{4}'

'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{HippiesAtrapando}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{HippiesAtrapando}{\In{c}{conj(posicion)}, \In{cs}{estr}}{bool}'
	nat: i $\leftarrow$ 0 '\ote{1}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).x] $\neq$ " " then '\ote{1}'
			i $\leftarrow$ i$+1$ '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{4}'

	res $\leftarrow$ i $\geq 2$ '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{SancionarAgentes}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{SancionarAgentes}{\In{c}{conj(As)}, \Inout{cs}{estr}}{}'
	itConj(As): itC $\leftarrow$ CrearIt(c) '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		*Siguiente(itC).datos.cantSanccantSanc $\leftarrow$
			$\leftarrow$ *Siguiente(itC).datos.cantSanc$+1$ '\ote{1}'
		itLista(kSanc): itLis $\leftarrow$ *Siguiente(itC).datos.itMismasSanc'\ote{1}'

		if HaySiguiente(*Siguiente(itC).datos.itMismasSanc) then '\ote{1}'
			Avanzar(*Siguiente(itC).datos.itMismasSanc)
			if Siguiente(*Siguiente(itC).datos.itMismasSanc).sanc =
			*Siguiente(itC).datos.cantSanc then '\ote{1}'
			else
				AgregarComoAnterior(*Siguiente(itC).datos.itMismasSanc,
					tupla(*Siguiente(itC).datos.cantSanc, Vacio())) '\ote{1}'
				Retroceder(*Siguiente(itC).datos.itMismasSanc) '\ote{1}'
			end if

		else
			AgregarComoSiguiente(*Siguiente(itC).datos.itMismasSanc,
				tupla(*Siguiente(itC).datos.cantSanc, Vacio()) '\ote{1}'
			Avanzar(*Siguiente(itC).datos.itMismasSanc) '\ote{1}'
		end if

		EliminarSiguiente(*Siguiente(itC).datos.itConjMismasSanc) '\ote{1}'
		*Siguiente(itC).datos.itConjMismasSanc $\leftarrow$
			$\leftarrow$ AgregarAdelante(*Siguiente(itC).datos.itMismasSanc.agentes,
				*Siguiente(itC).agente) '\ote{1}'
	end while '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{HippiesRodeadosAs}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{HippiesRodeadosAs}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(nombre, posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).y] $\neq$ " "  AND
		todasOcupadas?(vecinos(Siguiente(itDiccS), $cs$.campus)) AND
		AlMenosUnAgente(vecinos(Siguiente(itDiccS), $cs$.campus)) then '\ote{1}'
			AgregarRapido(res,
			tupla($cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
			+ Siguiente(itC).y],
				Siguiente(itC)) '\ote{1}'

			conj(As): conjAgPremiar $\leftarrow$
			$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itDiccS), $cs$), $cs$) '\ote{1}'
			PremiarAgentes(conjAgPremiar, $cs$) '\ote{1}'

		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{4}'

'\ofi{O(4) = O(1) \text{. La cantidad maxima del conjunto de posicion es 4.}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{AgParaPremSanc}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{AgParaPremSanc}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(As)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) + x].datos $\neq$
			$\neq$ NULL then '\ote{1}'
			AgregarRapido(res,
				$cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) + x]) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) \ote{1}'
	end while '\ote{4}'

'\ofi{O(1) + O(1) + O(4) = O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{PremiarAgentes}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{PremiarAgentes}{\In{c}{conj(As)}, \Inout{cs}{estr}}{}'
	itConj(As): itC $\leftarrow$ CrearIt(As) '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		*Siguiente(itC).datos.cantAtrapados $\leftarrow$
			$\leftarrow$ *Siguiente(itC).datos.cantAtrapados$+1$ '\ote{1}'
	end while '\ote{4}'

'\ofi{O(4) = O(1) \text{. La cantidad maxima de agentes va a ser 4.}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{CantHippiesVecinos}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{CantHippiesVecinos}{\In{c}{conj(posicion)}, \In{cs}{estr}}{nat}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ $0$

	while HaySiguiente(itC) do '\ote{1}'
		itDiccString(nombre, posicion): itDic $\leftarrow$ CrearIt($cs$.hippies) '\ote{1}'

		while HaySiguiente(itDic) do '\ote{1}'
			if Siguiente(itDic) = Siguiente(itC) '\ote{1}'
				res $\leftarrow$ res$+1$ '\ote{1}'
			end if '\ote{1}'
		end while '\ote{$|n_m|$}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{$|n_m|$}'

'\ofi{O(|n_m|) \text{. Como vecinos como maximo tiene longitud 4, la complejidad sería } O(4*|n_m|) = O(|n_m|)}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{HippiesRodeadosEstudiantes}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{HippiesRodeadosEstudiantes}{\In{c}{conj(posicion}, \In{cs}{estr}}{conj(nombre, posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).x] $\neq$ " "  AND
		todasOcupadas?(vecinos(Siguiente(itC), $cs$.campus)) AND
		TodosEstudiantes(vecinos(Siguiente(itC), $cs$.campus)) then '\ote{1}'
			AgregarRapido(res,
				tupla(, $cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).x]
				Siguiente(itC)) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{4}'

'\ofi{O(4) = O(1) \text{. Como el conjunto c tiene como maximo longitud 4, la complejidad sería } O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{todasOcupadas?}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{todasOcupadas?}{\In{c}{conj(posicion)}, \In{cs}{estr}}{bool}'
	res $\leftarrow$ false '\ote{1}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesHippies[Siguiente(itC)*Columnas($cs$.campus) +
		+ Siguiente(itC).y] $\neq$ " " then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'

		if $cs$.posicionesEstudiantes[Siguiente(itC)*Columnas($cs$.campus) +
		+ Siguiente(itC).y] $\neq$ " " then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{1}'

	itC $\leftarrow$ CrearIt(c) '\ote{1}'
	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) + x].datos $\neq$
		$\neq$ NULL then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if '\ote{1}'
	end while '\ote{4}'

	itC $\leftarrow$ CrearIt(c) '\ote{1}'
	while HaySiguiente(itC) do '\ote{1}'
		if Ocupada?($cs$.campus, Siguiente(itC)) '\ote{1}'
			res $\leftarrow$ true
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{4}'

'\ofi{O(1) \text{. Como el conjunto c tiene como maximo longitud 4, la complejidad sería } O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{AlMenosUnAgente}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{AlMenosUnAgente}{\In{c}{conj(posicion)}, \In{cs}{estr} }{bool}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ false '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) + x].datos $\neq$
		$\neq$ NULL then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if '\ote{1}'
	end while '\ote{4}'

'\ofi{O(4) = O(1) \text{. Como el conjunto c tiene maximo 4 posiciones, solo hace el ciclo 4 veces maximo.}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{TodosEstudiantes}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{TodosEstudiantes}{\In{c}{conj(posicion)}, \In{cs}{estr} }{bool}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c)
	res $\leftarrow$ true

	while HaySiguiente(itC) AND res = true do '\ote{1}'
		if $cs$.posicionesEstudiantes[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).x] $=$ " " then '\ote{1}'
			res $\leftarrow$ false
		end if '\ote{1}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{1}'

'\ofi{O(1) \text{. Como el conjunto c tiene como maximo longitud 4, la complejidad sería } O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iIngresarHippie}{\In{h}{nombre}, \In{pos}{posicion}, \Inout{cs}{estr} }{}'
	if todasOcupadas?(vecinos(pos, $cs$.campus), $cs$) AND
	AND AlMenosUnAgente(vecinos(pos, $cs$.campus) then '\ote{1}'
		conj(As): conjAgParaPrem $\leftarrow$ AgParaPremSanc(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
		PremiarAgentes(conjAgParaSanc, $cs$) '\ote{1}'
	else if todasOcuapadas?(vecinos(pos, $cs$.campus), $cs$) AND
	AND TodosEstudiantes(vecinos(pos, $cs$.campus), $cs$) then '\ote{1}'
		Definir($cs$.estudiantes, h, pos) '\ote{$|n_m|$}'
		$cs$.posicionesEstudiantes[pos.y*Columnas($cs$.campus) + pos.x] $\leftarrow$ h
	else
		Definir($cs$.hippies, h, pos) '\ote{$|n_m|$}'
		$cs$.posicionesHippies[pos.y*Columnas($cs$.campus) + pos.x] $\leftarrow$ h
	end if '\ote{$|n_m|$}'

	conj(nombre, posicion): conjHippiesRodEst $\leftarrow$
		$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'

	if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'

		while HaySiguiente(itHEst) do '\ote{1}'
			Definir($cs$.estudiantes, Siguiente(itHEst).nombre,
				Siguiente(itHEst).posicion) '\ote{$|n_m|$}'
			Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHEst).posicion.x] $\leftarrow$
			$\leftarrow$ $cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] '\ote{1}'

			$cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] $\leftarrow$ " " '\ote{1}'

			Avanzar(itHEst) '\ote{1}'
		end while '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'

	conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
		$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'
		while HaySiguiente(itHAs) do '\ote{1}'
			Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itHAs).y*Columnas($cs$.campus) +
		+ Siguiente(itHAs).x] $\leftarrow$ " " '\ote{1}'
			Avanzar(itHAs) '\ote{1}'
		end while '\ote{$4|n_m|$}'
	end if '\ote{$4|n_m|$}'

	conj(nombre, posicion): conjEstRodHip $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosHippies(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjEstRodHip) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itEstH $\leftarrow$ CrearIt(conjEstRodHip) '\ote{1}'
		while HaySiguiente(itEstH) do '\ote{1}'
			Eliminar($cs$.estudiantes, Siguiente(itEstH).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ " " '\ote{1}'

			Definir($cs$.hippies, Siguiente(itEstH).nombre,
				Siguiente(itEstH).posicion) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ Siguiente(itEstH).nombre '\ote{1}'

			Avanzar(itHAs) '\ote{1}'
		end while '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'

	conj(posicion): conjEstRodAs $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjEstRodAs) $> 0$ then '\ote{1}'
		itConj(posicion): itEstAs $\leftarrow$ CrearIt(conjEstRodAs) '\ote{1}'

		while HaySiguiente(itEstAs) do '\ote{1}'
			if todasOcupadas?(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$ AND
			AND AlMenosUnAgente(vecinos(Siguiente(itEstAs), $cs$.campus) then '\ote{1}'
				conj(As): conjAgParaSanc $\leftarrow$
					$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$) '\ote{1}'
				SancionarAgentes(conjAgParaSanc, $cs$) '\ote{1}'
			end if '\ote{1}'
		end while '\ote{4}'

	end if '\ote{4}'

'\ofi{O(|n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iMoverEstudiante}{\In{e}{nombre}, \In{d}{dirección}, \Inout{cs}{estr} }{}'

	Posicion: actualPos $\leftarrow$ Obtener(cs.estudiantes,e) '\ote{$|n_m|$}'
	Posicion: pos $\leftarrow$ actualPos '\ote{1}'
	if(d=Izquierda) then '\ote{1}'
		pos.x $\leftarrow$ pos.x - 1 '\ote{1}'
	else if (d=derecha) then '\ote{1}'
		pos.x $\leftarrow$ pos.x + 1 '\ote{1}'
	else if (d=Arriba) then '\ote{1}'
		pos.y $\leftarrow$ pos.y + 1 '\ote{1}'
 	else if (d=Abajo) then '\ote{1}'
 		pos.y $\leftarrow$ pos.y - 1 '\ote{1}'
 	end if

 	if(not (pos.y = 1 OR pos.y = cd.campus.filas)) then '\ote{1}'
		if CantHippiesVecinos(vecinos(pos, $cs$.campus), $cs$)$< 2$  then '\ote{$|n_m|$}'
			Definir($cs$.estudiantes, e, pos) '\ote{$|n_m|$}'
			$cs$.posicionesEstudiantes[actualPos.y * Columnas($cs$.campus)
				+ actualPos.x] $\leftarrow$ "" '\ote{1}'
			$cs$.posicionesEstudiantes[pos.y * Columnas($cs$.campus) + pos.x] $\leftarrow$ e '\ote{1}'
		else
			Definir($cs$.hippies, e, pos) '\ote{$|n_m|$}'
			$cs$.posicionesHippies[pos.y * Columnas($cs$.campus) + pos.x] $\leftarrow$ e '\ote{1}'
			$cs$.posicionesEstudiantes[actualPos.y * Columnas($cs$.campus)
				+ actualPos.x] $\leftarrow$ "" '\ote{1}'
			Borrar(cs.estudiantes,e) '\ote{$|n_m|$}'
		end if '\ote{$|n_m| + |n_m|$}'

		conj(nombre, posicion): conjHippiesRodEst $\leftarrow$
			$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'

		if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
			itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'

			while HaySiguiente(itHEst) do '\ote{1}'
				Definir($cs$.estudiantes, Siguiente(itHEst).nombre,
					Siguiente(itHEst).posicion) '\ote{$|n_m|$}'
				Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_m|$}'

				$cs$.posicionesEstudiantes[Siguiente(itHEst).posicion.y*Columnas($cs$.campus)
				+ Siguiente(itHEst).posicion.x]
				$\leftarrow$ $cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus)
				+ Siguiente(itHest).posicion.x] '\ote{1}'

				$cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus)
				+ Siguiente(itHest).posicion.x] $\leftarrow$ "" '\ote{1}'

				Avanzar(itHEst) '\ote{1}'
			end while '\ote{$2|n_m|$}'
		end if '\ote{$4 * 2|n_m|$}'

		conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
			$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
		if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
			itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'
			while HaySiguiente(itHAs) do '\ote{1}'
				Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_m|$}'

				$cs$.posicionesHippies[Siguiente(itHAs).y*Columnas($cs$.campus) +
			+ Siguiente(itHAs).x] $\leftarrow$ "" '\ote{1}'
				Avanzar(itHAs) '\ote{1}'
			end while '\ote{$4|n_m|$}'
		end if '\ote{$4|n_m|$}'

		conj(nombre, posicion): conjEstRodHip $\leftarrow$
			$\leftarrow$ EstudiantesRodeadosHippies(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
		if Cardinal(conjEstRodHip) $>$ 0 then '\ote{1}'
			itConj(nombre, posicion): itEstH $\leftarrow$ CrearIt(conjEstRodHip) '\ote{1}'
			while HaySiguiente(itEstH) do '\ote{1}'
				Eliminar($cs$.estudiantes, Siguiente(itEstH).nombre) '\ote{$|n_m|$}'

				$cs$.posicionesEstudiantes[Siguiente(itEstH).y*Columnas($cs$.campus) +
			+ Siguiente(itEstH).x] $\leftarrow$ "" '\ote{1}'

				Definir($cs$.hippies, Siguiente(itEstH).nombre,
					Siguiente(itEstH).posicion) '\ote{$|n_m|$}'

				$cs$.posicionesHippies[Siguiente(itEstH).y*Columnas($cs$.campus) +
			+ Siguiente(itEstH).x] $\leftarrow$ Siguiente(itEstH).nombre '\ote{1}'

				Avanzar(itHAs) '\ote{1}'
			end while '\ote{$4*2|n_m|$}'
		end if '\ote{$4*2|n_m|$}'

		conj(posicion): conjEstRodAs $\leftarrow$
			$\leftarrow$ EstudiantesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
		if Cardinal(conjEstRodAs) $> 0$ then '\ote{1}'
			itConj(posicion): itEstAs $\leftarrow$ CrearIt(conjEstRodAs) '\ote{1}'

			while HaySiguiente(itEstAs) do '\ote{1}'
				if todasOcupadas?(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$ AND
				AND AlMenosUnAgente(vecinos(Siguiente(itEstAs), $cs$.campus) then '\ote{1}'
					conj(As): conjAgParaSanc $\leftarrow$
						AgParaPremSanc(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$) '\ote{1}'
					SancionarAgentes(conjAgParaSanc, $cs$) '\ote{1}'
				end if '\ote{1}'
			end while '\ote{4}'

		end if '\ote{4}'
	else
		Borrar(cs.estudiantes,e) '\ote{$|n_m|$}'
		$cs$.posicionesEstudiantes[actualPos.y * Columnas($cs$.campus) + actualPos.x]
			$\leftarrow$ "" '\ote{1}'
	end if

'\ofi{O(|n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iMoverHippie}{\In{h}{nombre}, \Inout{cs}{estr} }{}'

	posicion : actualPos $\leftarrow$ obtener(h, cs.hippies) '\ote{$|n_m|$}'
	posicion : pos $\leftarrow$ porxPos(actualPos, cs.estudiantes, cs) '\ote{$N_e$}'
	if actualPos $\neq_{obs}$ pos then '\ote{1}'
		definir(cs.hippies, h, pos) '\ote{$|n_m|$}'
		cs.posicionesHippies[actualPos.y * columnas(cs.campus)
								+ actualPos.x] $\leftarrow$ "" '\ote{1}'
		cs.posicionesHippies[pos.y * columnas(cs.campus) + pos.x] $\leftarrow$ h '\ote{1}'

	conj(nombre, posicion): conjHippiesRodEst $\leftarrow$
		$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'

	if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'

		while HaySiguiente(itHEst) do '\ote{1}'
			Definir($cs$.estudiantes, Siguiente(itHEst).nombre,
				Siguiente(itHEst).posicion) '\ote{$|n_m|$}'
			Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHEst).posicion.x] $\leftarrow$
			$\leftarrow$ $cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] '\ote{1}'

			$cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] $\leftarrow$ " " '\ote{1}'

			Avanzar(itHEst) '\ote{1}'
		end while '\ote{$2|n_m|$}'
	end if '\ote{$4 * 2|n_m|$}'

	conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
		$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'
		while HaySiguiente(itHAs) do '\ote{1}'
			Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itHAs).y*Columnas($cs$.campus) +
		+ Siguiente(itHAs).x] $\leftarrow$ " " '\ote{1}'
			Avanzar(itHAs) '\ote{1}'
		end while '\ote{$4|n_m|$}'
	end if '\ote{$4|n_m|$}'

	conj(nombre, posicion): conjEstRodHip $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosHippies(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjEstRodHip) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itEstH $\leftarrow$ CrearIt(conjEstRodHip) '\ote{1}'
		while HaySiguiente(itEstH) do '\ote{1}'
			Eliminar($cs$.estudiantes, Siguiente(itEstH).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ " " '\ote{1}'

			Definir($cs$.hippies, Siguiente(itEstH).nombre,
				Siguiente(itEstH).posicion) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ Siguiente(itEstH).nombre '\ote{1}'

			Avanzar(itHAs) '\ote{1}'
		end while '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'

	conj(posicion): conjEstRodAs $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjEstRodAs) $> 0$ then '\ote{1}'
		itConj(posicion): itEstAs $\leftarrow$ CrearIt(conjEstRodAs) '\ote{1}'

		while HaySiguiente(itEstAs) do '\ote{1}'
			if todasOcupadas?(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$ AND
			AND AlMenosUnAgente(vecinos(Siguiente(itEstAs), $cs$.campus) then '\ote{1}'
				conj(As): conjAgParaSanc $\leftarrow$
					$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$) '\ote{1}'
				SancionarAgentes(conjAgParaSanc, $cs$) '\ote{1}'
			end if '\ote{1}'
		end while '\ote{4}'

	end if '\ote{4}'
	end if

'\ofi{O(N_e + |n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{ProxPos}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{ProxPos}{\In{pos}{posicion}, \In{d}{dicString(nombre,posicion)}, \In{cs}{estr}}{posicion}'

	itDicString(nombre,posicion): itDic $\leftarrow$ CrearIt(d) '\ote{1}'
	int: distCorta $\leftarrow$ DistanciaMasCorta(pos, d) '\ote{$\#$Claves(d)}'

	conj(posicion): conjDondeIr $\leftarrow$ DondeIr(pos, distCorta, d) '\ote{$\#$Claves(d)}'
	conj(posicion): conjLugaresPosibles $\leftarrow$
		$\leftarrow$ LugaresPosibles(pos,conjDondeIr, cs) '\ote{Cardinal(c)}'

	if Cardinal(conjLugaresPosibles)$=0$ then '\ote{1}'
		res $\leftarrow$ pos '\ote{1}'
	else
		itConj(posicion): itC $\leftarrow$ CrearIt(conjLugaresPosibles) '\ote{1}'
		res $\leftarrow$ Siguiente(itC) '\ote{1}'
	end if '\ote{1}'

'\ofi{O(\#Claves(d)) + Cardinal(c) = O(\#Claves(d)) \text{. El Cardinal(c) depende de las claves del diccionario.}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{LugaresPosibles}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{LugaresPosibles}{\In{pos}{posicion}, \In{c}{conj(posicion)}, \In{cs}{estr}}{conj(posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if Siguiente(itC).x $>$ pos.x AND Siguiente(itC).y $>$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x+1, pos.y)) '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y +1)) '\ote{1}'
		else if Siguiente(itC).x $=$ pos.x AND Siguiente(itC).y $>$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y +1)) '\ote{1}'
		else if Siguiente(itC).x $<$ pos.x AND Siguiente(itC).y $>$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x-1, pos.y)) '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y +1)) '\ote{1}'
		else if Siguiente(itC).x $<$ pos.x AND Siguiente(itC).y $=$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x-1, pos.y)) '\ote{1}'
		else if Siguiente(itC).x $<$ pos.x AND Siguiente(itC).y $<$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x-1, pos.y)) '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y -1)) '\ote{1}'
		else if Siguiente(itC).x $=$ pos.x AND Siguiente(itC).y $<$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y -1)) '\ote{1}'
		else if Siguiente(itC).x $<$ pos.x AND Siguiente(itC).y $<$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x-1, pos.y)) '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y -1)) '\ote{1}'
		else if Siguiente(itC).x $>$ pos.x AND Siguiente(itC).y $=$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x+1, pos.y)) '\ote{1}'
		end if '\ote{1}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{Cardinal(c)}'

	itConj(posicion) itPosibles $\leftarrow$ CrearIt(res) '\ote{1}'

	while HaySiguiente(itPosibles) do '\ote{1}'
		if HayAlgoEnPos(Siguiente(itPosibles), $cs$) then '\ote{1}'
			EliminarSiguiente(itPosibles) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itPosibles) '\ote{1}'
	end while '\ote{Cardinal(c)}'

'\ofi{Cardinal(c)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{HayAlgoEnPos}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{HayAlgoEnPos}{\In{pos}{posicion}, \In{cs}{estr}}{bool}'
	res $\leftarrow$ false '\ote{1}'

	if $cs$.posicionesAgente[pos.y*Columnas($cs$.campus) + pos.x].datos $\neq$ NULL then '\ote{1}'
		res $\leftarrow$ true '\ote{1}'
	end if '\ote{1}'

	if $cs$.posicionesHippies[pos.y*Columnas($cs$.campus) + pos.x].datos $\neq$ " " then '\ote{1}'
		res $\leftarrow$ true '\ote{1}'
	end if '\ote{1}'

	if $cs$.posicionesEstudiantes[pos.y*Columnas($cs$.campus) + pos.x].datos $\neq$ " " then '\ote{1}'
		res $\leftarrow$ true '\ote{1}'
	end if '\ote{1}'

	if Ocupada?(pos, $cs$.campus) then '\ote{1}'
		res $\leftarrow$ true '\ote{1}'
	end if '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{DondeIr}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{DondeIr}{\In{pos}{posicion}, \In{dist}{nat}, \In{d}{diccString(nombre,posicion)}}{conj(posicion)}'

	res $\leftarrow$ Vacio() '\ote{1}'
	itDiccString(nombre,posicion): itDicc $\leftarrow$ CrearIt(d) '\ote{1}'

	while HaySiguiente(itDicc) do '\ote{1}'
		if dist = Distancia(pos,Siguiente(itDicc)) then '\ote{1}'
			AgregarRapido(res, Siguiente(itDicc)) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itDicc) '\ote{1}'
	end while '\ote{$\#$Claves(d)}'

'\ofi{O(\# Claves(d))}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{DistanciaMasCorta}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{DistanciaMasCorta}{\In{pos}{posicion}, \In{d}{dicString(nombre, posicion)}}{int}'

	itDiccString(nombre,posicion): itDicc $\leftarrow$ CrearIt(d) '\ote{1}'
	res $\leftarrow$ Distancia(pos, Siguiente(itDicc)) '\ote{1}'
	Avanzar(itDicc) '\ote{1}'

	while HaySiguiente(itDicc) do '\ote{1}'
		if res $>$ Distancia(pos, Siguiente(itDicc)) '\ote{1}'
			res $\leftarrow$ Distancia(pos, Siguiente(itDicc)) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itDicc)
	end while '\ote{$\#$Claves(d)}'

'\ofi{O(\#Claves(d))}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{Distancia}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{Distancia}{\In{pos1,pos2}{posicion}}{nat}'

	res $\leftarrow$ $|pos2.x - pos1.x| + |pos2.y - pos1.x|$ '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iMoverAgente}{\In{a}{agente}, \Inout{cs}{estr} }{}'
	vector(tupla(agente, puntero(datosAgente)))
		placas $\leftarrow$ ordenadoPorClave(cs.personalAS)						'\ote{1}'
	puntero(datosAgente) as $\leftarrow$ busqBinPorPlaca(placas, a)				'\ote{$log(N_a)$}'

	// Actualizo la posicion del agente
	posicion nuevaPos $\leftarrow$ ProxPos((*as).posicion, cs.hippies, cs)		'\ote{$N_h$}'
	posicionesAgentes[(*as).posicion.y * columnas(cs.campus) + (*as).posicion.x].datos
		$\leftarrow$ NULL														'\ote{1}'
	posicionesAgentes[nuevaPos.y * columnas(cs.campus) + nuevaPos.x]
		$\leftarrow$ tupla(a, as)												'\ote{1}'
	(*as).posicion $\leftarrow$ nuevaPos										'\ote{1}'

	// Me fijo a quienes atrapa
	posicion posArr $\leftarrow$ moverDir(cs.campus, nuevaPos, arriba)			'\ote{1}'
	actualizarAgente(cs, posArr, a, as) 				'\ote{$log(N_a) + |n_m| + N_h$}'

	posicion posAba $\leftarrow$ moverDir(cs.campus, nuevaPos, abajo)			'\ote{1}'
	actualizarAgente(cs, posAba, a, as) 				'\ote{$log(N_a) + |n_m| + N_h$}'

	posicion posDer $\leftarrow$ moverDir(cs.campus, nuevaPos, der)				'\ote{1}'
	actualizarAgente(cs, posDer, a, as) 				'\ote{$log(N_a) + |n_m| + N_h$}'

	posicion posIzq $\leftarrow$ moverDir(cs.campus, nuevaPos, izq)				'\ote{1}'
	actualizarAgente(cs, posIzq, a, as) 				'\ote{$log(N_a) + |n_m| + N_h$}'


'\ofi{O(log(N_a) + |n_m| + N_h)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{actualizarAgente}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{actualizarAgente}{\Inout{cs}{estr}, \In{posicion}{pos}, \In{a}{agente}, \In{puntero(datosAgente)}{as}}{}'
	if(posValida?(cs.campus, pos) then 										'\ote{1}'

	   	if(posicionesHippies[pos.y * columnas(cs.campus) + pos.x] $\not$= "") then
	   		if(atrapado?(cs, pos)) then										'\ote{1}'
	   			// Le sumo uno a sus capturas, actualizo masVigilante y mato al hippie
	   			(*as).cantAtrapados++;											'\ote{1}'
	   			if((*as).cantAtrapados > (*cs.masVigilante.datos).cantAtrapados) then
	   				cs.masVigilante $\leftarrow$ tupla(a, as)					'\ote{1}'
	   			end if
	   			borrar(cs.hippies, posicionesHippies[pos.y *
	   			       columnas(cs.campus) + pos.x])							'\ote{$|n_m|$}'
	   			posicionesHippies[pos.y * columnas(cs.campus) + pos.x]
	   				$\leftarrow$ ""												'\ote{1}'
	   		end if
	   	end if

	   	if(posicionesEstudiantes[pos.y * columnas(cs.campus) + pos.x] $\not$= "") then
	   		if(atrapado?(cs, pos)) then 										'\ote{1}'
	   			// Actualizo las sanciones y las estructuras relacionadas
	   			cs.mismasSancModificado $\leftarrow$ true						'\ote{1}'

	   			itConj(agente) iterConj $\leftarrow$ (*as).itConjMismasSanc 	'\ote{1}'
	   			EliminarSiguiente(iterConj)										'\ote{1}'

	   			itLista(kSanc) iterLista $\leftarrow$ (*as).itMismasSanc 		'\ote{1}'
	   			// Me guardo un iterador para borrar el nodo de la lista
	   			// si es que queda sin agentes
	   			itLista(kSanc) iterListaAnterior $\leftarrow$ (*as).itMismasSanc '\ote{1}'
	   			if(HaySiguiente?(iterLista) then 								'\ote{1}'
	   			   	// Me fijo si el siguiente es la siguiente sancion
	   			   	nat : sanciones $\leftarrow$ Siguiente(iterLista).sanc 		'\ote{1}'
	   			   	Avanzar(iterLista) 											'\ote{1}'

	   			   	if(Siguiente(iterLista).sanc = sanciones + 1) then 			'\ote{1}'
	   			   		// Lo agrego al conjunto
	   			   		(*as).itConjMismasSanc $\leftarrow$
	   			   			AgregarRapido(a, Siguiente(iterLista).agentes)		'\ote{1}'
	   			   	else
	   			   		// Creo un nuevo nodo en el medio
	   			   		conj(agente) conj $\leftarrow$ Vacio()					'\ote{1}'
	   			   		(*as).itConjMismasSanc $\leftarrow$
	   			   			AgregarRapido(a, conj)								'\ote{1}'
	   			   		kSanc nodo $\leftarrow$ tupla(sanciones + 1, conj)		'\ote{1}'
	   			   		AgregarComoAnterior(iterLista, nodo)					'\ote{1}'
	   			   		Retroceder(iterLista)									'\ote{1}'
	   			   		(*as).itMismasSanc $leftarrow$ iterLista				'\ote{1}'
	   			   	end if
	   			else
	   				// Creo un nuevo nodo
	   				conj(agente) conj $\leftarrow$ Vacio()					'\ote{1}'
	   				(*as).itConjMismasSanc $\leftarrow$
   			   			AgregarRapido(a, conj)								'\ote{1}'
   			   		kSanc nodo $\leftarrow$ tupla(sanciones + 1, conj)		'\ote{1}'
   			   		AgregarComoSiguiente(iterLista, nodo)					'\ote{1}'
   			   		Avanzar(iterLista)										'\ote{1}'
	   			   	(*as).itMismasSanc $leftarrow$ iterLista				'\ote{1}'
	   			end if

	   			if(!HaySiguiente?(iterConj) then							'\ote{1}'
	   				// Borro el nodo anterior de la lista porque no tiene agentes
	   				EliminarSiguiente(iterListaAnterior)					'\ote{1}'
	   			end if

	   			(*as).cantSanc++;											'\ote{1}'
	   		end if
	   	end if
	end if
'\ofi{O(log(N_a) + |n_m| + N_h)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iCampus}{\In{cs}{estr} }{campus}'
	$res$ $\leftarrow$ $cs$.campus'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iEstudiantes}{\In{cs}{estr} }{itDiccString(nombre,posición)}'
	$res$ $\leftarrow$ CrearIt($cs$.estudiantes)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iHippies}{\In{cs}{estr} }{itDiccString(nombre,posición)}'
	$res$ $\leftarrow$ CrearIt($cs$.hippies)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iAgentes}{\In{cs}{estr} }{itDiccNat(agente,datosAgente)}'
	$res$ $\leftarrow$ CrearIt($cs$.personalAS)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iPosEstudianteYHippie}{\In{id}{nombre}, \In{cs}{estr} }{posición}'
	if Definido?($id$, $cs$.hippies) then '\ote{$|n_m|$}'
		$res$ $\leftarrow$ Obtener($id$, $cs$.hippies)'\ote{$|n_m|$}'
	else
		$res$ $\leftarrow$ Obtener($id$, $cs$.estudiantes)'\ote{$|n_m|$}'
	end if
'\ofi{O(|n_m|) + O(4*2|n_m|) = O(|n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iPosAgente}{\In{a}{agente}, \In{cs}{estr} }{posición}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).posicion '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iCantSanciones}{\In{a}{agente}, \In{cs}{estr} }{}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).cantSanc '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iCantHippiesAtrapados}{\In{a}{agente}, \In{cs}{estr} }{}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).cantAtrapados '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iConMismasSanciones}{\In{a}{agente}, \In{cs}{estr} }{lista(agente)}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).itMismasSanc.conjAgente '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iConKSanciones}{\In{k}{nat}, \In{cs}{estr} }{lista(agente)}'
	if $cs$.mismasSancModificado == true then '\ote{1}'
		hacerArregloMismasSanc($cs$) '\ote{$N_a$}'
		$cs$.mismasSancModificado $\leftarrow$ false
	end if

	nat: i $\leftarrow$ 0
	bool: esta $\leftarrow$ busqBinAgente($k$, i, $cs$.vectorMismasSanc) '\ote{$logN_a$}'
	if esta = true then '\ote{1}'
		res $\leftarrow$ *$cs$.vectorMismasSanc[i].agentes '\ote{1}'
	else
		res $\leftarrow$ Vacia() '\ote{1}'
	end if

'\ofi{\text{Si las sanciones no fueron modificadas: } O(N_a) \text{. Si no } O(logN_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{hacerArregloMismasSanc}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{hacerArregloMismasSanc}{\Inout{cs}{estr}}{}'
	arreglo(puntero(kSanc)): arregloNuevo $\leftarrow$ CrearArreglo(Longitud($cs$.listaMismasSanc))
	'\ote{$N_a$}'
	itLista(kSanc): it $\leftarrow$ CrearIt($cs$.listaMismasSanc) '\ote{1}'
	nat: i $\leftarrow$ $0$ '\ote{1}'

	while HaySiguiente(it) do '\ote{1}'
		puntero(kSanc): p $\leftarrow$ puntero(Siguiente(it)) '\ote{1}'
		arregloNuevo[i] $\leftarrow$ p '\ote{1}'
		i $\leftarrow$ i $+1$ '\ote{1}'
		Avanzar(it) '\ote{1}'
	end while '\ote{$N_a$}'

	$cs$.arregloMismasSanc $\leftarrow$ arregloNuevo '\ote{1}'

'\ofi{O(N_a) + O(N_a) = O(N_a) \text{ Como máximo va a ser la cantidad de agentes la lista listaMismasSanc} }'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{busqBinAgente}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{busqBinAgente}{\In{k}{nat}, \Inout{i}{nat}, \In{v}{arreglo(puntero(kSanc))}}{bool}'
	nat: n $\leftarrow$ $0$ '\ote{1}'
	nat: m $\leftarrow$ Longitud(v) '\ote{1}'
	nat: med

	while n $\neq$ m$-1$ do '\ote{1}'
		med $\leftarrow$ $\frac{n+m}{2}$ '\ote{1}'
		if med $\leq$ k then '\ote{1}'
			n $\leftarrow$ med '\ote{1}'
		else
			m $\leftarrow$ med '\ote{1}'
		end if
	end while '\ote{$log(N_a)$}'

	if v[n] $=$ k then
		i $\leftarrow$ n
		$res$ $\leftarrow$ true
	else
		$res$ $\leftarrow$ false
	end if

'\ofi{O(logN_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{Atrapado?}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{Atrapado?}{\In{c}{campus}, \In{pos}{Posicion}}{bool}'
	$res$ $\leftarrow$ todasOcupadas?(vecinos(pos,cs.campus)) '\ote{1}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{busqBinPorPlaca}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{busqBinPorPlaca}{\In{a}{agente}, \In{v}{vector(tupla(clave : agente, p : puntero(datosAgente))}}{puntero(datosAgente)}'
	nat: inf $\leftarrow$ $0$ '\ote{1}'
	nat: sup $\leftarrow$ Longitud(v) '\ote{1}'
	nat: med $\leftarrow$ $\frac{inf+sup}{2}$ '\ote{1}'

	while inf $\neq$ sup$-1$ do '\ote{1}'
		med $\leftarrow$ $\frac{inf+sup}{2}$ '\ote{1}'
		if v[med].clave $\leq$ a then '\ote{1}'
			inf $\leftarrow$ med '\ote{1}'
		else
			sup $\leftarrow$ med '\ote{1}'
		end if
	end while '\ote{$log(N_a)$}'

	$res$ $\leftarrow$ v[inf].p

'\ofi{O(logN_a)}'
\end{lstlisting}


\textbf{Complejidad:} Analizar complejidad.

