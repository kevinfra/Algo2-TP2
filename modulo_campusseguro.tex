\section{Módulo CampusSeguro}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{CampusSeguro}.

\textbf{géneros}: \TipoVariable{campusSeguro}.

\subsubsection{Operaciones básicas de CampusSeguro}

\InterfazFuncion{comenzarRastrillaje}{\In{c}{campus}, \In{d}{dicc(placa,AS)}}{campusSeguro}
[($\forall a$ : agente) (def?($a$,$d$) $\Rightarrow_L$ (posVálida(obtener($a$,$d$)) $\land$ $\neg$ocupada?(obtener($a$,$d$,$c$))) $\land$ ($\forall a, a2$ : agente) ((def?($a$,$d$) $\land$ def?($a2$,$d$) $\land a \neq a2$) $\Rightarrow_L$ obtener($a$,$d$) $\neq$ obtener($a2$,$d$))]
{res $=_{obs}$ comenzarRastrillaje(c,d)}
[$O()$]
[Crea un nuevo campusSeguro tomando un campus y un diccionario con agentes.]
[]

~

\InterfazFuncion{ingresarEstudiante}{\In{e}{nombre}, \In{p}{posición}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land e \not\in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)) $\land$ esIngreso?($p$,campus($cs$)) $\land$ $\neg$estaOcupada?($p$,$cs$)]
{$cs =_{obs}$ ingresarEstudiante($e$,$p$,$cs_o$)}
[$O(|n_m|) + O(log(N_a))$]
[Ingresa un nuevo estudiante al campusSeguro]
[]

~

\InterfazFuncion{ingresarHippie}{\In{h}{nombre}, \In{p}{posición}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land h \not\in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)) $\land$ esIngreso?($p$,campus($cs$)) $\land$ $\neg$estaOcupada?($p$,$cs$)]
{$cs =_{obs}$ ingresarHippie($h$,$p$,$cs_o$)}
[$O(|n_m|) + O(log(N_a))$]
[Ingresa un nuevo hippie el campusSeguro]
[]

~

\InterfazFuncion{moverEstudiante}{\In{e}{nombre}, \In{dir}{dirección}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land e \in$ estudiantes($cs$) $\land$ (seRetira($e$,$dir$,$cs$) $\lor$ \\
(posValida(proxPosicion(posEstudianteYHippie($e$,$cs$),$dir$,campus($cs$)), campus($cs$)) $\land$ $\neg$estaOcupada?(proxPosicion(posEstudianteYHippie($e$,$cs$),$dir$,campus($cs$)),$cs$)]
{$cs =_{obs}$ moverEstudiante($e$,$dir$,$cs_o$)}
[$O(|n_m|) + O(log(N_a))$]
[Mueve un estudiante dentro del campus o lo hace salir y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{moverHippie}{\In{h}{nombre}, \In{d}{direccion}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land h \in$ hippies($cs$) $\land$ $\neg$todasOcupadas?(vecinos(posEstudianteYHippie($h$,$cs$),campus($cs$)), $cs$)]
{$cs =_{obs}$ moverHippie($h$,$d$,$cs_o$}
[$O(|n_m|) + O(log(N_a)) + O(N_e)$]
[Mueve un hippie dentro del campus y se actualizan los atrapados, sanciones(si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{moverAgente}{\In{a}{agente}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land a \in$ agentes($cs$) $\land_L$ cantSanciones($a$,$cs$) $\leq 3 \land$ \\
$\neg$todasOcupadas?(vecinos(posEstudianteYHippie($h$,$cs$),campus($cs$)),$cs$)]
{$cs =_{obs}$ moverAgente($a$,$cs_o$)}
[$O(|n_m|) + O(log(N_a)) + O(N_h)$]
[Mueve un agente dentro del campus y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{campus}{\In{cs}{campusSeguro}}{campus}
[true]
{$res =_{obs}$ campus($cs$)}
[$O(1)$]
[Devuelve el campus del campusSeguro.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{estudiantes}{\In{cs}{campusSeguro}}{conj(nombre)}
[true]
{$res =_{obs}$ estudiantes($cs$)}
[$O(1)$]
[Devuelve el conjunto de los estudiantes que estan en el campus.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{hippies}{\In{cs}{campusSeguro}}{conj(nombre)}
[true]
{$res =_{obs}$ hippies($cs$)}
[$O(1)$]
[Devuelve el conjunto de los hippies que estan en el campus.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{agentes}{\In{cs}{campusSeguro}}{conj(agentes)}
[true]
{$res =_{obs}$ agentes($cs$)}
[$O(1)$]
[Devuelve el conjunto de los agentes que estan en el campus.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{posEstudianteYHippie}{\In{id}{nombre}, \In{cs}{campusSeguro}}{posición}
[$id \in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)]
{$res =_{obs}$ posEstudianteYHippie($id$,$cs$)}
[$O(|n_m|)$, donde $|m_n|$ es la longitud mas larga entre todos los nombres.]
[Devuelve la posicion del estudiante o hippie.]
[]

~

\InterfazFuncion{posAgente}{\In{a}{agente}, \In{cs}{campusSeguro}}{posición}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ posAgente($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la posicion del agente pasado como parametro.]
[]

~

\InterfazFuncion{cantSanciones}{\In{a}{agente}, \In{cs}{campusSeguro}}{nat}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ cantSanciones($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la cantidad de sanciones que posee el agente pasado como parametro.]
[]

~

\InterfazFuncion{cantHippiesAtrapados}{\In{a}{agente}, \In{cs}{campusSeguro}}{nat}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ cantHippiesAtrapados($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la cantidad de hippies que atrapo el agente pasado como parametro.]
[]

~

\InterfazFuncion{másVigilante}{\In{cs}{campusSeguro}}{agente}
[true]
{$res =_{obs}$ másVigilante($cs$)}
[$O(1)$]
[Devuelve la placa del agente que ha atrapado mas hippies.]
[]

~

\InterfazFuncion{conMismasSanciones}{\In{a}{agente}, \In{cs}{campusSeguro}}{conj(agentes)}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ conMismasSanciones($a$,$cs$)}
[$O(1)$]
[Devuelve el conjunto de los agentes que tienen el mismo numero de sanciones que el agente pasado como parametro.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{conKSanciones}{\In{k}{nat}, \In{cs}{campusSeguro}}{conj(agentes)}
[true]
{$res =_{obs}$ conKSanciones($k$,$cs$)}
[$O(N_a)$ la primera vez que se la llama y $O(log(N_a))$ en futuras llamadas mientras no ocurran sanciones.]
[Devuelve el conjuto de agenes que tienen k sanciones.]
[$res$ es una referencia no modificable.]

~
\pagebreak

\subsubsection{Representación de campusSeguro}

\begin{Estructura}{campusSeguro}[estr]
	\begin{Tupla}[estr]
		\tupItem{campus}{campus}%
		\tupItem{\\ personalAS}{diccNat(agente,datosAgente)}%
		\tupItem{\\ posicionesAgente}{vector(As)}%
		\tupItem{\\ masVigilante}{As}%
		\tupItem{\\ sanciones}{mismasSanc}%
		\tupItem{\\ hippies}{dicString(nombre,posicion)}%
		\tupItem{\\ estudiantes}{dicString(nombre, posicion)}%
	\end{Tupla}

	~

	\begin{Tupla}[datosAgente]
		\tupItem{posicion}{posicion}%
		\tupItem{\\ cantSanc}{nat}%
		\tupItem{\\ cantAtrapados}{nat}%
		\tupItem{\\ itMismasSanc}{itLista(kSanc)}%
		\tupItem{\\ itConjMismasSanc}{itConj(agente)}%
	\end{Tupla}

	~
	\begin{Tupla}[mismasSanc]
		\tupItem{lista}{lista(kSanc)}%
		\tupItem{huboSanc}{bool}%
		\tupItem{vectorMismasSanc}{vector(puntero(kSanc))}%
	\end{Tupla}

	~

	\begin{Tupla}[As]
		\tupItem{agente}{nat}%
		\tupItem{datos}{puntero(datosAgente)}%
	\end{Tupla}

	~

	\begin{Tupla}[kSanc]
		\tupItem{sanc}{nat}
		\tupItem{conjAgente}{lista(agente)}
	\end{Tupla}

\end{Estructura}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\begin{enumerate}
	%done
	\item Las posiciones de todos los agentes son posiciones validas del campus.
	%done
	\item Las posiciones de los hippies son posiciones validas del campus.
	%done
	\item Las posiciones de los estudiantes son posiciones validas del campus.
	%done
	\item Las posiciones de los agentes son distintas a las posiciones de los hippies.
	%done
	\item Las posiciones de los estudiantes son distintas a las posiciones de los hippies.
	%done
	\item Las posiciones de los agentes son distintas a las posiciones de los estudiantes.
	%done
	\item El agente masVigilante esta definido en personalAs y tiene la mayor cantidad de sanciones.
	%done
	\item Para todo nombre que esta definido en el diccionario de hippies no puede estar definido en el diccionario de estudiantes y viceversa.
	%done
	\item La cantidad de elementos que tiene posicionesAgente es la cantidad de coordenadas que tiene la grilla.
	%done
	\item Los agentes de posicionesAgente son los mismos que los de personalAs y viceversa.
	%done
	\item La posicion de todos los agentes de posicionesAgente se mapea con la posicion que tienen en personalAs y viceversa.
	%done
	\item Las posiciones en posicionesAgente que no tienen agente tienen un puntero a NULL.
	%done
	\item La cantidad de estudiantes, hippies, agentes y obstaculos es menor o igual que la cantidad de coordenadas que tiene el campus.
	%done
	\item La longitud de la lista mismasSanc es la cantidad de sanciones diferentes que hay.
	
%	\item Por cada posición de la lista mismasSanc va a estar el conjunto de todos los agentes que tienen la misma cantidad de sanciones.
%	\item Todos los agentes de personalAS estan en mismasSanc en la posicion del vector que tiene su sanción.
%	\item La cantidad de agentes en mismasSanc es la misma cantidad de agentes que personalAS
%	\item Cada agente de personalAS tiene un iterador (posMismasSanc) que apunta al vector mismasSanc en la posición que tiene su misma cantidad de sanciones y otro iterador (posVectorMismasSanc) que apunta a la posicion del vector vectorAgente que posee la posicion en donde esta el otro iterador en donde esta el agente.
	
\end{enumerate}

\pagebreak

\Rep[estr][e]{
	\\
	($\forall a$: nat)(def?($a$, $e$.personalAS) $\Rightarrow_L$ posValida(Obtener($a$,$e$.personalAS).posicion, e.campus) $\land$ $\neg$ocupada?(Obtener($a$,$e$.personalAS).posicion),e.campus)
	\\
	$\land$
	\\
	($\forall h$: string)(def?($h$, $e$.hippies) $\Rightarrow_L$ posValida(Obtener($h$,$e$.hippies), e.campus) $\land$ $\neg$ocupada?(Obtener($h$, $e$.hippies)),e.campus)
	\\
	$\land$
	\\
	($\forall est$: string)(def?($est$, $e$.estudiantes) $\Rightarrow_L$ posValida(Obtener($est$, $e$.estudiantes), e.campus) $\land$ $\neg$ocupada?(Obtener($est$, $e$.estudiantes)), e.campus)
	\\
	$\land$
	\\
	($\forall a$: nat)($\forall h$: string) def?($a$, $e$.personalAS) $\land$ def?($h$, $e$.hippies) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).posicion $\neq$ Obtener($h$, $e$.hippies)
	\\
	$\land$
	\\
	($\forall est$: string)($\forall h$: string) def?($est$,$e$.estudiantes) $\land$ def?($h$,$e$.hippies) $\Rightarrow_L$ Obtener($est$,$e$.estudiantes) $\neq$ Obtener($h$, $e$.hippies)
	\\
	$\land$
	\\
	($\forall a$: nat)($\forall est$: string) def?($a$, $e$.personalAS) $\land$ def?($est$, $e$.estudiantes) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).posicion $\neq$ Obtener($est$, $e$.estudiantes)
	\\
	$\land$
	\\
	def?(masVigilante.agente, $e$.personalAS) $\land_L$ Obtener(masVigilante.agente, $e$.personalAS) = *masVigilante.datos
	\\
	$\land$
	\\
	($\forall a$: nat) def?($a$, $e$.personalAS) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).cantSanc $\leq$ *masVigilante.datos.cantSanc 
	\\
	$\land$
	\\
	($\forall h$: string) def?($h$, $e$.hippies) $\Rightarrow$ $\neg$def?($h$, $e$.estudiantes)
	\\
	$\land$
	\\
	($\forall est$: string) def?($est$, $e$.estudiantes) $\Rightarrow$ $\neg$def?($est$, $e$.hippies)
	\\
	$\land$
	\\
	longitud($e$.posicionesAgente) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\
	($\forall a$: nat) def?($a$, $e$.personalAS) $\Leftrightarrow_L$ ($\exists! i$: nat) $i <$ longitud($e$.posicionesAgente) $\land_L$ $e$.posicionesAgente[$i$].agente = $a$ $\land$ *$e$.posicionesAgente[$i$].datos = Obtener($a$, $e$.personalAS) $\land$ ($i$ $div$ filas($e$.campus)) = Obtener($a$, $e$.personalAS).posicion.X $\land$ ($i$ $mod$ columnas($e$.campus)) = Obtener($a$, $e$.personalAS).posicion.Y
	\\
	$\land$
	\\
	($\forall i$: nat) $i <$ longitud($e$.posicionesAgente) $\Leftrightarrow_L$ *$e$.posicionesAgente[$i$].datos = NULL $\lor$ ($\exists! a$: nat) def?($a$, $e$.personalAS) $\land_L$ *$e$.posicionesAgente[$i$].datos = Obtener($a$, $e$.personalAS)
	\\
	$\land$
	\\
	$\#$Claves($e$.personalAS) $+$ $\#$Claves($e$.hippies) $+$ $\#$Claves($e$.estudiantes) $+$ $\#$Obstaculos($e$.campus) $\leq$ filas($e$.campus)*columnas($e$.campus)
	\\
	$\land$
	\\
%	Long($e$.mismasSanc) = $\#$SancionesDistintas($e$.personalAS)
%	\\
%	$\land$
%	\\
%	($\forall a$: nat) def?($a$, $e$.personalAS) $\Leftrightarrow_L$ ($\exists$ i:nat) $i <$ Longitud($e$.mismasSanc) $\land_L$ $e$.mismasSanc[$i$].sanc = Obtener($a$, $e$.personalAS).cantSanc $\land$ ($\exists j:$ nat) $j <$ Longitud($e$.mismasSanc.vectorAgente) $\land_L$ $e$.mismasSanc[$i$].vectorAgente[$j$] = a
%	\\
%	$\land$
%	\\
%	$\#$Claves($e$.personalAS) = cantAgentes($e$.mismasSanc)
%	\\
%	$\land$
%	\\
%	($\forall a$: nat) def?($a$, $e$.personalAS) $\Rightarrow_L$ Siguiente(Obtener($a$, $e$.personalAS).posMismasSanc).sanc = Obtener($a$, $e$.personalAS).cantSanc $\land$ Siguiente(Obtener($a$, $e$.personalAS).posVectorMismasSanc) = $a$
%	\\
%	$\land$
%	\\

	

}\mbox{}

\tadOperacion{$\#$Obstaculos}{campus}{nat}{}
\tadOperacion{$\#$ObstaculosAux}{nat,nat,campus}{nat}{}
\tadOperacion{$\#$SancionesDistintas}{diccNat(agente, datosAgente)}{nat}{}
\tadOperacion{conjSanciones}{conj(nat), diccNat(agente,datosAgente)}{conj(nat)}{}
\tadOperacion{cantAgentes}{secu(kSanc}{nat}{}

~

\tadAxioma{$\#$Obstaculos(c)}{
	$\#$ObstaculosAux(filas($c$)$-1$, columnas($c$)$-1$, $c$)
}
\tadAxioma{$\#$ObstaculosAux(f,col,c)}{
	\IF ($f=0 \land col=0$) THEN	$\beta$(ocupada?(<$f$,$col$>, $c$)
	ELSE{
		\IF ($f \neq 0 \land col = 0$) THEN $\#$ObstaculosAux($f-1$, columnas($c$)$-1$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
		ELSE{
			\IF ($f = 0 \land col \neq 0$) THEN $\#$ObstaculosAux(filas($c$),$col-1$,$c$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
			ELSE{
				$\#$ObstaculosAux($f-1$, $col-1$, $c$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
			}
			FI
		}
		FI
	}
	FI
}
\tadAxioma{$\#$SancionesDistintas(d)}{
	$\#$conjSanciones(Claves($d$),$d$)
}
\tadAxioma{conjSanciones(c,d)}{
	\IF $\neg\emptyset$($c$) THEN $\emptyset$
	ELSE{
		Ag(Obtener(DameUno($c$),$d$).cantSanc, conjSanciones(SinUno($c$,$d$)))
	}
	FI
}
\tadAxioma{cantAgentes(s)}{
	\IF $s = <>$ THEN 0
	ELSE {
		Long(prim($s$).vectorAgente) + cantAgentes(fin($s$))
	}
	FI
}

\pagebreak

\subsubsection{Función de Abstracción}
\Abs[estr]{campusSeguro}[e]{cs}{
$e$.campus $=$ campus($cs$) 
\\
$\land$
\\
$e$.estudiantes $=$ estudiantes($cs$)
\\
$\land$
\\
$e$.hippies $=$ hippies($cs$)
\\
$\land$
\\
$e$.personalAS $=$ agentes($cs$)
\\
$\land$
\\
($\forall a$: nat) (def?($a$, $e$.personalAS) $\Rightarrow_L$ posAgente($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).posicion $\land$ cantSanciones($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).cantSanc $\land$cantHippiesAtrapados($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).cantAtrapados)
\\
$\land$
\\
($\forall id$: string) (def?($id$, $e$.estudiantes) $\land_L$ Obtener($id$, $e$.estudiantes) = posEstudianteYHippie(cs)) $\lor$ (def?($id$, $e$.hippies) $\land_L$ Obtener($id$, $e$.hippies) = posEstudianteYHippie(cs))
}

\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{icomenzarRastrillaje}{\In{c}{campus}, \In{d}{diccNat(agente, datosAgente)}}{estr}' 

	res.campus $\leftarrow$ c '\ote{1}'
	res.personalAS $\leftarrow$ d '\ote{1}'
	
	res.posicionesAgente $\leftarrow$ vectorizarPos(d,filas(c),columnas(c)) '\ote{}'

	res.masVigilante $\leftarrow$ menorPlaca(d) '\ote{}'
	res.hippies $\leftarrow$ Vacio() '\ote{1}'
	res.estudiantes $\leftarrow$ Vacio() '\ote{1}'

'\ofi{O()}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{vectorizarPos}{\In{d}{diccNat(agente, datosAgente)}, \In{f,c}{nat}}{vector(AS)}'
	
	vectorPos $\leftarrow$ Vacio()
	
	while i = 0..f*c do '\ote{1}'
		itd $\leftarrow$ CrearIt(d) '\ote{1}'
		AgregarAtras(vectorPos, $<0,NILL>$) '\ote{1}'
	end while

	itd $\leftarrow$ CrearIt(d) '\ote{1}'

	while HaySiguiente(itd) do
		
	



'\ofi{O()}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iIngresarEstudiante}{\In{e}{nombre}, \In{pos}{posicion}, \Inout{cs}{campusSeguro} } {}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iIngresarHippie}{\In{h}{nombre}, \In{pos}{posicion}, \Inout{cs}{campusSeguro} }{}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iMoverEstudiante}{\In{e}{nombre}, \In{d}{dirección}, \Inout{cs}{campusSeguro} }{}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iMoverHippie}{\In{h}{nombre}, \Inout{cs}{campusSeguro} }{}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iMoverAgente}{\In{a}{agente}, \Inout{cs}{campusSeguro} }{}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iCampus}{\In{cs}{campusSeguro} }{campus}'
	$res$ $\leftarrow$ $cs$.campus'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iEstudiantes}{\In{cs}{campusSeguro} }{itDiccString(nombre,posición)}'
	$res$ $\leftarrow$ CrearIt($cs$.estudiantes)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iHippies}{\In{cs}{campusSeguro} }{itDiccString(nombre,posición)}'
	$res$ $\leftarrow$ CrearIt($cs$.hippies)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iAgentes}{\In{cs}{campusSeguro} }{itDiccNat(agente,datosAgente)}'
	$res$ $\leftarrow$ CrearIt($cs$.personalAS)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iPosEstudianteYHippie}{\In{id}{nombre}, \In{cs}{campusSeguro} }{posición}'
	if Definido?($id$, $cs$.hippies) then '\ote{$|n_m|$}'
		$res$ $\leftarrow$ Obtener($id$, $cs$.hippies)'\ote{$|n_m|$}'
	else
		$res$ $\leftarrow$ Obtener($id$, $cs$.estudiantes)'\ote{$|n_m|$}'
	end if
'\ofi{O(|n_m|) + O(|n_m|) = O(|n_m|)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iPosAgente}{\In{a}{agente}, \In{cs}{campusSeguro} }{posición}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS)'\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iCantSanciones}{\In{a}{agente}, \In{cs}{campusSeguro} }{}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS) '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iCantHippiesAtrapados}{\In{a}{agente}, \In{cs}{campusSeguro} }{}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS) '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iConMismasSanciones}{\In{a}{agente}, \In{cs}{campusSeguro} }{lista(agente)}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).itMismasSanc.conjAgente '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iConKSanciones}{\In{k}{nat}, \In{cs}{campusSeguro} }{lista(agente)}'
	if $cs$.sanciones.huboSanc == true then '\ote{1}'
		rearmarVectorMismasSanc($cs$) '\ote{$N_a$}'
	end if

	esta $\leftarrow$ busqBinAgente(k, i, $cs$.sanciones.vectorMismasSanc) '\ote{log(n)}'
	if esta == true then '\ote{1}'
		res $\leftarrow$ *$cs$.sanciones.vectorMismasSanc[i].conjAgente '\ote{1}'
	else
		res $\leftarrow$ Vacia() '\ote{1}'
	end if

'\ofi{O(N_a) \text{ la primera vez que se llama y } O(log N_a) \text{ en futuras llamadas mientras no ocurran sanciones.}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{rearmarVectorMismasSanc}{\Inout{cs}{camspusSeguro}}{}'
	
'\ofi{O(N_a)}'
\end{lstlisting}


%de aca para abajo es del tp del cuatri pasado.
\begin{lstlisting}[mathescape]
'\alg{Red}{\In{dcn}{dcnet}}{red}'

	res $\leftarrow$ dcn.topologia '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{CaminoRecorrido}{\In{dcn}{dcnet}, \In{p}{paquete}}{lista(compu)}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	while i < Longitud(dcn.vectorCompusDCNet) do '\ote{1}'
		if Definido?(dcn.vectorCompusDCNet[i].diccPaquetesDCNet, p.id) then '\ote{log(k)}'
			res $\leftarrow$ Siguiente(Obtener(dcn.vectorCompusDCNet[i].diccPaquetesDCNet,
				p.id)).recorrido '\ote{log(k)}'
		end if
		i++ '\ote{1}'
	end while '\ote{n * log(k)}'

'\ofi{O(n * log(k))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{CantidadEnviados}{\In{dcn}{dcnet}, \In{c}{compu}}{nat}'

	res $\leftarrow$ Obtener(dcn.diccCompusDCNet, c.ip)$\rightarrow$enviados '\ote{L}'

'\ofi{O(L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{EnEspera}{\In{dcn}{dcnet}, \In{c}{compu}}{nat}'

	res $\leftarrow$ Obtener(dcn.diccCompusDCNet, c.ip)$\rightarrow$conjPaquetes '\ote{L}'

'\ofi{O(L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{PaqueteEnTransito}{\In{dcn}{dcnet}, \In{p}{paquete}}{bool}'

	res $\leftarrow$ false
	nat: i $\leftarrow$ 0 '\ote{1}'
	while i < Longitud(dcn.vectorCompusDCNet) do '\ote{1}'
		if Definido?(dcn.vectorCompusDCNet[i].diccPaquetesDCNet, p.id) then '\ote{log(k)}'
			res $\leftarrow$ true '\ote{1}'
		end if
		i++ '\ote{1}'
	end while '\ote{n * log(k)}'

'\ofi{O(n * log(k))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{LaQueMasEnvio}{\In{dcn}{dcnet}}{compu}'

	res $\leftarrow$ *(dcn.laQueMasEnvio$\rightarrow$pc) '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{$\puntito$ $=_i$ $\puntito$}{\In{dcn_1}{dcnet}, \In{dcn_2}{dcnet}}{bool}'

	bool: boolTopo $\leftarrow$ $dcn_1$.topologia = $dcn_2$.topologia '\ote{n + $L^2$}'
	bool: boolVec $\leftarrow$ $dcn_1$.vectorCompusDCNet = $dcn_2$.vectorCompusDCNet '\ote{n * k * (k + n)}'
	bool: boolConj $\leftarrow$ $dcn_1$.conjPaquetesDCNet = $dcn_2$.conjPaquetesDCNet '\ote{$k^3$ * (k + n)}'
	bool: boolMasEnvio $\leftarrow$ *($dcn_1$.laQueMasEnvio) = *($dcn_2$.laQueMasEnvio) '\ote{1}'

	res $\leftarrow$ boolTopo $\land$ boolVec $\land$ boolTrie $\land$ boolConj $\land$ boolMasEnvio '\ote{1}'

'\ofi{O(n * k^3 * (k + n))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{$\puntito$ $=_{compudcn}$ $\puntito$}{\In{c_1}{compuDCNet}, \In{c_2}{compuDCNet}}{bool}'

	bool: boolPC $\leftarrow$ *($c_1$.pc) = *($c_2$.pc) '\ote{1}'
	bool: boolConj $\leftarrow$ $c_1$.conjPaquetes = $c_1$.conjPaquetes '\ote{$k^2$}'
	bool: boolAVL $\leftarrow$ true '\ote{1}'
	bool: boolCola $\leftarrow$ true '\ote{1}'
	bool: boolPaq $\leftarrow$ Siguiente($c_1$.paqueteAEnviar) $=_{paqdcn}$ Siguiente($c_2$.paqueteAEnviar)
		'\ote{n}'
	bool: boolEnviados $\leftarrow$ $c_1$.enviados = $c_2$.enviados '\ote{1}'

	if boolConj then '\ote{1}'
		itConj: $itconj_1$ $\leftarrow$ CrearIt($c_1$.conjPaquetes) '\ote{1}'
		while HaySiguiente?($itconj_1$) do '\ote{1}'
			if Definido?($c_2$.diccPaquetesDCNet, Siguiente($itconj_1$)).id then '\ote{log(n)}'
				if $\neg$(Siguiente(Obtener($c_1$.diccPaquetesDCNet, Siguiente($itconj_1$).id))
					$=_{paqdcn}$
					Siguiente(Obtener($c_1$.diccPaquetesDCNet, Siguiente($itconj_1$).id)))
					then '\ote{n}'
					boolAVL $\leftarrow$ false '\ote{1}'
				end if
			else
				boolAVL $\leftarrow$ false '\ote{1}'
			end if
			Avanzar($itconj_1$) '\ote{1}'
		end while '\ote{n * k}'
	end if

	if EsVacia($c_1$.colaPrioridad) then '\ote{1}'
		if $\neg$EsVacia($c_2$.colaPrioridad) then '\ote{1}'
			boolCola $\leftarrow$ false '\ote{1}'
		end if
	else
		if EsVacia($c_1$.colaPrioridad) then '\ote{1}'
			boolCola $\leftarrow$ false '\ote{1}'
		else
			if $\neg$(Siguiente(Proximo($c_1$.colaPrioridad)) $=_{paqdcn}$
				Siguiente(Proximo($c_2$.colaPrioridad))) then '\ote{n}'
				boolCola $\leftarrow$ false '\ote{1}'
			end if
		end if
	end if

	res $\leftarrow$ boolPC $\land$ boolConj $\land$ boolAVL $\land$ boolCola $\land$ boolPaq $\land$ boolEnviados '\ote{1}'

'\ofi{O(k^2 + n * k) = O(k * (k + n))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{$\puntito$ $=_{paqdcn}$ $\puntito$}{\In{p_1}{paqueteDCNet}, \In{p_2}{paqueteDCNet},}{bool}'

	bool: boolPaq $\leftarrow$ Siguiente($p_1$.it) = Siguiente($p_2$.it) '\ote{1}'
	bool: boolRecorrido $\leftarrow$ $p_1$.recorrido = $p_2$.recorrido '\ote{n}'

	res $\leftarrow$ boolPaq $\land$ boolRecorrido '\ote{1}'

'\ofi{O(n)}'
\end{lstlisting}
