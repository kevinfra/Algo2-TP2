\section{Módulo CampusSeguro}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{CampusSeguro}.

\textbf{géneros}: \TipoVariable{campusSeguro}.

\subsubsection{Operaciones básicas de CampusSeguro}

\InterfazFuncion{comenzarRastrillaje}{\In{c}{campus}, \In{d}{dicc(placa,AS)}}{campusSeguro}
[($\forall a$ : agente) (def?($a$,$d$) $\Rightarrow_L$ (posVálida(obtener($a$,$d$)) $\land$ $\neg$ocupada?(obtener($a$,$d$,$c$))) $\land$ ($\forall a, a2$ : agente) ((def?($a$,$d$) $\land$ def?($a2$,$d$) $\land a \neq a2$) $\Rightarrow_L$ obtener($a$,$d$) $\neq$ obtener($a2$,$d$))]
{res $=_{obs}$ comenzarRastrillaje(c,d)}
[$O()$]
[Crea un nuevo campusSeguro tomando un campus y un diccionario con agentes.]
[]

~

\InterfazFuncion{ingresarEstudiante}{\In{e}{nombre}, \In{p}{posición}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land e \not\in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)) $\land$ esIngreso?($p$,campus($cs$)) $\land$ $\neg$estaOcupada?($p$,$cs$)]
{$cs =_{obs}$ ingresarEstudiante($e$,$p$,$cs_o$)}
[$O(|n_m|) + O(log(N_a))$]
[Ingresa un nuevo estudiante al campusSeguro]
[]

~

\InterfazFuncion{ingresarHippie}{\In{h}{nombre}, \In{p}{posición}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land h \not\in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)) $\land$ esIngreso?($p$,campus($cs$)) $\land$ $\neg$estaOcupada?($p$,$cs$)]
{$cs =_{obs}$ ingresarHippie($h$,$p$,$cs_o$)}
[$O(|n_m|) + O(log(N_a))$]
[Ingresa un nuevo hippie el campusSeguro]
[]

~

\InterfazFuncion{moverEstudiante}{\In{e}{nombre}, \In{dir}{dirección}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land e \in$ estudiantes($cs$) $\land$ (seRetira($e$,$dir$,$cs$) $\lor$ \\
(posValida(proxPosicion(posEstudianteYHippie($e$,$cs$),$dir$,campus($cs$)), campus($cs$)) $\land$ $\neg$estaOcupada?(proxPosicion(posEstudianteYHippie($e$,$cs$),$dir$,campus($cs$)),$cs$)]
{$cs =_{obs}$ moverEstudiante($e$,$dir$,$cs_o$)}
[$O(|n_m|) + O(log(N_a))$]
[Mueve un estudiante dentro del campus o lo hace salir y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{moverHippie}{\In{h}{nombre}, \In{d}{direccion}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land h \in$ hippies($cs$) $\land$ $\neg$todasOcupadas?(vecinos(posEstudianteYHippie($h$,$cs$),campus($cs$)), $cs$)]
{$cs =_{obs}$ moverHippie($h$,$d$,$cs_o$}
[$O(|n_m|) + O(log(N_a)) + O(N_e)$]
[Mueve un hippie dentro del campus y se actualizan los atrapados, sanciones(si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{moverAgente}{\In{a}{agente}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land a \in$ agentes($cs$) $\land_L$ cantSanciones($a$,$cs$) $\leq 3 \land$ \\
$\neg$todasOcupadas?(vecinos(posEstudianteYHippie($h$,$cs$),campus($cs$)),$cs$)]
{$cs =_{obs}$ moverAgente($a$,$cs_o$)}
[$O(|n_m|) + O(log(N_a)) + O(N_h)$]
[Mueve un agente dentro del campus y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{campus}{\In{cs}{campusSeguro}}{campus}
[true]
{$res =_{obs}$ campus($cs$)}
[$O(1)$]
[Devuelve el campus del campusSeguro.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{estudiantes}{\In{cs}{campusSeguro}}{conj(nombre)}
[true]
{$res =_{obs}$ estudiantes($cs$)}
[$O(1)$]
[Devuelve el conjunto de los estudiantes que estan en el campus.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{hippies}{\In{cs}{campusSeguro}}{conj(nombre)}
[true]
{$res =_{obs}$ hippies($cs$)}
[$O(1)$]
[Devuelve el conjunto de los hippies que estan en el campus.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{agentes}{\In{cs}{campusSeguro}}{conj(agentes)}
[true]
{$res =_{obs}$ agentes($cs$)}
[$O(1)$]
[Devuelve el conjunto de los agentes que estan en el campus.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{posEstudianteYHippie}{\In{id}{nombre}, \In{cs}{campusSeguro}}{posición}
[$id \in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)]
{$res =_{obs}$ posEstudianteYHippie($id$,$cs$)}
[$O(|n_m|)$, donde $|m_n|$ es la longitud mas larga entre todos los nombres.]
[Devuelve la posicion del estudiante o hippie.]
[]

~

\InterfazFuncion{posAgente}{\In{a}{agente}, \In{cs}{campusSeguro}}{posición}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ posAgente($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la posicion del agente pasado como parametro.]
[]

~

\InterfazFuncion{cantSanciones}{\In{a}{agente}, \In{cs}{campusSeguro}}{nat}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ cantSanciones($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la cantidad de sanciones que posee el agente pasado como parametro.]
[]

~

\InterfazFuncion{cantHippiesAtrapados}{\In{a}{agente}, \In{cs}{campusSeguro}}{nat}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ cantHippiesAtrapados($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la cantidad de hippies que atrapo el agente pasado como parametro.]
[]

~

\InterfazFuncion{másVigilante}{\In{cs}{campusSeguro}}{agente}
[true]
{$res =_{obs}$ másVigilante($cs$)}
[$O(1)$]
[Devuelve la placa del agente que ha atrapado mas hippies.]
[]

~

\InterfazFuncion{conMismasSanciones}{\In{a}{agente}, \In{cs}{campusSeguro}}{conj(agentes)}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ conMismasSanciones($a$,$cs$)}
[$O(1)$]
[Devuelve el conjunto de los agentes que tienen el mismo numero de sanciones que el agente pasado como parametro.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{conKSanciones}{\In{k}{nat}, \In{cs}{campusSeguro}}{conj(agentes)}
[true]
{$res =_{obs}$ conKSanciones($k$,$cs$)}
[$O(N_a)$ la primera vez que se la llama y $O(log(N_a))$ en futuras llamadas mientras no ocurran sanciones.]
[Devuelve el conjuto de agenes que tienen k sanciones.]
[$res$ es una referencia no modificable.]

~
\pagebreak

\subsubsection{Representación de campusSeguro}

\begin{Estructura}{campusSeguro}[estr]
	\begin{Tupla}[estr]
		\tupItem{campus}{campus}%
		\tupItem{\\ personalAS}{diccNat(agente,datosAgente)}%
		\tupItem{\\ posicionesAgente}{vector(As)}%
		\tupItem{\\ masVigilante}{As}%
		\tupItem{\\ listaMismasSanc}{lista(kSanc)}%
		\tupItem{\\ arregloMismasSanc}{arreglo(puntero(kSanc))}
		\tupItem{\\ mismasSancModificado}{bool}
		\tupItem{\\ hippies}{dicString(nombre,posicion)}%
		\tupItem{\\ estudiantes}{dicString(nombre, posicion)}%
		\tupItem{\\ posicionesHippies}{vector(nombre)}
		\tupItem{\\ posicionesEstudiantes}{vector(nombre)}
	\end{Tupla}

	~

	\begin{Tupla}[datosAgente]
		\tupItem{posicion}{posicion}%
		\tupItem{\\ cantSanc}{nat}%
		\tupItem{\\ cantAtrapados}{nat}%
		\tupItem{\\ itMismasSanc}{itLista(kSanc)}%
		\tupItem{\\ itConjMismasSanc}{itConj(agente)}%
	\end{Tupla}

	~

	\begin{Tupla}[As]
		\tupItem{agente}{nat}%
		\tupItem{datos}{puntero(datosAgente)}%
	\end{Tupla}

	~

	\begin{Tupla}[kSanc]
		\tupItem{sanc}{nat}
		\tupItem{agentes}{conj(agente)}
	\end{Tupla}

\end{Estructura}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\begin{enumerate}
	%done
	\item Las posiciones de todos los agentes son posiciones validas del campus.
	%done
	\item Las posiciones de los hippies son posiciones validas del campus.
	%done
	\item Las posiciones de los estudiantes son posiciones validas del campus.
	%done
	\item Las posiciones de los agentes son distintas a las posiciones de los hippies.
	%done
	\item Las posiciones de los estudiantes son distintas a las posiciones de los hippies.
	%done
	\item Las posiciones de los agentes son distintas a las posiciones de los estudiantes.
	%done
	\item El agente masVigilante esta definido en personalAs y tiene la mayor cantidad de sanciones.
	%done
	\item Para todo nombre que esta definido en el diccionario de hippies no puede estar definido en el diccionario de estudiantes y viceversa.
	%done
	\item La cantidad de elementos que tiene posicionesAgente, posicionesHippies y posicionesEstudiantes es la cantidad de coordenadas que tiene la grilla.
	%done
	\item Los agentes de posicionesAgente son los mismos que los de personalAs y viceversa.
	%done
	\item La posicion de todos los agentes de posicionesAgente se mapea con la posicion que tienen en personalAs y viceversa.
	%done
	\item Las posiciones en posicionesAgente que no tienen agente tienen un puntero a NULL.
	%done
	\item La dimension del campus es mayor que la cantidad de estudiantes, hippies, agentes y obstaculos .
	%done
	\item La longitud de listaMismasSanc es la cantidad de sanciones diferentes que hay.
	\item Para cada cantidad de sanciones distinta hay un nodo en listaMismasSanc con esa cantidad de sanciones.
	\item listaMismasSanc esta ordenada por cantidad de sanciones.
	\item En cada nodo de listaMismasSanc va a estar el conjunto de todos los agentes que tienen la cantidad de sanciones indicada en el nodo.
	\item Si mismasSancModificado es falso, vectorMismasSanc tiene misma cantidad de elementos que listaMismasSanc, y cada elemento apunta a un nodo de listaMismasSanc, respetando el orden de listaMismasSanc
	\item La posiciones de todos los hippies en posicionesHippies se mapea con la posicion que tienen en el diccString hippies y viceversa
	\item La posiciones de todos los estudiantes en posicionesEstudiantes se mapea con la posicion que tienen en el diccString estudiantes y viceversa
\end{enumerate}

\Rep[estr][e]{
	\\
	($\forall a$: nat)(def?($a$, $e$.personalAS) $\Rightarrow_L$ posValida(Obtener($a$,$e$.personalAS).posicion, e.campus) $\land$ $\neg$ocupada?(Obtener($a$,$e$.personalAS).posicion),e.campus)
	\\
	$\land$
	\\
	($\forall h$: string)(def?($h$, $e$.hippies) $\Rightarrow_L$ posValida(Obtener($h$,$e$.hippies), e.campus) $\land$ $\neg$ocupada?(Obtener($h$, $e$.hippies)),e.campus)
	\\
	$\land$
	\\
	($\forall est$: string)(def?($est$, $e$.estudiantes) $\Rightarrow_L$ posValida(Obtener($est$, $e$.estudiantes), e.campus) $\land$ $\neg$ocupada?(Obtener($est$, $e$.estudiantes)), e.campus)
	\\
	$\land$
	\\
	($\forall a$: nat)($\forall h$: string) def?($a$, $e$.personalAS) $\land$ def?($h$, $e$.hippies) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).posicion $\neq$ Obtener($h$, $e$.hippies)
	\\
	$\land$
	\\
	($\forall est$: string)($\forall h$: string) def?($est$,$e$.estudiantes) $\land$ def?($h$,$e$.hippies) $\Rightarrow_L$ Obtener($est$,$e$.estudiantes) $\neq$ Obtener($h$, $e$.hippies)
	\\
	$\land$
	\\
	($\forall a$: nat)($\forall est$: string) def?($a$, $e$.personalAS) $\land$ def?($est$, $e$.estudiantes) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).posicion $\neq$ Obtener($est$, $e$.estudiantes)
	\\
	$\land$
	\\
	def?(masVigilante.agente, $e$.personalAS) $\land_L$ Obtener(masVigilante.agente, $e$.personalAS) = *masVigilante.datos
	\\
	$\land$
	\\
	($\forall a$: nat) def?($a$, $e$.personalAS) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).cantSanc $\leq$ *masVigilante.datos.cantSanc 
	\\
	$\land$
	\\
	($\forall h$: string) def?($h$, $e$.hippies) $\Rightarrow$ $\neg$def?($h$, $e$.estudiantes)
	\\
	$\land$
	\\
	($\forall est$: string) def?($est$, $e$.estudiantes) $\Rightarrow$ $\neg$def?($est$, $e$.hippies)
	\\
	$\land$
	\\
	longitud($e$.posicionesAgente) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\
	longitud($e$.posicionesHippies) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\
	longitud($e$.posicionesEstudiantes) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\
	($\forall a$: nat) def?($a$, $e$.personalAS) $\Leftrightarrow_L$ ($\exists i$: nat) $i <$ longitud($e$.posicionesAgente) $\land_L$ $e$.posicionesAgente[$i$].agente = $a$ $\land$ *$e$.posicionesAgente[$i$].datos = Obtener($a$, $e$.personalAS) $\land$ ($i$ $/$ columnas($e$.campus)) = Obtener($a$, $e$.personalAS).posicion.y $\land$ ($i$ $mod$ columnas($e$.campus)) = Obtener($a$, $e$.personalAS).posicion.x
	\\
	$\land$
	\\
	($\forall i$: nat) $i <$ longitud($e$.posicionesAgente) $\Leftrightarrow_L$ *$e$.posicionesAgente[$i$].datos = NULL $\lor$ ($\exists! a$: nat) def?($a$, $e$.personalAS) $\land_L$ *$e$.posicionesAgente[$i$].datos = Obtener($a$, $e$.personalAS)
	\\
	$\land$
	\\
	$\#$claves($e$.personalAS) $+$ $\#$claves($e$.hippies) $+$ $\#$claves($e$.estudiantes) $+$ $\#$Obstaculos($e$.campus) $\leq$ filas($e$.campus)*columnas($e$.campus)
	
}\mbox{}
\\
	$\land$
	\\
	long($e$.listaMismasSanc) = $\#$SancionesDistintas($e$.personalAS)
	\\
	$\land$
	\\
	($\forall$ sanc : nat)(sanc $\in$ conjSanciones(claves($e$.personalAS), $e$.personalAS) $\Rightarrow$ ($\exists$ nodo : kSanc)(esta?(kSanc, $e$.listaMismasSanc) $\land$ kSanc.sanc = sanc))
	\\
	$\land$
	\\
	ordenada?($e$.listaMismasSanc)
	\\
	$\land$
	\\
	($\forall$ nodo : kSanc)(esta?(kSanc, $e$.listaMismasSanc) $\Rightarrow$ agentes(kSanc) $=_{obs}$ agentesKSanc($e$.personalAS, claves($e$.personalAS), sanc(kSanc)))
	\\
	$\land$
	\\
	$e$.mismasSancModificado $\Rightarrow$ (long($e$.listaMismasSanc) = long(vectorMismasSanc) $\land_L$ mismosNodos($e$.listaMismasSanc, $e$.vectorMismasSanc))
	\\
	$\land$
	\\
	($\forall$ h : string)(def?(h, $e$.hippies) $\Leftrightarrow_L$ ($\exists$ i : nat)(i < longitud($e$.posicionesHippies) $\land_L$ $e$.posicionesHippies[i] = obtener(h, $e$.hippies) $\land$ (i / columnas($e$.campus) = obtener(j, $e$.hippies).y) $\land$ (i mod columnas($e$.campus) = obtener(j, $e$.hippies).y)))
	\\
	$\land$
	\\
	($\forall$ h : string)(def?(h, $e$.estudiantes) $\Leftrightarrow_L$ ($\exists$ i : nat)(i < longitud($e$.posicionesEstudiantes) $\land_L$ $e$.posicionesEstudiantes[i] = obtener(h, $e$.estudiantes) $\land$ (i / columnas($e$.campus) = obtener(j, $e$.estudiantes).y) $\land$ (i mod columnas($e$.campus) = obtener(j, $e$.estudiantes).y)))
	\\
	\\
\tadOperacion{$\#$Obstaculos}{campus}{nat}{}
\tadOperacion{$\#$ObstaculosAux}{nat,nat,campus}{nat}{}
\tadOperacion{$\#$SancionesDistintas}{diccNat(agente, datosAgente)}{nat}{}
\tadOperacion{conjSanciones}{conj(nat), diccNat(agente,datosAgente)}{conj(nat)}{}
\tadOperacion{cantAgentes}{secu(kSanc)}{nat}{}
\tadOperacion{ordenada?}{secu(kSanc)}{bool}{}
\tadOperacion{agentesKSanc}{diccNat(agente, datosAgente), conj(agente), nat}{conj(agente)}{}
\tadOperacion{mismosNodos}{secu(kSanc)/lista, secu(puntero(kSanc))/vec}{bool}{long(lista) = long(vec)}

~

\tadAxioma{$\#$Obstaculos(c)}{
	$\#$ObstaculosAux(filas($c$)$-1$, columnas($c$)$-1$, $c$)
}
\tadAxioma{$\#$ObstaculosAux(f,col,c)}{
	\IF ($f=0 \land col=0$) THEN	$\beta$(ocupada?(<$f$,$col$>, $c$)
	ELSE{
		\IF ($f \neq 0 \land col = 0$) THEN $\#$ObstaculosAux($f-1$, columnas($c$)$-1$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
		ELSE{
			\IF ($f = 0 \land col \neq 0$) THEN $\#$ObstaculosAux(filas($c$),$col-1$,$c$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
			ELSE{
				$\#$ObstaculosAux($f-1$, $col-1$, $c$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
			}
			FI
		}
		FI
	}
	FI
}
\tadAxioma{$\#$SancionesDistintas(d)}{
	$\#$conjSanciones(Claves($d$),$d$)
}
\tadAxioma{conjSanciones(c,d)}{
	\IF $\neg\emptyset$($c$) THEN $\emptyset$
	ELSE{
		Ag(Obtener(DameUno($c$),$d$).cantSanc, conjSanciones(SinUno($c$,$d$)))
	}
	FI
}
\tadAxioma{cantAgentes(s)}{
	\IF $s = <>$ THEN 0
	ELSE {
		Long(prim($s$).vectorAgente) + cantAgentes(fin($s$))
	}
	FI
}
\tadAxioma{ordenada?(lista)}{
	\IF vacia?(lista) THEN true
	ELSE{
		\IF vacia?(fin(lista)) THEN true
		ELSE{
			\IF sanc(prim(lista)) < sanc(prim(fin(lista))) THEN ordenada?(fin(lista))
			ELSE false
			FI 
		}
		FI
	}
	FI
}
\tadAxioma{agentesKSanc(dicc, claves, k)}{
	\IF $\emptyset$?(claves) THEN $\emptyset$
	ELSE{
		\IF cantSanc(obtener(prim(claves), dicc)) = k THEN
			Ag(prim(claves), agentesKSanc(dicc, fin(claves), k))
		ELSE
			agentesKSanc(dicc, fin(claves), k)
		FI
	}
	FI
}
\tadAxioma{mismosNodos(lista, vec)}{
	\IF vacia?(lista) THEN true
	ELSE{
		\IF $\&prim(lista) = prim(vec)$ THEN 
			mismosNodos(fin(lista), fin(vec))
		ELSE
			false
		FI
	}
	FI
}

\pagebreak

\subsubsection{Función de Abstracción}
\Abs[estr]{campusSeguro}[e]{cs}{
$e$.campus $=$ campus($cs$) 
\\
$\land$
\\
$e$.estudiantes $=$ estudiantes($cs$)
\\
$\land$
\\
$e$.hippies $=$ hippies($cs$)
\\
$\land$
\\
$e$.personalAS $=$ agentes($cs$)
\\
$\land$
\\
($\forall a$: nat) (def?($a$, $e$.personalAS) $\Rightarrow_L$ posAgente($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).posicion $\land$ cantSanciones($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).cantSanc $\land$cantHippiesAtrapados($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).cantAtrapados)
\\
$\land$
\\
($\forall id$: string) (def?($id$, $e$.estudiantes) $\land_L$ Obtener($id$, $e$.estudiantes) = posEstudianteYHippie(cs)) $\lor$ (def?($id$, $e$.hippies) $\land_L$ Obtener($id$, $e$.hippies) = posEstudianteYHippie(cs))
}

\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{icomenzarRastrillaje}{\In{c}{campus}, \In{d}{diccNat(agente, datosAgente)}}{estr}' 

	res.campus $\leftarrow$ c '\ote{1}'
	res.listaMismasSanc $\leftarrow$ generarListaMismasSanc(d) '\ote{$N_a$}'
	res.personalAS $\leftarrow$ d '\ote{1}'
	res.posicionesAgente $\leftarrow$ vectorizarPos(d,filas(c),columnas(c)) '\ote{(f$*$c)$^2$ + $N_a$}'
	res.masVigilante $\leftarrow$ menorPlaca(d) '\ote{$N_a$}'
	res.mismasSancModificado $\leftarrow$ true '\ote{1}'
	res.hippies $\leftarrow$ Vacio() '\ote{1}'
	res.estudiantes $\leftarrow$ Vacio() '\ote{1}'

'\ofi{O(N_a) + O(N_a) + O((f*c)^2 + N_a) = O((f*c)^2 + N_a)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{vectorizarPos}{\In{d}{diccNat(agente, datosAgente)}, \In{f}{nat}, \In{c}{nat}}{vector(AS)}'
	res $\leftarrow$ Vacia() '\ote{1}'
	nat: i $\leftarrow$ 0 '\ote{1}'
	itDiccNat(agente, datosAgente): it $\leftarrow$ CrearIt(d) '\ote{1}'

	while i $<$ f$*$c do '\ote{1}'
		AgregarAtras(res, tupla(0,NULL)) '\ote{f$*$c}'
		i $\leftarrow$ i$+1$ '\ote{1}'
	end while '\ote{(f$*$c)$^2$}'
	
	while HaySiguiente(it) do '\ote{1}'
		res[Siguiente(it).significado.posicion.y $*$ c $+$ 
				Siguiente(it).significado.posicion.x] $\leftarrow$
			$\leftarrow$ tupla(Siguiente(it).clave, puntero(Siguiente(it).significado)) '\ote{1}'
	end while '\ote{$N_a$}'

'\ofi{O((f*c)^2 + N_a)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{menorPlaca}{\In{d}{diccNat(agente, datosAgente)}}{AS}'
	itDiccNat(agente, datosAgente): it $\leftarrow$ CrearIt(d) '\ote{1}'
	nat: placaMenor $\leftarrow$ Siguiente(it).clave '\ote{1}'
	puntero(datosAgente): punt $\leftarrow$ puntero(Siguiente(it).datosAgente '\ote{1}'
	while HaySiguiente(d) do '\ote{1}'
		if Siguiente(it).clave < placaMenor	then '\ote{1}'
			placaMenor $\leftarrow$ Siguiente(it).clave '\ote{1}'
			punt $\leftarrow$ puntero(Siguiente(it).datosAgente) '\ote{1}'
		end if '\ote{1}'
		Avanzar(it) '\ote{1}'
	end while '\ote{$N_a$}'
	
	res.agente $\leftarrow$ placaMenor '\ote{1}'
	res.datos $\leftarrow$ punt '\ote{1}'

'\ofi{O(N_a)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{generarListaMismasSanc}{\Inout{d}{diccNat(agente, datosAgente)}}{lista(kSanc)}'
	itDiccNat(agente, datosAgente): itDic $\leftarrow$ CrearIt(d) '\ote{1}'
	res $\leftarrow$ Vacia() '\ote{1}'
	AgregarAdelante(res, tupla(0,Vacio())) '\ote{1 (esta vacío el vector)}'
	itLista(kSanc): itL $\leftarrow$ CrearIt(res) '\ote{1}'

	while HaySiguiente(itDic) do '\ote{1}'
		itConj(agente): itC $\leftarrow$ AgregarRapido(res.agentes, Siguiente(itDic).clave) '\ote{1}'
		Siguiente(itDic).significado.itConjMismasSanc $\leftarrow$ itC '\ote{1}'
		Siguiente(itDic).significado.itMismasSanc $\leftarrow$ itL '\ote{1}'
		Avanzar(itDic) '\ote{1}'
	end while '\ote{$N_a$}'

'\ofi{O(N_a)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iIngresarEstudiante}{\In{e}{nombre}, \In{pos}{posicion}, \Inout{cs}{estr} } {}'
	if todasOcupadas?(vecinos(pos, $cs$.campus), $cs$ AND 
	AND AlMenosUnAgente(vecinos(pos, $cs$.campus) then '\ote{$|n_a|$}'
		conj(As): conjAgParaSanc $\leftarrow$ AgParaPremSanc(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
		SancionarAgentes(conjAgParaSanc, $cs$) '\ote{1}'
	end if '\ote{1}'

	if CantHippiesVecinos(vecinos(pos, $cs$.campus), $cs$)$< 2$  then '\ote{$|n_a|$}'
		Definir($cs$.estudiantes, e, pos) '\ote{$|n_a|$}'
	else
		Definir($cs$.hippies, e, pos) '\ote{$|n_a|$}'
	end if '\ote{$|n_a| + |n_a|$}'
	
	conj(nombre, posicion): conjHippiesRodEst $\leftarrow$ 
		$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$) '\ote{$|n_a|$}'

	if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'
		
		while HaySiguiente(itHEst) do '\ote{1}'
			Definir($cs$.estudiantes, Siguiente(itHEst).nombre, 
				Siguiente(itHEst).posicion) '\ote{$|n_a|$}'
			Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_a|$}'
			Avanzar(itHEst) '\ote{1}'
		end while '\ote{$2|n_a|$}'
	end if '\ote{$4 * 2|n_a|$}'

	conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
		$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) '\ote{1}'
	if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'	
		while HaySiguiente(itHAs) do '\ote{1}'
			Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_a|$}'
			Avanzar(itHAs) '\ote{1}'
		end while '\ote{$4|n_a|$}'
	end if '\ote{$4|n_a|$}'
	 

'\ofi{O(2|n_a|) + O(|n_a|) + O(4*2|n_a|) + O(4|n_a|) = O(15|n_a|) = O(|n_a|)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{SancionarAgentes}{\In{c}{conj(As)}, \Inout{cs}{estr}}{}'
	itConj(As): itC $\leftarrow$ CrearIt(c) '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		*Siguiente(itC).datos.cantSanccantSanc $\leftarrow$
			$\leftarrow$ *Siguiente(itC).datos.cantSanc$+1$ '\ote{1}'
		itLista(kSanc): itLis $\leftarrow$ *Siguiente(itC).datos.itMismasSanc'\ote{1}'

		if HaySiguiente(*Siguiente(itC).datos.itMismasSanc) then '\ote{1}'
			Avanzar(*Siguiente(itC).datos.itMismasSanc)
			if Siguiente(*Siguiente(itC).datos.itMismasSanc).sanc = 
			*Siguiente(itC).datos.cantSanc then '\ote{1}'
			else
				AgregarComoAnterior(*Siguiente(itC).datos.itMismasSanc,
					tupla(*Siguiente(itC).datos.cantSanc, Vacio())) '\ote{1}'
				Retroceder(*Siguiente(itC).datos.itMismasSanc) '\ote{1}'
			end if

		else
			AgregarComoSiguiente(*Siguiente(itC).datos.itMismasSanc,
				tupla(*Siguiente(itC).datos.cantSanc, Vacio()) '\ote{1}'
			Avanzar(*Siguiente(itC).datos.itMismasSanc) '\ote{1}'
		end if
		
		EliminarSiguiente(*Siguiente(itC).datos.itConjMismasSanc) '\ote{1}'
		*Siguiente(itC).datos.itConjMismasSanc $\leftarrow$
			$\leftarrow$ AgregarAdelante(*Siguiente(itC).datos.itMismasSanc.agentes, 
				*Siguiente(itC).agente) '\ote{1}'
	end while '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{HippiesRodeadosAs}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(nombre, posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		itDiccString(nombre, posicion) itDiccS $\leftarrow$ CrearIt($cs$.hippies) '\ote{1}'
		while HaySiguiente(itDiccS) AND Siguiente(itDiccS) $\neq$ Siguiente(itC) do '\ote{1}'
		Avanzar(itDiccS) '\ote{1}'
		end while '\ote{$|n_a|$}'

		if HaySiguiente(itDiccS) AND 
		todasOcupadas?(vecinos(Siguiente(itDiccS), $cs$.campus)) AND 
		AlMenosUnAgente(vecinos(Siguiente(itDiccS), $cs$.campus)) then '\ote{$|n_a|$}'
			AgregarRapido(res, tupla(DarClave(Siguiente(itDiccS)), 
				Siguiente(itDiccS)) '\ote{1}'

			conj(As): conjAgPremiar $\leftarrow$
			$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itDiccS), $cs$), $cs$) '\ote{1}'
			PremiarAgentes(conjAgPremiar, $cs$) '\ote{1}'

		end if '\ote{$|n_a|$}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{$4 * 2|n_a|$}'

'\ofi{O(4 * 2|n_a|) = O(|n_a|) \text{. La cantidad maxima del conjunto de posicion es 4.}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{AgParaPremSanc}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(As)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) + x].datos $\neq$ 
			$\neq$ NULL then '\ote{1}'
			AgregarRapido(res, 
				$cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) + x]) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) \ote{1}'
	end while '\ote{4}'

'\ofi{O(1) + O(1) + O(4) = O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{PremiarAgentes}{\In{c}{conj(As)}, \Inout{cs}{estr}}{}'
	itConj(As): itC $\leftarrow$ CrearIt(As) '\ote{1}'
	
	while HaySiguiente(itC) do '\ote{1}'
		*Siguiente(itC).datos.cantAtrapados $\leftarrow$
			$\leftarrow$ *Siguiente(itC).datos.cantAtrapados$+1$ '\ote{1}'
	end while '\ote{4}'

'\ofi{O(4) = O(1) \text{. La cantidad maxima de agentes va a ser 4.}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{CantHippiesVecinos}{\In{c}{conj(posicion)}, \In{cs}{estr}}{nat}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ $0$
	
	while HaySiguiente(itC) do '\ote{1}'
		itDiccString(nombre, posicion): itDic $\leftarrow$ CrearIt($cs$.hippies) '\ote{1}'
		
		while HaySiguiente(itDic) do '\ote{1}'
			if Siguiente(itDic) = Siguiente(itC) '\ote{1}'
				res $\leftarrow$ res$+1$ '\ote{1}'
			end if '\ote{1}'
		end while '\ote{$|n_a|$}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{$|n_a|$}'

'\ofi{O(|n_a|) \text{. Como vecinos como maximo tiene longitud 4, la complejidad sería } O(4*|n_a|) = O(|n_a|)}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{HippiesRodeadosEstudiantes}{\In{c}{conj(posicion}, \In{cs}{estr}}{conj(nombre, posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		itDiccString(nombre, posicion) itDiccS $\leftarrow$ CrearIt($cs$.hippies) '\ote{1}'

		while HaySiguiente(itDiccS) AND Siguiente(itDiccS) $\neq$ Siguiente(itC) do '\ote{1}'
		Avanzar(itDiccS) '\ote{1}'
		end while '\ote{$|n_a|$}'

		if HaySiguiente(itDiccS) AND 
		todasOcupadas?(vecinos(Siguiente(itDiccS), $cs$.campus)) AND 
		todosEstudiantes(vecinos(Siguiente(itDiccS), $cs$.campus)) then '\ote{$|n_a|$}'
			AgregarRapido(res, tupla(DarClave($cs$.hippies, Siguiente(itDiccS)), 
				Siguiente(itDiccS)) '\ote{1}'
		end if '\ote{$|n_a|$}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{$4|n_a|$}'

'\ofi{O(4|n_a|) = O(|n_a|) \text{. Como el conjunto c tiene como maximo longitud 4, la complejidad sería } O(|n_a|)}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{todasOcupadas?}{\In{c}{conj(posicion)}, \In{cs}{estr}}{bool}'
	res $\leftarrow$ false '\ote{1}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	
	while HaySiguiente(itC) do '\ote{1}'
		itDiccString(nombre, posicion): itHippies $\leftarrow$ CrearIt($cs$.hipies) '\ote{1}'
		while HaySiguiente(itHippies) AND Siguiente(itHippies) $\neq$ Siguiente(itC) '\ote{1}'
			Avanzar(itHippies) '\ote{1}'
		end while '\ote{$|n_a|$}'

		if HaySiguiente(itHippies) then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if '\ote{1}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{$4|n_a|$}'

	itC $\leftarrow$ CrearIt(c) '\ote{1}'
	while HaySiguiente(itC) do '\ote{1}'
		itDiccString(nombre, posicion): itEst $\leftarrow$ CrearIt($cs$.estudiantes) '\ote{1}'
		while HaySiguiente(itEst) AND Siguiente(itEst) $\neq$ Siguiente(itC) '\ote{1}'
			Avanzar(itEst) '\ote{1}'
		end while '\ote{$|n_a|$}'

		if HaySiguiente(itEst) then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if '\ote{1}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{$4|n_a|$}'

	itC $\leftarrow$ CrearIt(c) '\ote{1}'
	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) + x].datos $\neq$
		$\neq$ NULL then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if '\ote{1}'
	end while '\ote{4}'

	itC $\leftarrow$ CrearIt(c) '\ote{1}'
	while HaySiguiente(itC) do '\ote{1}'
		if Ocupada?($cs$.campus, Siguiente(itC)) '\ote{1}'
			res $\leftarrow$ true
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{4}'

'\ofi{O(4|n_a|) = O(|n_a|) \text{. Como el conjunto c tiene como maximo longitud 4, la complejidad sería } O(|n_a|)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{AlMenosUnAgente}{\In{c}{conj(posicion)}, \In{cs}{estr} }{bool}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ false '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) + x].datos $\neq$
		$\neq$ NULL then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if '\ote{1}'
	end while '\ote{4}'

'\ofi{O(4) = O(1) \text{. Como el conjunto c tiene maximo 4 posiciones, solo hace el ciclo 4 veces maximo.}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{TodosEstudiantes}{\In{c}{conj(posicion)}, \In{cs}{estr} }{bool}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c)
	res $\leftarrow$ true
	
	while HaySiguiente(itC) AND res = true do '\ote{1}'
		itDiccString(nombre, posicion): itEst $\leftarrow$ CrearIt($cs$.estudiantes) '\ote{1}'
		while HaySiguiente(itEst) AND Siguiente(itEst) $\neq$ Siguiente(itC) '\ote{1}'
			Avanzar(itEst) '\ote{1}'
		end while '\ote{$|n_a|$}'

		if HaySiguiente(itEst) = false then '\ote{1}'
			res $\leftarrow$ false '\ote{1}'
		end if '\ote{1}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{$4|n_a|$}'

'\ofi{O(4|n_a|) = O(|n_a|) \text{. Como el conjunto c tiene como maximo longitud 4, la complejidad sería } O(|n_a|)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iIngresarHippie}{\In{h}{nombre}, \In{pos}{posicion}, \Inout{cs}{estr} }{}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iMoverEstudiante}{\In{e}{nombre}, \In{d}{dirección}, \Inout{cs}{estr} }{}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iMoverHippie}{\In{h}{nombre}, \Inout{cs}{estr} }{}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iMoverAgente}{\In{a}{agente}, \Inout{cs}{estr} }{}'

	
'\ofi{}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iCampus}{\In{cs}{estr} }{campus}'
	$res$ $\leftarrow$ $cs$.campus'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iEstudiantes}{\In{cs}{estr} }{itDiccString(nombre,posición)}'
	$res$ $\leftarrow$ CrearIt($cs$.estudiantes)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iHippies}{\In{cs}{estr} }{itDiccString(nombre,posición)}'
	$res$ $\leftarrow$ CrearIt($cs$.hippies)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iAgentes}{\In{cs}{estr} }{itDiccNat(agente,datosAgente)}'
	$res$ $\leftarrow$ CrearIt($cs$.personalAS)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iPosEstudianteYHippie}{\In{id}{nombre}, \In{cs}{estr} }{posición}'
	if Definido?($id$, $cs$.hippies) then '\ote{$|n_m|$}'
		$res$ $\leftarrow$ Obtener($id$, $cs$.hippies)'\ote{$|n_m|$}'
	else
		$res$ $\leftarrow$ Obtener($id$, $cs$.estudiantes)'\ote{$|n_m|$}'
	end if
'\ofi{O(|n_m|) + O(|n_m|) = O(|n_m|)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iPosAgente}{\In{a}{agente}, \In{cs}{estr} }{posición}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).posicion '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iCantSanciones}{\In{a}{agente}, \In{cs}{estr} }{}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).cantSanc '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iCantHippiesAtrapados}{\In{a}{agente}, \In{cs}{estr} }{}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).cantAtrapados '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iConMismasSanciones}{\In{a}{agente}, \In{cs}{estr} }{lista(agente)}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).itMismasSanc.conjAgente '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iConKSanciones}{\In{k}{nat}, \In{cs}{estr} }{lista(agente)}'
	if $cs$.mismasSancModificado == true then '\ote{1}'
		hacerArregloMismasSanc($cs$) '\ote{$N_a$}'
		$cs$.mismasSancModificado $\leftarrow$ false
	end if
	
	nat: i $\leftarrow$ 0
	bool: esta $\leftarrow$ busqBinAgente($k$, i, $cs$.vectorMismasSanc) '\ote{$logN_a$}'
	if esta = true then '\ote{1}'
		res $\leftarrow$ *$cs$.vectorMismasSanc[i].agentes '\ote{1}'
	else
		res $\leftarrow$ Vacia() '\ote{1}'
	end if

'\ofi{\text{Si las sanciones no fueron modificadas: } O(N_a) \text{. Si no } O(logN_a)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{hacerArregloMismasSanc}{\Inout{cs}{estr}}{}'
	arreglo(puntero(kSanc)): arregloNuevo $\leftarrow$ CrearArreglo(Longitud($cs$.listaMismasSanc)) 
	'\ote{$N_a$}'
	itLista(kSanc): it $\leftarrow$ CrearIt($cs$.listaMismasSanc) '\ote{1}'
	nat: i $\leftarrow$ $0$ '\ote{1}'

	while HaySiguiente(it) do '\ote{1}'
		puntero(kSanc): p $\leftarrow$ puntero(Siguiente(it)) '\ote{1}'
		arregloNuevo[i] $\leftarrow$ p '\ote{1}'
		i $\leftarrow$ i $+1$ '\ote{1}'
		Avanzar(it) '\ote{1}'
	end while '\ote{$N_a$}'
	
	$cs$.arregloMismasSanc $\leftarrow$ arregloNuevo '\ote{1}'

'\ofi{O(N_a) + O(N_a) = O(N_a) \text{ Como máximo va a ser la cantidad de agentes la lista listaMismasSanc} }'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{busqBinAgente}{\In{k}{nat}, \Inout{i}{nat}, \In{v}{arreglo(puntero(kSanc))}}{bool}'
	nat: n $\leftarrow$ $0$ '\ote{1}'
	nat: m $\leftarrow$ Longitud(v) '\ote{1}'
	nat: med
	
	while n $\neq$ m$-1$ do '\ote{1}'
		med $\leftarrow$ $\frac{n+m}{2}$ '\ote{1}'
		if med $\leq$ k then '\ote{1}'
			n $\leftarrow$ med '\ote{1}'
		else
			m $\leftarrow$ med '\ote{1}'
		end if
	end while '\ote{$log(N_a)$}'

	if v[n] $=$ k then
		i $\leftarrow$ n
		$res$ $\leftarrow$ true
	else
		$res$ $\leftarrow$ false
	end if

'\ofi{O(logN_a)}'
\end{lstlisting}

