\section{Módulo CampusSeguro}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{CampusSeguro}.

\textbf{géneros}: \TipoVariable{campusSeguro}.

\subsubsection{Operaciones básicas de CampusSeguro}

\InterfazFuncion{comenzarRastrillaje}{\In{c}{campus}, \In{d}{diccNat(agente,datosAgente)}}{campusSeguro}
[($\forall a$ : agente) (def?($a$,$d$) $\Rightarrow_L$ (posVálida(obtener($a$,$d$)) $\land$ $\neg$ocupada?(obtener($a$,$d$,$c$))) $\land$ ($\forall a, a2$ : agente) ((def?($a$,$d$) $\land$ def?($a2$,$d$) $\land a \neq a2$) $\Rightarrow_L$ obtener($a$,$d$) $\neq$ obtener($a2$,$d$))]
{res $=_{obs}$ comenzarRastrillaje(c,d)}
[$O(f*c)^2 + N_a^2)$]
[Crea un nuevo campusSeguro tomando un campus y un diccionario con agentes.]
[Se genera aliasing campus y en el diccionario que se pasan por parametro.]

~

\InterfazFuncion{ingresarEstudiante}{\In{e}{nombre}, \In{p}{posición}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land e \not\in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)) $\land$ esIngreso?($p$,campus($cs$)) $\land$ $\neg$estaOcupada?($p$,$cs$)]
{$cs =_{obs}$ ingresarEstudiante($e$,$p$,$cs_o$)}
[$O(|n_m|)$]
[Ingresa un nuevo estudiante al campusSeguro]
[]

~

\InterfazFuncion{ingresarHippie}{\In{h}{nombre}, \In{p}{posición}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land h \not\in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)) $\land$ esIngreso?($p$,campus($cs$)) $\land$ $\neg$estaOcupada?($p$,$cs$)]
{$cs =_{obs}$ ingresarHippie($h$,$p$,$cs_o$)}
[$O(|n_m|)$]
[Ingresa un nuevo hippie el campusSeguro]
[]

~

\InterfazFuncion{moverEstudiante}{\In{e}{nombre}, \In{dir}{dirección}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land e \in$ estudiantes($cs$) $\land$ (seRetira($e$,$dir$,$cs$) $\lor$ \\
(posValida(proxPosicion(posEstudianteYHippie($e$,$cs$),$dir$,campus($cs$)), campus($cs$)) $\land$ $\neg$estaOcupada?(proxPosicion(posEstudianteYHippie($e$,$cs$),$dir$,campus($cs$)),$cs$)]
{$cs =_{obs}$ moverEstudiante($e$,$dir$,$cs_o$)}
[$O(|n_m|)$]
[Mueve un estudiante dentro del campus o lo hace salir y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{moverHippie}{\In{h}{nombre}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land h \in$ hippies($cs$) $\land$ $\neg$todasOcupadas?(vecinos(posEstudianteYHippie($h$,$cs$),campus($cs$)), $cs$)]
{$cs =_{obs}$ moverHippie($h$,$d$,$cs_o$}
[$O(|n_m|) + O(N_e)$]
[Mueve un hippie dentro del campus y se actualizan los atrapados, sanciones(si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{moverAgente}{\In{a}{agente}, \Inout{cs}{campusSeguro}}{}
[$cs =_{obs} cs_o \land a \in$ agentes($cs$) $\land_L$ cantSanciones($a$,$cs$) $\leq 3 \land$ \\
$\neg$todasOcupadas?(vecinos(posEstudianteYHippie($h$,$cs$),campus($cs$)),$cs$)]
{$cs =_{obs}$ moverAgente($a$,$cs_o$)}
[$O(|n_m|) + O(log(N_a)) + O(N_h)$]
[Mueve un agente dentro del campus y se actualizan los atrapados, sanciones (si es que las hay) y hippies atrapados (si es que los hay).]
[]

~

\InterfazFuncion{campus}{\In{cs}{campusSeguro}}{campus}
[true]
{$res =_{obs}$ campus($cs$)}
[$O(1)$]
[Devuelve el campus del campusSeguro.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{estudiantes}{\In{cs}{campusSeguro}}{itConj(tupla(nombre, posicion))}
[true]
{$res =_{obs}$ estudiantes($cs$)}
[$O(1)$]
[Devuelve el conjunto de los estudiantes que estan en el campus.]
[$res$ es un iterador no modificable.]

~

\InterfazFuncion{hippies}{\In{cs}{campusSeguro}}{itConj(tupla(nombre, posicion))}
[true]
{$res =_{obs}$ hippies($cs$)}
[$O(1)$]
[Devuelve el conjunto de los hippies que estan en el campus.]
[$res$ es un iterador no modificable.]

~

\InterfazFuncion{agentes}{\In{cs}{campusSeguro}}{itConj(tupla(agente,datosAgente))}
[true]
{$res =_{obs}$ agentes($cs$)}
[$O(1)$]
[Devuelve un iterador al diccionario de los agentes que estan en el campus.]
[$res$ es un interador no modificable.]

~

\InterfazFuncion{posEstudianteYHippie}{\In{id}{nombre}, \In{cs}{campusSeguro}}{posición}
[$id \in$ (estudiantes($cs$) $\bigcup$ hippies($cs$)]
{$res =_{obs}$ posEstudianteYHippie($id$,$cs$)}
[$O(|n_m|)$, donde $|m_n|$ es la longitud mas larga entre todos los nombres.]
[Devuelve la posicion del estudiante o hippie.]
[]

~

\InterfazFuncion{posAgente}{\In{a}{agente}, \In{cs}{campusSeguro}}{posición}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ posAgente($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la posicion del agente pasado como parametro.]
[]

~

\InterfazFuncion{cantSanciones}{\In{a}{agente}, \In{cs}{campusSeguro}}{nat}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ cantSanciones($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la cantidad de sanciones que posee el agente pasado como parametro.]
[]

~

\InterfazFuncion{cantHippiesAtrapados}{\In{a}{agente}, \In{cs}{campusSeguro}}{nat}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ cantHippiesAtrapados($a$,$cs$)}
[$O(1)$ en caso promedio.]
[Devuelve la cantidad de hippies que atrapo el agente pasado como parametro.]
[]

~

\InterfazFuncion{másVigilante}{\In{cs}{campusSeguro}}{agente}
[true]
{$res =_{obs}$ másVigilante($cs$)}
[$O(1)$]
[Devuelve la placa del agente que ha atrapado mas hippies.]
[]

~

\InterfazFuncion{conMismasSanciones}{\In{a}{agente}, \In{cs}{campusSeguro}}{conj(agentes)}
[$a \in$ agentes($cs$)]
{$res =_{obs}$ conMismasSanciones($a$,$cs$)}
[$O(1)$ en el caso promedio.]
[Devuelve el conjunto de los agentes que tienen el mismo numero de sanciones que el agente pasado como parametro.]
[$res$ es una referencia no modificable.]

~

\InterfazFuncion{conKSanciones}{\In{k}{nat}, \In{cs}{campusSeguro}}{conj(agentes)}
[true]
{$res =_{obs}$ conKSanciones($k$,$cs$)}
[$O(N_a)$ la primera vez que se la llama y $O(log(N_a))$ en futuras llamadas mientras no ocurran sanciones.]
[Devuelve el conjuto de agenes que tienen k sanciones.]
[$res$ es una referencia no modificable.]

~
\pagebreak

\subsubsection{Representación de campusSeguro}

\begin{Estructura}{campusSeguro}[estr]
	\begin{Tupla}[estr]
		\tupItem{campus}{campus}%
		\tupItem{\\ personalAS}{diccNat(agente,datosAgente)}%
		\tupItem{\\ agentesOrdenados}{vector(As)}
		\tupItem{\\ posicionesAgente}{vector(As)}%
		\tupItem{\\ masVigilante}{As}%
		\tupItem{\\ listaMismasSanc}{lista(kSanc)}%
		\tupItem{\\ arregloMismasSanc}{arreglo(itLista(kSanc))}
		\tupItem{\\ mismasSancModificado}{bool}
		\tupItem{\\ hippies}{dicString(nombre,posicion)}%
		\tupItem{\\ estudiantes}{dicString(nombre, posicion)}%
		\tupItem{\\ posicionesHippies}{vector(nombre)}
		\tupItem{\\ posicionesEstudiantes}{vector(nombre)}
	\end{Tupla}

	~

	\begin{Tupla}[datosAgente]
		\tupItem{posicion}{posicion}%
		\tupItem{\\ cantSanc}{nat}%
		\tupItem{\\ cantAtrapados}{nat}%
		\tupItem{\\ itMismasSanc}{itLista(kSanc)}%
		\tupItem{\\ itConjMismasSanc}{itConj(agente)}%
	\end{Tupla}

	~

	\begin{Tupla}[As]
		\tupItem{agente}{agente}%
		\tupItem{datos}{itDiccNat(agente,datosAgente)}%
	\end{Tupla}

	~

	\begin{Tupla}[kSanc]
		\tupItem{sanc}{nat}
		\tupItem{agentes}{conj(agente)}
	\end{Tupla}

\end{Estructura}

\subsubsection{Invariante de Representación}

\renewcommand{\labelenumi}{(\Roman{enumi})}

\begin{enumerate}
	%done nro1
	\item Las posiciones de todos los agentes son posiciones validas del campus.
	%done nro2
	\item Las posiciones de los hippies son posiciones validas del campus.
	%done nro3
	\item Las posiciones de los estudiantes son posiciones validas del campus.
	%done nro4
	\item Las posiciones de los agentes son distintas a las posiciones de los hippies.
	%done nro5
	\item Las posiciones de los estudiantes son distintas a las posiciones de los hippies.
	%done nro6
	\item Las posiciones de los agentes son distintas a las posiciones de los estudiantes.
	%done nro7
	\item El agente masVigilante esta definido en personalAs y tiene la mayor cantidad de sanciones.
	%done nro8
	\item Para todo nombre que esta definido en el diccionario de hippies no puede estar definido en el diccionario de estudiantes y viceversa.
	%done nro9
	\item La cantidad de elementos que tiene posicionesAgente, posicionesHippies y posicionesEstudiantes es la cantidad de coordenadas que tiene el campus.
	%done nro10
	\item Los agentes de posicionesAgente son los mismos que los de personalAs y viceversa.
	%done nro11
	\item La posicion de todos los agentes de posicionesAgente se mapea con la posicion que tienen en personalAs y viceversa.

	%DONE habia puntero, ahora hay iterador nro12
	\item Las posiciones en posicionesAgente que no tienen agente tienen un agente tienen un iterador en el que ver si hay siguiente da false.

	%done nro13
	\item La dimension del campus es mayor que la cantidad de estudiantes, hippies, agentes y obstaculos.
	%done nro14
	\item La longitud de listaMismasSanc es la cantidad de sanciones diferentes que hay.
	% nro15
	\item Para cada cantidad de sanciones distinta hay un nodo en listaMismasSanc con esa cantidad de sanciones.
	% nro16
	\item listaMismasSanc esta ordenada por cantidad de sanciones.
	% nro17
	\item En cada nodo de listaMismasSanc va a estar el conjunto de todos los agentes que tienen la cantidad de sanciones indicada en el nodo.

	%DONE nro18
	\item Cada agente que esta en personalAS esta en el conjunto de un nodo que tiene su misma cantidad de sanciones de la lista listaMismasSanciones y viceversa.

	%DONE nro19
	\item Cada agente de personalAS tiene un iterador valido, itMismasSanc, que apunta al nodo de la lista listaMismasSanc que tiene la misma cantidad de sanciones que ese agente, y otro iterador valido, itConjMismasSanc, que apunta si mismo en el conjunto agentes del nodo de listaMismasSanc que posee su misma cantidad de sanciones.
	%done nro20
	\item Si mismasSancModificado es falso, arregloMismasSanc tiene misma cantidad de elementos que listaMismasSanc, y cada elemento apunta a un nodo de listaMismasSanc, respetando el orden de listaMismasSanc.
	%done nro21
	\item Los hippies de posicionesHippies son los mismos que los del dicString hippies.
	%done nro22
	\item Las posiciones en posicionesHippies que no tienen un hippie poseen el caracter de espacio " ".
	%done nro23
	\item La posiciones de todos los hippies en posicionesHippies se mapea con la posicion que tienen en el diccString hippies y viceversa
	%done nro24
	\item Los estudiantes de posicionesEstudiantes son los mismos que los del dicString estudiantes.
	%done nro25
	\item Las posiciones en posicionesEstudiantes que no tienen un estudiante poseen el caracter de espacio " ".
	%done nro26
	\item La posiciones de todos los estudiantes en posicionesEstudiantes se mapea con la posicion que tienen en el diccString estudiantes y viceversa
	%done nro27
	\item agentesOrdenados tiene todas las claves de la tabla, el largo es igual a la cantidad de claves de personalAS y los iteradores van al significado de la clave correspondiente en la tabla
	%no28
	\item agentesOrdenados está ordenado por placa
\end{enumerate}

\pagebreak

\Rep[estr][e]{
	% nro1
	($\forall a$: nat)(def?($a$, $e$.personalAS) $\Rightarrow_L$ posValida(Obtener($a$,$e$.personalAS).posicion, e.campus) $\land$ $\neg$ocupada?(Obtener($a$,$e$.personalAS).posicion),e.campus)
	\\
	$\land$
	\\ %nro2
	($\forall h$: string)(def?($h$, $e$.hippies) $\Rightarrow_L$ posValida(Obtener($h$,$e$.hippies), e.campus) $\land$ $\neg$ocupada?(Obtener($h$, $e$.hippies)),e.campus)
	\\
	$\land$
	\\%nro3
	($\forall est$: string)(def?($est$, $e$.estudiantes) $\Rightarrow_L$ posValida(Obtener($est$, $e$.estudiantes), e.campus) $\land$ $\neg$ocupada?(Obtener($est$, $e$.estudiantes)), e.campus)
	\\
	$\land$
	\\%nro4
	($\forall a$: nat)($\forall h$: string) def?($a$, $e$.personalAS) $\land$ def?($h$, $e$.hippies) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).posicion $\neq$ Obtener($h$, $e$.hippies)
	\\
	$\land$
	\\%nro5
	($\forall est$: string)($\forall h$: string) def?($est$,$e$.estudiantes) $\land$ def?($h$,$e$.hippies) $\Rightarrow_L$ Obtener($est$,$e$.estudiantes) $\neq$ Obtener($h$, $e$.hippies)
	\\
	$\land$
	\\%nro6
	($\forall a$: nat)($\forall est$: string) def?($a$, $e$.personalAS) $\land$ def?($est$, $e$.estudiantes) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).posicion $\neq$ Obtener($est$, $e$.estudiantes)
	\\
	$\land$
	\\%nro7
	def?(masVigilante.agente, $e$.personalAS) $\land_L$ HaySiguiente(masVigilante.datos) $\land_L$ Obtener(masVigilante.agente, $e$.personalAS) = Siguiente(masVigilante.datos)
	\\
	$\land$
	\\%nro7 (2da parte)
	($\forall a$: nat)(def?($a$, $e$.personalAS) $\land$ HaySiguiente(masVigilante.datos)) $\Rightarrow_L$ Obtener($a$, $e$.personalAS).cantSanc $\leq$ Siguiente(masVigilante.datos).cantSanc
	\\
	$\land$
	\\%nro8
	($\forall h$: string) def?($h$, $e$.hippies) $\Rightarrow$ $\neg$def?($h$, $e$.estudiantes)
	\\
	$\land$
	\\%nro8 (2da parte)
	($\forall est$: string) def?($est$, $e$.estudiantes) $\Rightarrow$ $\neg$def?($est$, $e$.hippies)
	\\
	$\land$
	\\%nro9
	longitud($e$.posicionesAgente) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\%nro9 (2)
	longitud($e$.posicionesHippies) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\%nro9 (3)
	longitud($e$.posicionesEstudiantes) = filas($e$.campus)$*$columnas($e$.campus)
	\\
	$\land$
	\\%nro10 y nro11  fue modificado, habia punteros, ahora hay iterador
	($\forall a$: nat) def?($a$, $e$.personalAS) $\Leftrightarrow_L$ ($\exists i$: nat) $i <$ longitud($e$.posicionesAgente) $\land_L$ $e$.posicionesAgente[$i$].agente = $a$ $\land$ Siguiente($e$.posicionesAgente[$i$].datos) = Obtener($a$, $e$.personalAS) $\land$ ($i$ $/$ columnas($e$.campus)) = Obtener($a$, $e$.personalAS).posicion.y $\land$ ($i$ $mod$ columnas($e$.campus)) = Obtener($a$, $e$.personalAS).posicion.x
	\\
	$\land$
	\\%nro12  fue modificado, habia punteros, ahora hay iterador
	($\forall i$: nat) $i <$ longitud($e$.posicionesAgente) $\Leftrightarrow_L$ $\neg$HaySiguiente($e$.posicionesAgente[$i$].datos) $\lor$ ($\exists! a$: nat) def?($a$, $e$.personalAS) $\land_L$ Siguiente($e$.posicionesAgente[$i$].datos) = Obtener($a$, $e$.personalAS)
	\\
	$\land$
	\\%nro13
	$\#$claves($e$.personalAS) $+$ $\#$claves($e$.hippies) $+$ $\#$claves($e$.estudiantes) $+$ $\#$Obstaculos($e$.campus) $\leq$ filas($e$.campus)*columnas($e$.campus)
	\\
	$\land$
	\\%nro14
	long($e$.listaMismasSanc) = $\#$SancionesDistintas($e$.personalAS)
	\\
	$\land$
	\\%nro15
	($\forall$ sanc: nat)(sanc $\in$ conjSanciones(claves($e$.personalAS), $e$.personalAS) $\Rightarrow$ ($\exists$ nodo: kSanc)(esta?(nodo, $e$.listaMismasSanc) $\land$ nodo.sanc = sanc))
	\\
	$\land$
	\\%nro16
	ordenada?($e$.listaMismasSanc)
	\\
}\mbox{} %aca termina el scope del break, si no termina aca sigue por la eternidad en la misma pagina (no pasa a la siguiente)
	$\land$
	\\%nro17
	($\forall$ nodo: kSanc)(esta?(nodo, $e$.listaMismasSanc) $\Rightarrow_L$ agentes(nodo) $=$ agentesKSanc($e$.personalAS, claves($e$.personalAS), sanc(kSanc)))
	\\
	$\land$
	\\%nro18 + nro19
	($\forall$ $a$: nat)(def?$a$, $e$.personalAS) $\Rightarrow_L$ (HaySiguiente(Obtener($a$, $e$.personalAS).itMismasSanc) $\land_L$ Siguiente(Obtener($a$, $e$.personalAS).itMismasSanc).sanc = Obtener($a$, $e$.personalAS).cantSanc) $\land$ (HaySiguiente(Obtener($a$, $e$.personalAS).itConjMismasSanc) $\land_L$ Siguiente(Obtener($a$, $e$.personalAS).itConjMismasSanc) = $a$) $\land$ ($\exists!$ nodo: kSanc) (esta?(nodo, $e$.listaMismasSanc) $\land_L$ Siguiente(Obtener($a$, $e$.personalAS).itMismasSanc = nodo $\land$ Pertenece?(nodo,	Siguiente(Obtener($a$, $e$.personalAS).itConjMismasSanc)) = Pertenece?(nodo, a)
	\\
	$\land$
	\\%nro20
	$\neg$$e$.mismasSancModificado $\Rightarrow$ (long($e$.listaMismasSanc) = long(vectorMismasSanc) $\land_L$ mismosNodos($e$.listaMismasSanc, $e$.vectorMismasSanc))
	\\
	$\land$
	\\%nro21 + nro22
	($\forall$ i: nat)(i < longitud($e$.posicionesHippies) $\Leftrightarrow_L$ posicionesHippies[i] = " " $\lor$ ($\exists!$ h: string)(def?(h, $e$.hippies) $\land_L$ h = posicionesHippies[i]
	\\
	$\land$
	\\%nro23
	($\forall$ h: string)(def?(h, $e$.hippies) $\Leftrightarrow_L$ ($\exists!$ i: nat)(i < longitud($e$.posicionesHippies) $\land_L$ $e$.posicionesHippies[i] = obtener(h, $e$.hippies) $\land$ (i / columnas($e$.campus) = obtener(h, $e$.hippies).x) $\land$ (i mod columnas($e$.campus) = obtener(h, $e$.hippies).y)))
	\\
	$\land$
	\\%nro24 + nro25
	($\forall$ i: nat)(i < longitud($e$.posicionesEstudiantes) $\Leftrightarrow_L$ posicionesEstudiantes[i] = " " $\lor$ ($\exists!$ e: string)(def?(e, $e$.estudiantes) $\land_L$ e = posicionesEstudiantes[i]
	\\
	$\land$
	\\%nro26
	($\forall$ est: string)(def?(est, $e$.estudiantes) $\Leftrightarrow_L$ ($\exists!$ i: nat)(i < longitud($e$.posicionesEstudiantes) $\land_L$ $e$.posicionesEstudiantes[i] = Obtener(est, $e$.estudiantes) $\land$ (i / columnas($e$.campus) = Obtener(est, $e$.estudiantes).x) $\land$ (i mod columnas($e$.campus) = Obtener(est, $e$.estudiantes).y)))
	\\
	$\land$
	\\%nro27
	long(e.agentesOrdenados) $=$ cantClaves(e.personalAS) $\land$ ($\forall$ placa : agente)(definido?(placa, e.personalAS)
	\\$\Rightarrow_L$ ($\exists$ a : As)(placa $=_{obs}$ a.agente $\land$ obtener(placa, e.personalAS) $=_{obs}$ a.datos)
	\\
	$\land$
	\\%nro28
	ordenadoPorPlaca?(e.agentesOrdenados)
	\\
	\\

\tadOperacion{$\#$Obstaculos}{campus}{nat}{}
\tadOperacion{$\#$ObstaculosAux}{nat,nat,campus}{nat}{}
\tadOperacion{$\#$SancionesDistintas}{diccNat(agente, datosAgente)}{nat}{}
\tadOperacion{conjSanciones}{conj(nat), diccNat(agente,datosAgente)}{conj(nat)}{}
\tadOperacion{cantAgentes}{secu(kSanc)}{nat}{}
\tadOperacion{ordenada?}{secu(kSanc)}{bool}{}
\tadOperacion{agentesKSanc}{diccNat(agente, datosAgente), conj(agente), nat}{conj(agente)}{}
\tadOperacion{mismosNodos}{secu(kSanc)/lista, secu(itLista(kSanc))/vec}{bool}{long(lista) = long(vec)}
\tadOperacion{ordenadoPorPlaca?}{secu(As)}{bool}{}

~

\tadAxioma{$\#$Obstaculos(c)}{
	$\#$ObstaculosAux(filas($c$)$-1$, columnas($c$)$-1$, $c$)
}
\tadAxioma{$\#$ObstaculosAux(f,col,c)}{
	\IF ($f=0 \land col=0$) THEN	$\beta$(ocupada?(<$f$,$col$>, $c$)
	ELSE{
		\IF ($f \neq 0 \land col = 0$) THEN $\#$ObstaculosAux($f-1$, columnas($c$)$-1$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
		ELSE{
			\IF ($f = 0 \land col \neq 0$) THEN $\#$ObstaculosAux(filas($c$),$col-1$,$c$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
			ELSE{
				$\#$ObstaculosAux($f-1$, $col-1$, $c$) $+$ $\beta$(ocupada?(<$f$,$col$>, $c$)
			}
			FI
		}
		FI
	}
	FI
}
\tadAxioma{$\#$SancionesDistintas(d)}{
	$\#$conjSanciones(Claves($d$),$d$)
}
\tadAxioma{conjSanciones(c,d)}{
	\IF $\neg\emptyset$($c$) THEN $\emptyset$
	ELSE{
		Ag(Obtener(DameUno($c$),$d$).cantSanc, conjSanciones(SinUno($c$,$d$)))
	}
	FI
}
\tadAxioma{cantAgentes(s)}{
	\IF $s = <>$ THEN 0
	ELSE {
		Long(prim($s$).vectorAgente) + cantAgentes(fin($s$))
	}
	FI
}
\tadAxioma{ordenada?(lista)}{
	\IF vacia?(lista) THEN true
	ELSE{
		\IF vacia?(fin(lista)) THEN true
		ELSE{
			\IF sanc(prim(lista)) < sanc(prim(fin(lista))) THEN ordenada?(fin(lista))
			ELSE false
			FI
		}
		FI
	}
	FI
}
\tadAxioma{agentesKSanc(dicc, claves, k)}{
	\IF $\emptyset$?(claves) THEN $\emptyset$
	ELSE{
		\IF cantSanc(obtener(prim(claves), dicc)) = k THEN
			Ag(prim(claves), agentesKSanc(dicc, fin(claves), k))
		ELSE
			agentesKSanc(dicc, fin(claves), k)
		FI
	}
	FI
}
\tadAxioma{mismosNodos(lista, vec)}{
	\IF vacia?(lista) THEN true
	ELSE{
		\IF prim(lista) = Siguiente(prim(vec)) THEN
			mismosNodos(fin(lista), fin(vec))
		ELSE
			false
		FI
	}
	FI
}
\tadAxioma{ordenadoPorPlaca?(vec)}{
	\IF vacia?(vec) THEN true
	ELSE{
		\IF vacia?(fin(vec)) THEN true
		ELSE{
			\IF agente(prim(vec)) < agente(prim(fin(vec))) THEN ordenadoPorPlaca?(fin(vec))
			ELSE false
			FI
		}
		FI
	}
	FI
}

\subsubsection{Función de Abstracción}
\Abs[estr]{campusSeguro}[e]{cs}{
$e$.campus $=$ campus($cs$)
\\
$\land$
\\
$e$.estudiantes $=$ estudiantes($cs$)
\\
$\land$
\\
$e$.hippies $=$ hippies($cs$)
\\
$\land$
\\
$e$.personalAS $=$ agentes($cs$)
\\
$\land$
\\
($\forall a$: nat) (def?($a$, $e$.personalAS) $\Rightarrow_L$ posAgente($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).posicion $\land$ cantSanciones($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).cantSanc $\land$cantHippiesAtrapados($a$, $cs$) $=$ Obtener($a$, $e$.personalAS).cantAtrapados)
\\
$\land$
\\
($\forall id$: string) (def?($id$, $e$.estudiantes) $\land_L$ Obtener($id$, $e$.estudiantes) = posEstudianteYHippie(cs)) $\lor$ (def?($id$, $e$.hippies) $\land_L$ Obtener($id$, $e$.hippies) = posEstudianteYHippie(cs))
}

\pagebreak

\subsection{Algoritmos}

\lstset{style=alg}

\begin{lstlisting}[mathescape]
'\alg{icomenzarRastrillaje}{\In{c}{campus}, \In{d}{diccNat(agente, datosAgente)}}{estr}'

	res.campus $\leftarrow$ c $\textit{\textbf{(genera aliasing)}}$ '\ote{1}'
	res.listaMismasSanc $\leftarrow$ generarListaMismasSanc(d) $\textit{\textbf{(c1)}}$ '\ote{$N_a$}'
	res.personalAS $\leftarrow$ d $\textit{\textbf{(genera aliasing)}}$ '\ote{1}'
	res.posicionesAgente $\leftarrow$ vectorizarPos(d,filas(c),columnas(c)) $\textit{\textbf{(c2)}}$ '\ote{(f$*$c)$^2$ + $N_a$}'
	res.masVigilante $\leftarrow$ menorPlaca(d) $\textit{\textbf{(c3)}}$ '\ote{$N_a$}'
	res.mismasSancModificado $\leftarrow$ true '\ote{1}'
	res.hippies $\leftarrow$ Vacio() '\ote{1}'
	res.estudiantes $\leftarrow$ Vacio() '\ote{1}'
	res.posicionesHippies $\leftarrow$ Vacio() '\ote{1}'
	res.posicionesEstudiantes $\leftarrow$ Vacio() '\ote{1}'

	nat: i $\leftarrow$ 0 '\ote{1}'
	while i $<$ filas(c)*columnas(c) do '\ote{1}'
		AgregarAtras(res.posicionesHippies, " ") '\ote{k, siendo k la cantidad de elementos del vector}'
		AgregarAtras(res.posicionesEstudiantes, " ") '\ote{k, idem anterior}'
		i $\leftarrow$ i$+1$ '\ote{1}'
	end while $\textit{\textbf{(c4)}}$ '\ote{$\sum_{k=0}^{f*c - 1}(2k)$}'

	itDiccNat(agente, datosAgente) it $\leftarrow$ CrearIt(d) 					'\ote{1}'
	res.ordenadoPorPlaca $\leftarrow$ Vacia()									'\ote{1}'
	while HaySiguiente?(it) do 													'\ote{1}'
		i $\leftarrow$ 0														'\ote{1}'
		bool ordenado $\leftarrow$ true											'\ote{1}'
		while i < Longitud(res.ordenadoPorPlaca) $\land$ ordenado do			'\ote{1}'
			if res.ordenadoPorPlaca[i].agente > Siguiente(it).agente then		'\ote{1}'
				ordenado $\leftarrow$ false 									'\ote{1}'
			end if
		end while																'\ote{$N_a$}'
		Agregar(res.ordenadoPorPlaca, i, tupla(Siguiente(it).agente, it)) 		'\ote{$N_a$}'
	end while $\textit{\textbf{(c5)}}$											'\ote{$N_a^2$}'

'\ofi{O(N_a) + O(N_a) + O((f*c)^2 + N_a) + O(\sum_{k=0}^{f*c - 1}(2k)) + O(N_a^2) = max\{2O(N_a) , O((f*c)^2 + N_a)\} + O(2*(f*c-1)*(f*c)/2) + O(N_a^2) = O((f*c)^2 + N_a) + O(2*(f*c-1)*(f*c)/2) + O(N_a^2) < O((f*c)^2 + N_a) + O((f*c)^2) + O(N_a^2) = O((f*c)^2 + N_a^2)}'
\end{lstlisting}

\textbf{Justificación Complejidad:} \textit{\textbf{(c1)}} Complejidad de generarListaMismasSanc es $O(N_a)$. \\
\textit{\textbf{(c2)}} Complejidad de vectorizarPos es $O(f*c)^2 + N_a)$. \\
\textit{\textbf{(c3)}} Complejidad de menorPlaca es $O(N_a)$. \\
\textit{\textbf{(c4)}} AgregarAtras del vector cuesta $\Theta$($f$(long($v$) + copy(elemento)) entonces, por cada iteración hay un elemento más en el vector, esto genera que sea $\sum_{k=0}^{n}(2k)$lo que tarda en agregarse un elemento, siendo $0\leq n \leq f*c-1$. Por lo tanto, por todas las iteraciones tarda $O(\sum_{k=0}^{f*c - 1}(2k)) = O(2*(f*c-1)*(f*c)/2) < O((f*c)^2)$.\\
\textit{\textbf{(c5)}} Recorro todas las claves del diccionario, lo cual cuesta $O(N_a)$, y para cada una recorro el vector, que es lineal en la cantidad de elementos del vector, la cual va de 0 hasta la cantidad de agentes, y tambien se agrega en el vector hasta la posicion recorrida, esto cuesta $O(N_a)$. Finalmente, la complejidad es $O(N_a^2)$.

~

\InterfazFuncion{vectorizarPos}{\In{d}{diccNat(agente, datosAgente)}, \In{f}{nat}, \In{c}{nat}}{vector(As)}
[true]
{res va a ser el vector donde cada posicion va a matchear con una posicion del campus. Además, en cada posicion, va a haber un agente (si lo hay en el campus).}


\begin{lstlisting}[mathescape]
'\alg{vectorizarPos}{\In{d}{diccNat(agente, datosAgente)}, \In{f}{nat}, \In{c}{nat}}{vector(As)}'
	res $\leftarrow$ Vacio() '\ote{1}'
	nat: i $\leftarrow$ 0 '\ote{1}'
	itDiccNat(agente, datosAgente): it $\leftarrow$ CrearIt(d) '\ote{1}'

	vector(tupla(agente, datosAgente)) vVacio $\leftarrow$ Vacio() '\ote{1}'
	diccNat(agente, datosAgente) dVacio $\leftarrow$ crearDiccionario(vVacio) '\ote{1}'
	itDiccNat(agente, datosAgente): itVacio $\leftarrow$ CrearIt(dVacio) '\ote{1}'

	while i $<$ f$*$c do '\ote{1}'
		AgregarAtras(res, tupla(0,itVacio)) '\ote{k, siendo k la cantidad de elementos en el vector.}'
		i $\leftarrow$ i$+1$ '\ote{1}'
	end while $\textit{\textbf{(c1)}}$ '\ote{$\sum_{k=0}^{f*c - 1}(k))$}'

	while HaySiguiente(it) do '\ote{1}'
		itDiccNat(agente, datosAgente): itPos $\leftarrow$ it $\textbf{por copia}$ '\ote{1}'
		res[Siguiente(it).significado.posicion.y $*$ c $+$
				Siguiente(it).significado.posicion.x] $\leftarrow$
			$\leftarrow$ tupla(Siguiente(it).clave, itPos) '\ote{1}'
	end while $\textit{\textbf{(c2)}}$ '\ote{$N_a$}'

'\ofi{O(\sum_{k=0}^{f*c - 1}(k)) + N_a) = O((f*c-1)*(f*c)/2) + N_a) < O((f*c)^2 + N_a)}'
\end{lstlisting}

\textbf{Justificación Complejidad:} \textit{\textbf{(c1)}} AgregarAtras del vector cuesta $\Theta$($f$(long($v$) + copy(elemento)) entonces, por cada iteración hay un elemento más en el vector, esto genera que sea $\sum_{k=0}^{n}(k)$lo que tarda en agregarse un elemento, siendo $0\leq n \leq f*c-1$. Por lo tanto, por todas las iteraciones tarda $O(\sum_{k=0}^{f*c - 1}(k)) = O((f*c-1)*(f*c)/2) \leq O((f*c)^2)$. \\
\textit{\textbf{(c2)}} En cada iteración del iterador del diccionario de agentes me crea una copia del iterador (que tarda $O(1)$) y va agregando en el vector de posiciones en la posicion que corresponde al agente que apunta el iterador, con la copia del iterador en esa posición. Esto lo hace por todos los agentes por eso la complejidad de este ciclo es $O(N_a)$. \\
Como estos dos ciclos son los que predominan en complejidad (el resto de las funciones es $O(1)$) entonces la complejidad queda como $O((f*c)^2 + N_a)$.


~

\InterfazFuncion{menorPlaca}{\In{d}{diccNat(agente,datosAgente)}}{As}
[true]
{res $=_{obs}$ agenteDeMenorPlaca(d)}

\begin{lstlisting}[mathescape]
'\alg{menorPlaca}{\In{d}{diccNat(agente, datosAgente)}}{As}'
	itDiccNat(agente, datosAgente): it $\leftarrow$ CrearIt(d) '\ote{1}'
	nat: placaMenor $\leftarrow$ Siguiente(it).clave '\ote{1}'
	while HaySiguiente(d) do '\ote{1}'
		if Siguiente(it).clave < placaMenor	then '\ote{1}'
			placaMenor $\leftarrow$ Siguiente(it).clave '\ote{1}'
			itDiccNat(agente, datosAgente) itMenor $\leftarrow$ it $\textbf{por copia}$ '\ote{1}'
		end if '\ote{1}'
		Avanzar(it) '\ote{1}'
	end while $\textit{\textbf{(c1)}}$ '\ote{$N_a$}'

	res.agente $\leftarrow$ placaMenor '\ote{1}'
	res.datos $\leftarrow$ itMenor '\ote{1}'

'\ofi{O(N_a)}'
\end{lstlisting}

\textbf{Justificación Complejidad:} \textit{\textbf{(c1)}} Va iterando sobre todos los agentes y buscando el que tiene menor placa, cuando lo encuentra crea una copia del iterador que apunta a ese agente y de la placa. Como itera sobre todos los agentes para buscarlo toma $O(N_a)$.

~


\InterfazFuncion{generarListaMismasSanc}{\Inout{d}{diccNat(agente, datosAgente)}}{lista(kSanc)}
[true]
{res $=_{obs}$ generarListaMismasSanc $\land$ ($\forall$ a: nat)(def?(a,d) $\Rightarrow_L$ HaySiguiente(Obtener(a,d).itMismasSanc) $\land$ HaySiguiente(Obtener(a,d).itConjMismasSanc) $\land_L$ Siguiente(Obtener(a,d).itMismasSanc).sanc = Obtener(a,d).cantSanc $\land$ Pertenece(a,Siguiente(Obtener(a,d).itMismasSanc).agentes) $\land$ Siguiente(Obtener(a,d).itConjMismasSanc) = a}

\begin{lstlisting}[mathescape]
'\alg{generarListaMismasSanc}{\Inout{d}{diccNat(agente, datosAgente)}}{lista(kSanc)}'
	itDiccNat(agente, datosAgente): itDic $\leftarrow$ CrearIt(d) '\ote{1}'
	res $\leftarrow$ Vacia() '\ote{1}'
	AgregarAdelante(res, tupla(0,Vacio())) '\ote{1 (esta vacío el vector)}'
	itLista(kSanc): itL $\leftarrow$ CrearIt(res) '\ote{1}'

	while HaySiguiente(itDic) do '\ote{1}'
		itConj(agente): itC $\leftarrow$ AgregarRapido(res.agentes, Siguiente(itDic).clave) '\ote{1}'
		Siguiente(itDic).significado.itConjMismasSanc $\leftarrow$ itC '\ote{1}'
		Siguiente(itDic).significado.itMismasSanc $\leftarrow$ itL '\ote{1}'
		Avanzar(itDic) '\ote{1}'
	end while $\textit{\textbf{(c1)}}$ '\ote{$N_a$}'

'\ofi{O(N_a)}'
\end{lstlisting}

\textbf{Justificación Complejidad:} \textit{\textbf{(c1)}} Por cada agente, va agregandolo al conjunto de agentes que tiene el nodo de la lista y va agregando los iteradores correspondientes al agente. Como es por cada agente esto toma $O(N_a)$.

~


\begin{lstlisting}[mathescape]
'\alg{iIngresarEstudiante}{\In{e}{nombre}, \In{pos}{posicion}, \Inout{cs}{estr} } {}'
	if todasOcupadas?(vecinos(pos, $cs$.campus), $cs$) AND
	AND AlMenosUnAgente(vecinos(pos, $cs$.campus)) then $\textit{\textbf{(c1)}}$ '\ote{$2*4$}'
		conj(As): conjAgParaSanc $\leftarrow$
			$\leftarrow$ AgParaPremSanc(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c2)}}$ '\ote{4}'
		SancionarAgentes(conjAgParaSanc, $cs$) $\textit{\textbf{(c3)}}$ '\ote{4}'
	end if '\ote{$3*4$}'

	if CantHippiesVecinos(vecinos(pos, $cs$.campus), $cs$)$< 2$ $\textit{\textbf{(c4)}}$ then '\ote{$4*|n_m|$}'
		Definir($cs$.estudiantes, e, pos) '\ote{$|n_m|$}'
		$cs$.posicionesEstudiantes[pos.y * Columnas($cs$.campus) + pos.x] $\leftarrow$ e '\ote{1}'
	else
		Definir($cs$.hippies, e, pos) '\ote{$|n_m|$}'
		$cs$.posicionesHippies[pos.y * Columnas($cs$.campus) + pos.x] $\leftarrow$ e '\ote{1}'
	end if '\ote{$5*|n_m|$}'


	conj(nombre, posicion): conjHippiesRodEst $\leftarrow$
		$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c5)}}$ '\ote{4}'

	if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'
		while HaySiguiente(itHEst) do '\ote{1}'
			Definir($cs$.estudiantes, Siguiente(itHEst).nombre,
				Siguiente(itHEst).posicion) '\ote{$|n_m|$}'
			Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHEst).posicion.x] $\leftarrow$
			$\leftarrow$ $cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] '\ote{1}'

			$cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] $\leftarrow$ " " '\ote{1}'

			Avanzar(itHEst) '\ote{1}'
		end while $\textit{\textbf{(f1)}}$ '\ote{$4 * 2|n_m|$}'
	end if '\ote{$4 * 2|n_m|$}'


	//Las capturas se actualizan en HippiesRodeadosAs
	conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
		$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c6)}}$ '\ote{4}'

	if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'
		while HaySiguiente(itHAs) do '\ote{1}'
			Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itHAs).y*Columnas($cs$.campus) +
		+ Siguiente(itHAs).x] $\leftarrow$ " " '\ote{1}'
			Avanzar(itHAs) '\ote{1}'
		end while $\textit{\textbf{(f2)}}$ '\ote{$4*|n_m|$}'
	end if '\ote{$4*|n_m|$}'


	conj(nombre, posicion): conjEstRodHip $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosHippies(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c7)}}$ '\ote{4}'

	if Cardinal(conjEstRodHip) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itEstH $\leftarrow$ CrearIt(conjEstRodHip) '\ote{1}'
		while HaySiguiente(itEstH) do '\ote{1}'
			Eliminar($cs$.estudiantes, Siguiente(itEstH).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ " " '\ote{1}'

			Definir($cs$.hippies, Siguiente(itEstH).nombre,
				Siguiente(itEstH).posicion) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ Siguiente(itEstH).nombre '\ote{1}'

			Avanzar(itHAs) '\ote{1}'
		end while $\textit{\textbf{(f3)}}$ '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'


	conj(posicion): conjEstRodAs $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c8)}}$ '\ote{4}'

	if Cardinal(conjEstRodAs) $> 0$ then '\ote{1}'
		itConj(posicion): itEstAs $\leftarrow$ CrearIt(conjEstRodAs) '\ote{1}'

		while HaySiguiente(itEstAs) do '\ote{1}'
			if todasOcupadas?(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$ AND
			AND AlMenosUnAgente(vecinos(Siguiente(itEstAs), $cs$.campus) then $\textit{\textbf{(c9)}}$  '\ote{$2*4$}'
				conj(As): conjAgParaSanc $\leftarrow$
					$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itEstAs), $cs$.campus),
							$cs$) $\textit{\textbf{(c10)}}$ '\ote{4}'
				SancionarAgentes(conjAgParaSanc, $cs$) $\textit{\textbf{(c11)}}$ '\ote{4}'
			end if '\ote{1}'
		end while $\textit{\textbf{(f4)}}$ '\ote{$4*4*4$}'

	end if '\ote{$4*4*4$}'

'\ofi{O(3*4) + O(5*|n_m|) + O(4) + O(4*2|n_m|) + O(4*|n_m|) + O(4*2|n_m|) + O(4*4*4) = O(80) + O(25|n_m|) = O(1) + O(|n_m|) = O(|n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} \textit{\textbf{(c1)}} Las funciones todasOcupadas? y AlMenosUnAgente tienen como complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro. Como el conjunto que les estoy pasando solo tiene cuatro elementos (porque la función vecinos devuelve un conjunto de cuatro posiciones adyacentes) entonces la complejidad final de esa guarda es $O(2*4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c2)}} AgParaPremSanc idem que el anterior punto, la complejidad es $O(\#c)$ pero le estoy pasando un conjunto de 4 elementos la complejidad es $O(4)$ que es lo mismo que $O(1)$. \\
$\textit{\textbf{(c3)}}$ SancionarAgentes idem que el anterior, su complejidad es $O(\#c)$ pero como le paso un conjunto que como maximo tiene 4 elementos la complejidad es $O(4)$, o sea $O(1)$. \\
\textit{\textbf{(c4)}} CantHippiesVecinos tiene como complejidad $O(\#c + |n_m|)$ siendo $c$ el conjunto que se le pasa como parametro pero como le estoy pasando un conjunto que maximo tiene 4 elementos la complejidad termina siendo $O(4*|n_m|)$ que es lo mismo que $O(|n_m|)$. \\
\textit{\textbf{(c5)}} HippiesRodeadosEstudiantes tiene como complejidad $O(\#c)$ siendo $c$ el conjunto que se le pasa como parametro pero como le estoy pasando un conjunto que maximo tiene 4 elementos la complejidad termina siendo $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c6)}} HippiesRodeadosAs idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c7)}} EstudiantesRodeadosHippies idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c8)}} EstudiantesRodeadosAs idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c9)}} idem que el primer punto, todasOcupadas? y AlMenosUnAgente tienen complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro, pero como este conjunto tiene como maximo 4 elementos (porque vecinos devuelve un conjunto con maximo 4 elementos), las complejidades de ambas funciones es $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c10)}} AgParaPremSanc idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c11)}} SancionarAgentes idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(f1)}} El ciclo itera sobre el conjunto conjHippiesRodEst que tiene como máximo 4 elementos y dentro de él se define un estudiante ($O(|n_m|)$) y se elimina un hippie ($O(|n_m|)$), por lo tanto la complejidad del mismo es $O(4*2|n_m|)$ que es lo mismo que $O(|n_m|)$. \\
\textit{\textbf{(f2)}} Idem que el punto anterior, el conjunto conjHippiesRodAs tiene 4 elementos e itera sobre ellos, en este caso la complejidad queda $O(4*|n_m|)$ que es lo mismo que  $O(|n_m|)$. \\
\textit{\textbf{(f3)}} Idem que el punto anterior, el conjunto conjEstRodHip tiene 4 elementos e itera sobre ellos, en este caso la complejidad queda $O(4*2|n_m|)$ que es lo mismo que  $O(|n_m|)$. \\
\textit{\textbf{(f4)}} Idem que el anterior pero como las operaciones están acotadas a cuatro elementos la complejidad queda como $O(4*4*4)$ que es lo mismo que $O(1)$.

~


\InterfazFuncion{EstudiantesRodeadosAs}{\In{c}{conj(posición)}, \In{cs}{campusseguro}}{conj(posición)}
[true]
{res es el conjunto de posiciones en el cual hay estudiantes rodeados por As.}

\begin{lstlisting}[mathescape]
'\alg{EstudiantesRodeadosAs}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio()

	while HaySiguiente(itC) do '\ote{1}'
		if TodasOcupadas?(vecinos(Siguiente(itC), $cs$), $cs$) AND
		AND AlMenosUnAgente(vecinos(Siguiente(itC), $cs$), $cs$) then $\textit{\textbf{(c1)}}$ '\ote{$2*4$}'
		AgregarRapido(res, Siguiente(itC)) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{$(2*4)*\#c$}'

'\ofi{O((2*4)*\#c) = O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} \textit{\textbf{(c1)}} Las funciones todasOcupadas? y AlMenosUnAgente tienen como complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro. Como el conjunto que les estoy pasando solo tiene cuatro elementos (porque la función vecinos devuelve un conjunto de cuatro posiciones adyacentes) entonces la complejidad final de esa guarda es $O(2*4)$ que es lo mismo que $O(1)$. \\
La función va iterando por el conjunto de posiciones que se le pasa como parametro buscando los estudiantes rodeados por agentes. Como en el ciclo las complejidades son constantes la complejidad final da $O((2*4+8)*\#c)$ que es lo mismo que $O(\#c)$.


~


\InterfazFuncion{EstudiantesRodeadosHippies}{\In{c}{conj(posición)}, \In{cs}{campusseguro}}{conj(nombre, posición)}
[true]
{res es el conjunto que indica donde hay posiciones en las que haya estudiantes rodeados de hippies.}

\begin{lstlisting}[mathescape]
'\alg{EstudiantesRodeadosHippies}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(nombre, posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesEstudiantes[Siguiente(itC).y*Colummnas($cs$.campus) +
		+ Siguiente(itC).x] $\neq$ " " AND
		AND TodasOcupadas?(vecinos(Siguiente(itC), $cs$.campus), $cs$) AND
		AND HippiesAtrapando(vecinos(Siguiente(itC), $cs$.campus), $cs$) then $\textit{\textbf{(c1)}}$ '\ote{$2*4$}'
		AgregarRapido(res,
			tupla($cs$.posicionesEstudiantes[Siguiente(itC).y*Columnas($cs$.campus) +
			+ Siguiente(itC).x], Siguiente(itC)) '\ote{1}'

	end while '\ote{$(2*4)*\#c$}'

'\ofi{O((2*4*\#c)) = O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} \textit{\textbf{(c1)}} Las funciones todasOcupadas? y HippiesAtrapando tienen como complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro. Como el conjunto que les estoy pasando solo tiene cuatro elementos (porque la función vecinos devuelve un conjunto de cuatro posiciones adyacentes) entonces la complejidad final de esa guarda es $O(2*4)$ que es lo mismo que $O(1)$. \\
La función va iterando por el conjunto de posiciones que se le pasa como parametro buscando los estudiates rodeados por hippies. Como en el ciclo las complejidades son constantes la complejidad final da $O((2*4+8)*\#c)$ que es lo mismo que $O(\#c)$.


~


\InterfazFuncion{HippiesAtrapando}{\In{c}{conj(posición)}, \In{cs}{campusseguro}}{bool}
[true]
{res $=_{obs}$ HippiesAtrapando(c,cs)}

\begin{lstlisting}[mathescape]
'\alg{HippiesAtrapando}{\In{c}{conj(posicion)}, \In{cs}{estr}}{bool}'
	nat: i $\leftarrow$ 0 '\ote{1}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).x] $\neq$ " " then '\ote{1}'
			i $\leftarrow$ i$+1$ '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{$\#c$}'

	res $\leftarrow$ i $\geq 2$ '\ote{1}'

'\ofi{O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} La función itera sobre el conjunto de posiciones buscando si hay hippies en cada una de ellas. Como las operaciones son triviales, la complejidad final es la cantidad de elementos que tiene el conjunto pasado por parametro, o sea $O(\#c)$.

~


\InterfazFuncion{SancionarAgentes}{\In{c}{conj(As)}, \Inout{cs}{campusseguro}}{}
[true]
{Modifica los As pasados por parametro sumándoles uno al número de sanciones respectivo y actualiza las lista listaMismasSanc del campusSeguro}

\begin{lstlisting}[mathescape]
'\alg{SancionarAgentes}{\In{c}{conj(As)}, \Inout{cs}{estr}}{}'
	itConj(As): itC $\leftarrow$ CrearIt(c) '\ote{1}'

	if Cardinal(c) $>$ 0 then '\ote{1}'
		cs.mismasSancModificado $\leftarrow$ true '\ote{1}'
	end if

	while HaySiguiente(itC) do '\ote{1}'
		Siguiente(Siguiente(itC).datos).cantSanc $\leftarrow$
			$\leftarrow$ Siguiente(Siguiente(itC).datos).cantSanc$+1$ '\ote{1}'

			itLista(kSanc): itLis $\leftarrow$ Siguiente(Siguiente(itC).datos).itMismasSanc'\ote{1}'

		if HaySiguiente(Siguiente(Siguiente(itC).datos).itMismasSanc) then '\ote{1}'
			Avanzar(Siguiente(Siguiente(itC).datos).itMismasSanc)

			if Siguiente(Siguiente(Siguiente(itC).datos).itMismasSanc).sanc $\neq$
			$\neq$ Siguiente(Siguiente(itC).datos).cantSanc then '\ote{1}'
				AgregarComoAnterior(Siguiente(Siguiente(itC).datos).itMismasSanc,
					tupla(Siguiente(Siguiente(itC).datos).cantSanc, Vacio())) '\ote{1}'
				Retroceder(Siguiente(Siguiente(itC).datos).itMismasSanc) '\ote{1}'
			end if

		else
			AgregarComoSiguiente(Siguiente(Siguiente(itC).datos).itMismasSanc,
				tupla(Siguiente(Siguiente(itC).datos).cantSanc, Vacio()) '\ote{1}'
			Avanzar(Siguiente(Siguiente(itC).datos).itMismasSanc) '\ote{1}'
		end if

		EliminarSiguiente(Siguiente(Siguiente(itC).datos).itConjMismasSanc) '\ote{1}'
		Siguiente(Siguiente(itC).datos).itConjMismasSanc $\leftarrow$
			$\leftarrow$ AgregarAdelante(Siguiente(Siguiente(
				Siguiente(itC).datos).itMismasSanc).agentes,
					Siguiente(itC).agente) '\ote{1}'
	end while '\ote{$\#c$}'

'\ofi{O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} Itera una vez sobre el conjunto de agentes que toma como parametro sumandoles un uno en las sanciones de cada uno y reacomodandolos en la lista listaMismasSanc. Como todas las operaciones del ciclo tienen complejidad $O(1)$ la complejidad total es las veces que lo hace por cada elemento del conjunto. Por lo tanto, la complejidad es $O(\#c)$.

~


\InterfazFuncion{HippiesRodeadosAs}{\In{c}{conj(posición)}, \In{cs}{campusseguro}}{conj(nombre, posición}
[true]
{res $=_{obs}$ HippiesRodeadosAs(c,cs)}

\begin{lstlisting}[mathescape]
'\alg{HippiesRodeadosAs}{\In{c}{conj(posición)}, \In{cs}{estr}}{conj(nombre, posición)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).y] $\neq$ " "  AND
		todasOcupadas?(vecinos(Siguiente(itDiccS), $cs$.campus)) AND
		AlMenosUnAgente(vecinos(Siguiente(itDiccS), $cs$.campus)) then $\textit{\textbf{(c1)}}$ '\ote{$2 * 4$}'
			AgregarRapido(res,
			tupla($cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
			+ Siguiente(itC).x].agente,
				Siguiente(itC)) '\ote{1}'

			conj(As): conjAgPremiar $\leftarrow$
			$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itDiccS), $cs$), $cs$) $\textit{\textbf{(c2)}}$'\ote{4}'
			PremiarAgentes(conjAgPremiar, $cs$) $\textit{\textbf{(c3)}}$ '\ote{4}'

		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{$(2*4 + 8) * \#c$}'

'\ofi{O((2*4 + 8) * \#c) = O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} \textit{\textbf{(c1)}} Las funciones todasOcupadas? y AlMenosUnAgente tienen como complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro. Como el conjunto que les estoy pasando solo tiene cuatro elementos (porque la función vecinos devuelve un conjunto de cuatro posiciones adyacentes) entonces la complejidad final de esa guarda es $O(2*4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c2)}} AgParaPremSanc idem que lo anterior. \\
\textit{\textbf{(c3)}} PremiarAgentes tieme como complejidad $O(\#c)$ siendo $c$ el conjunto que se le pasa como parametro. El conjunto que le estoy pasando como parametro tiene como maximo cuatro elementos porque sale delconjunto que devuelve AgParaPremSanc que toma otro conjunto de cuatro elementos. Por ende, la complejidad en peor caso es de $O(4)$ que es lo mismo que $O(1)$. \\
La función va iterando por el conjunto de posiciones que se le pasa como parametro buscando los hippies rodeados por agentes. Como en el ciclo las complejidades son constantes la complejidad final da $O((2*4+8)*\#c)$ que es lo mismo que $O(\#c)$.

~


\InterfazFuncion{AgParaPremSanc}{\In{c}{conj(posición)}, \In{cs}{campusseguro}}{conj(As)}
[true]
{res va a a ser el conjunto de As tales que esten en alguna de las posiciones pasadas por parametro}

\begin{lstlisting}[mathescape]
'\alg{AgParaPremSanc}{\In{c}{conj(posicion)}, \In{cs}{estr}}{conj(As)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if HaySiguiente($cs$.posicionesAgente[Siguiente(itC).y *
			* Columnas($cs$.campus) + Siguiente(itC).x].datos) then '\ote{1}'
			AgregarRapido(res,
				$cs$.posicionesAgente[Siguiente(itC).y * Columnas($cs$.campus) +
				+ Siguiente(itC).x]) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{$\#c$}'

'\ofi{O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} Se itera sobre el conjunto de posiciones que se pasa como parametro una vez buscando las posiciones que tienen agente y se los va agregando, si los hay. Como se itera una vez y el resto toma $O(1)$ la complejidad de la función es $O(\#c)$.

~


\InterfazFuncion{PremiarAgentes}{\In{c}{conj(As)}, \Inout{cs}{campusseguro} }{}
[cs $=_{obs}$ cs$_o$]
{Se incrementa la cantidad de atrapados de todos los As pasados como parámetro}

\begin{lstlisting}[mathescape]
'\alg{PremiarAgentes}{\In{c}{conj(As)}, \Inout{cs}{estr}}{}'
	itConj(As): itC $\leftarrow$ CrearIt(As) '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		Siguiente(Siguiente(itC).datos).cantAtrapados $\leftarrow$
			$\leftarrow$ Siguiente(Siguiente(itC).datos).cantAtrapados$+1$ '\ote{1}'

		if Siguiente(cs.masVigilante.datos).cantAtrapados $<$
			$<$ Siguiente(itC).cantAtrapados then '\ote{1}'
			cs.masVigilante $\leftarrow$ Siguiente(itC) '\ote{1}'
		end if

		Avanzar(itC) '\ote{1}'
	end while '\ote{$\#c$}'

'\ofi{O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} La función itera sobre el conjunto de As que se le pasa por parametro y modifica todos los As sumandoles un uno en la cantidad de atrapados. Por ende, la complejidad de la función es la cantidad de agentes que tiene el conjunto, o sea $O(\#c)$.

~


\InterfazFuncion{CantHippiesVecinos}{\In{c}{conj(posición)}, \In{cs}{campusseguro}}{nat}
[true]
{res es igual a la cantidad de hippies que hay ocupando las posiciones pasadas por parametro}

\begin{lstlisting}[mathescape]
'\alg{CantHippiesVecinos}{\In{c}{conj(posicion)}, \In{cs}{estr}}{nat}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ $0$

	while HaySiguiente(itC) do '\ote{1}'
		itDiccString(nombre, posicion): itDic $\leftarrow$ CrearIt($cs$.hippies) '\ote{1}'

		while HaySiguiente(itDic) do '\ote{1}'
			if Siguiente(itDic) = Siguiente(itC) '\ote{1}'
				res $\leftarrow$ res$+1$ '\ote{1}'
			end if '\ote{1}'
			Avanzar(itDic) '\ote{1}'
		end while '\ote{$|n_m|$}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{$\#c * |n_m|$}'

'\ofi{O(\#c * |n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} Itera sobre el conjunto de posiciones que se pasa por parametro y se fija por cada una de ellas si esta en el diccString. Por lo tanto la complejidad es la cantidad de elementos del conjunto por la longitud de la palabra mas larga, $O(\#c * |n_m|)$.

~


\InterfazFuncion{HippiesRodeadosEstudiantes}{\In{c}{conj(posición)}, \In{cs}{campusseguro}}{conj(nombre, posición)}
[true]
{$res$ es igual a un conjunto de tuplas que contienen el nombre y posicion de los hippies de $c$ que hayan sido rodeados por estudiantes}

\begin{lstlisting}[mathescape]
'\alg{HippiesRodeadosEstudiantes}{\In{c}{conj(posición)}, \In{cs}{estr}}{conj(nombre, posición)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if $cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).x] $\neq$ " "  AND
		todasOcupadas?(vecinos(Siguiente(itC), $cs$.campus)) AND
		TodosEstudiantes(vecinos(Siguiente(itC), $cs$.campus)) then $\textit{\textbf{(c1)}}$ '\ote{4*2}'
			AgregarRapido(res,
				tupla($cs$.posicionesHippies[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).x], Siguiente(itC)) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while '\ote{$4 * 2 * \#c$}'

'\ofi{O(4 * 2 * \#c) = O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} \textit{\textbf{(c1)}} Las funciones todasOcupadas? y TodosEstudiantes tienen como complejidad $O(\#c)$ siendo $c$ el conjunto que le paso como parametro pero como les estoy pasando un conjunto de exactamente 4 elementos (vecinos me devuelve el conjunto que tiene las cuatro posiciones contiguas a la que le estoy pasando) la complejidad termina siendo $O(4)$ por cada función. \\
En la función va iterando cada posición del conjunto que se le pasa como parametro y va buscando si hay hippies atrapados. Como por cada ciclo se llama a todasOcupadas? y TodosEstudiantes la complejidad termina siendo $O(4 * 2 * \#c)$ que es lo mismo que $O(\#c)$.

~


\InterfazFuncion{todasOcupadas?}{\In{c}{conj(posición)}, \In{cs}{campusseguro} }{bool}
[true]
{res $=_{obs}$ ($\exists$ p: posicion) Pertenece?(p,c) $\land$ (($\exists$ a: nat) def?(a, agentes(cs)) $\land_L$ Obtener(a, agentes(cs)).posición $=$ p) $\lor$ (($\exists$ h: string) def?(h, hippies(cs)) $\land_L$ Obtener(h, hippies(cs)) $=$ p) $\lor$ (($\exists$ e: string) def?(e, estudiantes(cs)) $\land_L$ Obtener(e, estudiantes(cs)) $=$ p) $\lor$ Ocupada?(campus(cs),p)}

\begin{lstlisting}[mathescape]
'\alg{todasOcupadas?}{\In{c}{conj(posicion)}, \In{cs}{estr}}{bool}'
	res $\leftarrow$ false '\ote{1}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'

	while HaySiguiente(itC) AND $\neg$ res do '\ote{1}'
		if $cs$.posicionesHippies[Siguiente(itC)*Columnas($cs$.campus) +
		+ Siguiente(itC).y] $\neq$ " " then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if

		if $cs$.posicionesEstudiantes[Siguiente(itC)*Columnas($cs$.campus) +
		+ Siguiente(itC).y] $\neq$ " " then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if
		Avanzar(itC) '\ote{1}'
	end while $\textit{\textbf{(c1)}}$ '\ote{$\#c$}'

	itC $\leftarrow$ CrearIt(c) '\ote{1}'
	while HaySiguiente(itC) AND $\neg$res do '\ote{1}'
		if HaySiguiente($cs$.posicionesAgente[Siguiente(itC).y *
			* Columnas($cs$.campus) + x].datos) then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if '\ote{1}'
	end while $\textit{\textbf{(c2)}}$ '\ote{$\#c$}'

	itC $\leftarrow$ CrearIt(c) '\ote{1}'
	while HaySiguiente(itC) AND $\neg$res do '\ote{1}'
		if Ocupada?($cs$.campus, Siguiente(itC)) '\ote{1}'
			res $\leftarrow$ true
		end if '\ote{1}'
		Avanzar(itC) '\ote{1}'
	end while $\textit{\textbf{(c3)}}$ '\ote{$\#c$}'

'\ofi{O(\#c)}'
\end{lstlisting}

\textbf{Justificación de Complejidad:} $\textit{\textbf{(c1)}}$ $\textit{\textbf{(c2)}}$ $\textit{\textbf{(c3)}}$ En cada ciclo itera sobre la cantidad de elementos del conjunto fijandose si hay un elemento en cada una de las posiciones que tiene el conjunto. Por ende la complejidad es $O(\#c)$.

~


\InterfazFuncion{AlMenosUnAgente}{\In{c}{conj(posición)}, \In{cs}{campusseguro} }{bool}
[true]
{res $=_{obs}$ ($\exists$ p: posición) Pertenece?(p,c) $\land$ (($\exists$ a: nat) def?(a, agentes(cs)) $\land_L$ Obtener(a, agentes(cs)).posición = p)}

\begin{lstlisting}[mathescape]
'\alg{AlMenosUnAgente}{\In{c}{conj(posicion)}, \In{cs}{estr} }{bool}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ false '\ote{1}'

	while HaySiguiente(itC) AND $\neg$res do '\ote{1}'
		if HaySiguiente($cs$.posicionesAgente[Siguiente(itC).y *
			* Columnas($cs$.campus) + x].datos)	then '\ote{1}'
			res $\leftarrow$ true '\ote{1}'
		end if '\ote{1}'
	end while  '\ote{$\#c$}'

'\ofi{O(\#c)}'
\end{lstlisting}

\textbf{Justificación de Complejidad:} Revisa en cada posición del conjunto que se pasa por parametro si alguna tiene un agente. Como lo itera hasta que encuentra una posición en que haya agente puede que no haya o sea el ultimo elemento y da como peor caso que lo tenga que iterar todo. Por lo tanto, la complejidad es $O(\#c)$.

~


\InterfazFuncion{TodosEstudiantes}{\In{c}{conj(posición)}, \In{cs}{campusseguro}}{bool}
[true]
{res $=_{obs}$ ($\forall$ p: posición) Pertenece?(p,c) $\Rightarrow$ ($\exists!$ e: string) def?(e, estudiantes(cs)) $\land_L$ Obtener(e, estudiantes(cs)) $=$ p}

\begin{lstlisting}[mathescape]
'\alg{TodosEstudiantes}{\In{c}{conj(posicion)}, \In{cs}{estr} }{bool}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ true '\ote{1}'

	while HaySiguiente(itC) AND res do '\ote{1}'
		if $cs$.posicionesEstudiantes[Siguiente(itC).y*Columnas($cs$.campus) +
		+ Siguiente(itC).x] $=$ " " then '\ote{1}'
			res $\leftarrow$ false '\ote{1}'
		end if '\ote{1}'

		Avanzar(itC) '\ote{1}'
	end while '\ote{$\#c$}'

'\ofi{O(\#c)}'
\end{lstlisting}

\textbf{Justificación de Complejidad:} Itera una vez el conjunto buscando si las posiciones que hay en él pertenecen a un estudiante. Como las operaciones del interior del ciclo son triviales la complejidad esta dada por la cantidad de posiciones que tiene el conjunto que se esta iterando. Por lo tanto, la complejidad es $O(\#c)$.

~

\begin{lstlisting}[mathescape]
'\alg{iIngresarHippie}{\In{h}{nombre}, \In{pos}{posicion}, \Inout{cs}{estr} }{}'
	if todasOcupadas?(vecinos(pos, $cs$.campus), $cs$) AND
	AND AlMenosUnAgente(vecinos(pos, $cs$.campus)) then $\textit{\textbf{(c1)}}$ '\ote{$2*4$}'
		conj(As): conjAgParaPrem $\leftarrow$ AgParaPremSanc(vecinos(pos, $cs$.campus),
			$cs$) $\textit{\textbf{(c2)}}$ '\ote{4}'
		PremiarAgentes(conjAgParaPrem, $cs$) $\textit{\textbf{(c3)}}$ '\ote{4}'
	else if todasOcuapadas?(vecinos(pos, $cs$.campus), $cs$) AND
	AND TodosEstudiantes(vecinos(pos, $cs$.campus), $cs$) then $\textit{\textbf{(c4)}}$ '\ote{$2*4$}'
		Definir($cs$.estudiantes, h, pos) '\ote{$|n_m|$}'
		$cs$.posicionesEstudiantes[pos.y*Columnas($cs$.campus) + pos.x] $\leftarrow$ h
	else
		Definir($cs$.hippies, h, pos) '\ote{$|n_m|$}'
		$cs$.posicionesHippies[pos.y*Columnas($cs$.campus) + pos.x] $\leftarrow$ h
	end if '\ote{$2*4 + |n_m|$}'


	conj(nombre, posicion): conjHippiesRodEst $\leftarrow$
		$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$ )$\textit{\textbf{(c5)}}$ '\ote{4}'

	if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'
		while HaySiguiente(itHEst) do '\ote{1}'
			Definir($cs$.estudiantes, Siguiente(itHEst).nombre,
				Siguiente(itHEst).posicion) '\ote{$|n_m|$}'
			Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHEst).posicion.x] $\leftarrow$
			$\leftarrow$ $cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] '\ote{1}'

			$cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] $\leftarrow$ " " '\ote{1}'

			Avanzar(itHEst) '\ote{1}'
		end while $\textit{\textbf{(f1)}}$ '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'


	//Las capturas se actualizan en HippiesRodeadosAs
	conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
		$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c6)}}$ '\ote{4}'

	if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'
		while HaySiguiente(itHAs) do '\ote{1}'
			Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itHAs).y*Columnas($cs$.campus) +
		+ Siguiente(itHAs).x] $\leftarrow$ " " '\ote{1}'
			Avanzar(itHAs) '\ote{1}'
		end while $\textit{\textbf{(f2)}}$ '\ote{$4|n_m|$}'
	end if '\ote{$4|n_m|$}'


	conj(nombre, posicion): conjEstRodHip $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosHippies(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c7)}}$ '\ote{4}'

	if Cardinal(conjEstRodHip) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itEstH $\leftarrow$ CrearIt(conjEstRodHip) '\ote{1}'
		while HaySiguiente(itEstH) do '\ote{1}'
			Eliminar($cs$.estudiantes, Siguiente(itEstH).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ " " '\ote{1}'

			Definir($cs$.hippies, Siguiente(itEstH).nombre,
				Siguiente(itEstH).posicion) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ Siguiente(itEstH).nombre '\ote{1}'

			Avanzar(itHAs) '\ote{1}'
		end while $\textit{\textbf{(f3)}}$ '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'


	conj(posicion): conjEstRodAs $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c8)}}$ '\ote{4}'

	if Cardinal(conjEstRodAs) $> 0$ then '\ote{1}'
		itConj(posicion): itEstAs $\leftarrow$ CrearIt(conjEstRodAs) '\ote{1}'

		while HaySiguiente(itEstAs) do '\ote{1}'
			if todasOcupadas?(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$ AND
			AND AlMenosUnAgente(vecinos(Siguiente(itEstAs), $cs$.campus) then $\textit{\textbf{(c9)}}$ '\ote{$2*4$}'
				conj(As): conjAgParaSanc $\leftarrow$
					$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itEstAs), $cs$.campus),
						$cs$) $\textit{\textbf{(c10)}}$ '\ote{4}'
				SancionarAgentes(conjAgParaSanc, $cs$) $\textit{\textbf{(c11)}}$ '\ote{4}'
			end if '\ote{1}'
		end while $\textit{\textbf{(f4)}}$ '\ote{$4*4*4$}'

	end if '\ote{$4*4*4$}'

'\ofi{O(2*4 + |n_m|) + O(4*2*|n_m|) + O(4*|n_m|) + O(4*2|n_m|) + O(4*4*4) = O(8) + O(21|n_m|) = O(1) + O(|n_m|) = O(|n_m|)}'
\end{lstlisting}

\textbf{Justificación de Complejidad:} \textit{\textbf{(c1)}} Las funciones todasOcupadas? y AlMenosUnAgente tienen como complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro. Como el conjunto que les estoy pasando solo tiene cuatro elementos (porque la función vecinos devuelve un conjunto de cuatro posiciones adyacentes) entonces la complejidad final de esa guarda es $O(2*4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c2)}} AgParaPremSanc idem que el anterior punto, la complejidad es $O(\#c)$ pero le estoy pasando un conjunto de maximo 4  elementos la complejidad es $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c3)}} PremiarAgentes idem que el anterior punto, la complejidad es $O(\#c)$ pero le estoy pasando un conjunto de maximo 4 elementos la complejidad es $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c4)}} todasOcupadas? y TodosEstudiantes es lo mismo que el primer item, tienen ambas complejidad $O(\#c)$ pero se les pasa de parametro un conjunto de 4 elementos por ende su complejidad termina siendo $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c5)}} HippiesRodeadosEstudiantes tiene como complejidad $O(\#c)$ siendo $c$ el conjunto que se le pasa como parametro pero como le estoy pasando un conjunto que maximo tiene 4 elementos la complejidad termina siendo $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c6)}} HippiesRodeadosAs idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c7)}} EstudiantesRodeadosHippies idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c8)}} EstudiantesRodeadosAs idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c9)}} idem que el primer punto, todasOcupadas? y AlMenosUnAgente tienen complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro, pero como este conjunto tiene como maximo 4 elementos (porque vecinos devuelve un conjunto con maximo 4 elementos), las complejidades de ambas funciones es $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c10)}} AgParaPremSanc idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c11)}} SancionarAgentes idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(f1)}} El ciclo itera sobre el conjunto conjHippiesRodEst que tiene como máximo 4 elementos y dentro de él se define un estudiante ($O(|n_m|)$) y se elimina un hippie ($O(|n_m|)$), por lo tanto la complejidad del mismo es $O(4*2|n_m|)$ que es lo mismo que $O(|n_m|)$. \\
\textit{\textbf{(f2)}} Idem que el punto anterior, el conjunto conjHippiesRodAs tiene 4 elementos e itera sobre ellos, en este caso la complejidad queda $O(4*|n_m|)$ que es lo mismo que  $O(|n_m|)$. \\
\textit{\textbf{(f3)}} Idem que el punto anterior, el conjunto conjEstRodHip tiene 4 elementos e itera sobre ellos, en este caso la complejidad queda $O(4*2|n_m|)$ que es lo mismo que  $O(|n_m|)$. \\
\textit{\textbf{(f4)}} Idem que el anterior pero como las operaciones están acotadas a cuatro elementos la complejidad queda como $O(4*4*4)$ que es lo mismo que $O(1)$.

~


\begin{lstlisting}[mathescape]
'\alg{iMoverEstudiante}{\In{e}{nombre}, \In{d}{dirección}, \Inout{cs}{estr} }{}'

	Posicion: actualPos $\leftarrow$ Obtener(cs.estudiantes,e) '\ote{$|n_m|$}'
	Posicion: pos $\leftarrow$ actualPos '\ote{1}'
	if(d=Izquierda) then '\ote{1}'
		pos.x $\leftarrow$ pos.x - 1 '\ote{1}'
	else if (d=derecha) then '\ote{1}'
		pos.x $\leftarrow$ pos.x + 1 '\ote{1}'
	else if (d=Arriba) then '\ote{1}'
		pos.y $\leftarrow$ pos.y + 1 '\ote{1}'
 	else if (d=Abajo) then '\ote{1}'
 		pos.y $\leftarrow$ pos.y - 1 '\ote{1}'
 	end if

 	if(not (pos.y = 0 OR pos.y = cd.campus.filas$+1$)) then '\ote{1}'
		if CantHippiesVecinos(vecinos(pos, $cs$.campus), $cs$)$< 2$  then $\textit{\textbf{(c1)}}$ '\ote{$4*|n_m|$}'
			Definir($cs$.estudiantes, e, pos) '\ote{$|n_m|$}'
			$cs$.posicionesEstudiantes[actualPos.y * Columnas($cs$.campus)
				+ actualPos.x] $\leftarrow$ "" '\ote{1}'
			$cs$.posicionesEstudiantes[pos.y * Columnas($cs$.campus) + pos.x] $\leftarrow$ e '\ote{1}'
		else
			Definir($cs$.hippies, e, pos) '\ote{$|n_m|$}'
			$cs$.posicionesHippies[pos.y * Columnas($cs$.campus) + pos.x] $\leftarrow$ e '\ote{1}'
			$cs$.posicionesEstudiantes[actualPos.y * Columnas($cs$.campus)
				+ actualPos.x] $\leftarrow$ "" '\ote{1}'
			Borrar(cs.estudiantes,e) '\ote{$|n_m|$}'
		end if '\ote{$4*|n_m| + 2*|n_m|$}'


	conj(nombre, posicion): conjHippiesRodEst $\leftarrow$
		$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c2)}}$ '\ote{4}'

	if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'
		while HaySiguiente(itHEst) do '\ote{1}'
			Definir($cs$.estudiantes, Siguiente(itHEst).nombre,
				Siguiente(itHEst).posicion) '\ote{$|n_m|$}'
			Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHEst).posicion.x] $\leftarrow$
			$\leftarrow$ $cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] '\ote{1}'

			$cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] $\leftarrow$ " " '\ote{1}'

			Avanzar(itHEst) '\ote{1}'
		end while $\textit{\textbf{(f1)}}$ '\ote{$4 * 2|n_m|$}'
	end if '\ote{$4 * 2|n_m|$}'


	//Las capturas se actualizan en HippiesRodeadosAs
	conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
		$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c3)}}$ '\ote{4}'

	if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'
		while HaySiguiente(itHAs) do '\ote{1}'
			Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itHAs).y*Columnas($cs$.campus) +
		+ Siguiente(itHAs).x] $\leftarrow$ " " '\ote{1}'
			Avanzar(itHAs) '\ote{1}'
		end while $\textit{\textbf{(f2)}}$ '\ote{$4*|n_m|$}'
	end if '\ote{$4*|n_m|$}'


	conj(nombre, posicion): conjEstRodHip $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosHippies(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c4)}}$ '\ote{4}'

	if Cardinal(conjEstRodHip) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itEstH $\leftarrow$ CrearIt(conjEstRodHip) '\ote{1}'
		while HaySiguiente(itEstH) do '\ote{1}'
			Eliminar($cs$.estudiantes, Siguiente(itEstH).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ " " '\ote{1}'

			Definir($cs$.hippies, Siguiente(itEstH).nombre,
				Siguiente(itEstH).posicion) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ Siguiente(itEstH).nombre '\ote{1}'

			Avanzar(itHAs) '\ote{1}'
		end while $\textit{\textbf{(f3)}}$ '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'


	conj(posicion): conjEstRodAs $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c5)}}$ '\ote{4}'

	if Cardinal(conjEstRodAs) $> 0$ then '\ote{1}'
		itConj(posicion): itEstAs $\leftarrow$ CrearIt(conjEstRodAs) '\ote{1}'

		while HaySiguiente(itEstAs) do '\ote{1}'
			if todasOcupadas?(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$ AND
			AND AlMenosUnAgente(vecinos(Siguiente(itEstAs), $cs$.campus) then $\textit{\textbf{(c6)}}$  '\ote{$2*4$}'
				conj(As): conjAgParaSanc $\leftarrow$
					$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itEstAs), $cs$.campus),
							$cs$) $\textit{\textbf{(c7)}}$ '\ote{4}'
				SancionarAgentes(conjAgParaSanc, $cs$) $\textit{\textbf{(c8)}}$ '\ote{4}'
			end if '\ote{1}'
		end while $\textit{\textbf{(f4)}}$ '\ote{$4*4*4$}'

	end if '\ote{$4*4*4$}'

'\ofi{O(|n_m|)  + O(4*|n_m| + 2*|n_m|) + O(4*2|n_m|) + O(4*|n_m|) + O(4*2|n_m|) + O(4*4*4) = O(27|n_m|) + O(64) = O(|n_m|) + O(1) = O(|n_m|)}'
\end{lstlisting}

\textbf{Justificación de Complejidad:} \textit{\textbf{(c1)}} CantHippiesVecinos tiene como complejidad $O(\#c * |n_m|)$ siendo $c$ el conjunto que se le pasa como parametro. Como el conjunto que le paso como parametro tiene como maximo 4 posicines (porque la funcion vecinos devuelve un conjunto de las 4 posiciones adyacentes a la que le paso por parametro) la complejidad que da es $O(4*|n_m|)$ que es lo mismo que $O(|n_m|)$. \\
\textit{\textbf{(c2)}} HippiesRodeadosEstudiantes tiene como complejidad $O(\#c)$ siendo $c$ el conjunto que se le pasa como parametro pero como le estoy pasando un conjunto que maximo tiene 4 elementos (porque la función vecinos devuelve un conjunto de las 4 posiciones adyacentes a la que le paso por parametro) la complejidad termina siendo $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c3)}} HippiesRodeadosAs idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c4)}} EstudiantesRodeadosHippies idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c5)}} EstudiantesRodeadosAs idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c6)}} idem que el primer punto, todasOcupadas? y AlMenosUnAgente tienen complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro, pero como este conjunto tiene como maximo 4 elementos (porque vecinos devuelve un conjunto con maximo 4 elementos), las complejidades de ambas funciones es $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c7)}} AgParaPremSanc idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c8)}} SancionarAgentes idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(f1)}} El ciclo itera sobre el conjunto conjHippiesRodEst que tiene como máximo 4 elementos y dentro de él se define un estudiante ($O(|n_m|)$) y se elimina un hippie ($O(|n_m|)$), por lo tanto la complejidad del mismo es $O(4*2|n_m|)$ que es lo mismo que $O(|n_m|)$. \\
\textit{\textbf{(f2)}} Idem que el punto anterior, el conjunto conjHippiesRodAs tiene 4 elementos e itera sobre ellos, en este caso la complejidad queda $O(4*|n_m|)$ que es lo mismo que  $O(|n_m|)$. \\
\textit{\textbf{(f3)}} Idem que el punto anterior, el conjunto conjEstRodHip tiene 4 elementos e itera sobre ellos, en este caso la complejidad queda $O(4*2|n_m|)$ que es lo mismo que  $O(|n_m|)$. \\
\textit{\textbf{(f4)}} Idem que el anterior pero como las operaciones están acotadas a cuatro elementos la complejidad queda como $O(4*4*4)$ que es lo mismo que $O(1)$.


~

\begin{lstlisting}[mathescape]
'\alg{iMoverHippie}{\In{h}{nombre}, \Inout{cs}{estr} }{}'

	posicion : actualPos $\leftarrow$ obtener(h, cs.hippies) '\ote{$|n_m|$}'
	posicion : pos $\leftarrow$ ProxPos(actualPos, cs.estudiantes, cs) $\textit{\textbf{(c1)}}$ '\ote{$N_e$}'
	if actualPos $\neq$ pos then '\ote{1}'
		Definir(cs.hippies, h, pos) '\ote{$|n_m|$}'
		cs.posicionesHippies[actualPos.y * columnas(cs.campus)
								+ actualPos.x] $\leftarrow$ " " '\ote{1}'
		cs.posicionesHippies[pos.y * columnas(cs.campus) + pos.x] $\leftarrow$ h '\ote{1}'
	end if '\ote{$|n_m|$}'

	conj(nombre, posicion): conjHippiesRodEst $\leftarrow$
		$\leftarrow$ HippiesRodeadosEstudiantes(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c2)}}$ '\ote{4}'

	if Cardinal(conjHippiesRodEst) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHEst $\leftarrow$ CrearIt(conjHippiesRodEst) '\ote{1}'
		while HaySiguiente(itHEst) do '\ote{1}'
			Definir($cs$.estudiantes, Siguiente(itHEst).nombre,
				Siguiente(itHEst).posicion) '\ote{$|n_m|$}'
			Eliminar($cs$.hippies, Siguiente(itHEst).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHEst).posicion.x] $\leftarrow$
			$\leftarrow$ $cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] '\ote{1}'

			$cs$.posicionesHippies[Siguiente(itHEst).posicion.y*Columnas($cs$.campus) +
			+ Siguiente(itHest).posicion.x] $\leftarrow$ " " '\ote{1}'

			Avanzar(itHEst) '\ote{1}'
		end while $\textit{\textbf{(f1)}}$ '\ote{$4 * 2|n_m|$}'
	end if '\ote{$4 * 2|n_m|$}'


	//Las capturas se actualizan en HippiesRodeadosAs
	conj(nombre, posicion): conjHippiesRodAs $\leftarrow$
		$\leftarrow$ HippiesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c3)}}$ '\ote{4}'

	if Cardinal(conjHippiesRodAs) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itHAs $\leftarrow$ CrearIt(conjHippiesRodAs) '\ote{1}'
		while HaySiguiente(itHAs) do '\ote{1}'
			Eliminar($cs$.hippies, Siguiente(itHAs).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itHAs).y*Columnas($cs$.campus) +
		+ Siguiente(itHAs).x] $\leftarrow$ " " '\ote{1}'
			Avanzar(itHAs) '\ote{1}'
		end while $\textit{\textbf{(f2)}}$ '\ote{$4*|n_m|$}'
	end if '\ote{$4*|n_m|$}'


	conj(nombre, posicion): conjEstRodHip $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosHippies(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c4)}}$ '\ote{4}'

	if Cardinal(conjEstRodHip) $>$ 0 then '\ote{1}'
		itConj(nombre, posicion): itEstH $\leftarrow$ CrearIt(conjEstRodHip) '\ote{1}'
		while HaySiguiente(itEstH) do '\ote{1}'
			Eliminar($cs$.estudiantes, Siguiente(itEstH).nombre) '\ote{$|n_m|$}'

			$cs$.posicionesEstudiantes[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ " " '\ote{1}'

			Definir($cs$.hippies, Siguiente(itEstH).nombre,
				Siguiente(itEstH).posicion) '\ote{$|n_m|$}'

			$cs$.posicionesHippies[Siguiente(itEstH).y*Columnas($cs$.campus) +
		+ Siguiente(itEstH).x] $\leftarrow$ Siguiente(itEstH).nombre '\ote{1}'

			Avanzar(itHAs) '\ote{1}'
		end while $\textit{\textbf{(f3)}}$ '\ote{$4*2|n_m|$}'
	end if '\ote{$4*2|n_m|$}'


	conj(posicion): conjEstRodAs $\leftarrow$
		$\leftarrow$ EstudiantesRodeadosAs(vecinos(pos, $cs$.campus), $cs$) $\textit{\textbf{(c5)}}$ '\ote{4}'

	if Cardinal(conjEstRodAs) $> 0$ then '\ote{1}'
		itConj(posicion): itEstAs $\leftarrow$ CrearIt(conjEstRodAs) '\ote{1}'

		while HaySiguiente(itEstAs) do '\ote{1}'
			if todasOcupadas?(vecinos(Siguiente(itEstAs), $cs$.campus), $cs$ AND
			AND AlMenosUnAgente(vecinos(Siguiente(itEstAs), $cs$.campus) then $\textit{\textbf{(c6)}}$  '\ote{$2*4$}'
				conj(As): conjAgParaSanc $\leftarrow$
					$\leftarrow$ AgParaPremSanc(vecinos(Siguiente(itEstAs), $cs$.campus),
							$cs$) $\textit{\textbf{(c7)}}$ '\ote{4}'
				SancionarAgentes(conjAgParaSanc, $cs$) $\textit{\textbf{(c8)}}$ '\ote{4}'
			end if '\ote{1}'
		end while $\textit{\textbf{(f4)}}$ '\ote{$4*4*4$}'

	end if '\ote{$4*4*4$}'

'\ofi{O(|n_m|) + O(N_e) + O(|n_m|) + O(4*2|n_m|) + O(4|n_m|) + O(4*2|n_m|) + O(4*4*4) = O(22|n_m|) + O(N_e) + O(64) = O(|n_m|) + O(N_e) + O(1) = O(|n_m|) + O(N_e)}'
\end{lstlisting}

\textbf{Justificación de Complejidad:} \textit{\textbf{(c1)}} ProxPos tiene como complejidad $O(\#Claves(d))$ siendo $d$ el diccionario que se le pasa como parametro. Como el diccionario que le paso como parametro en este caso es el diccionario de los estudiantes la complejidad es la cantidad de estudiantes que hay, o sea, $O(N_e)$. \\
\textit{\textbf{(c2)}} HippiesRodeadosEstudiantes tiene como complejidad $O(\#c)$ siendo $c$ el conjunto que se le pasa como parametro pero como le estoy pasando un conjunto que maximo tiene 4 elementos (porque la función vecinos devuelve un conjunto de las 4 posiciones adyacentes a la que le paso por parametro) la complejidad termina siendo $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c3)}} HippiesRodeadosAs idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c4)}} EstudiantesRodeadosHippies idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c5)}} EstudiantesRodeadosAs idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c6)}} idem que el segundo punto, todasOcupadas? y AlMenosUnAgente tienen complejidad $O(\#c)$ siendo $c$ el conjunto que se les pasa como parametro, pero como este conjunto tiene como maximo 4 elementos (porque vecinos devuelve un conjunto con maximo 4 elementos), las complejidades de ambas funciones es $O(4)$ que es lo mismo que $O(1)$. \\
\textit{\textbf{(c7)}} AgParaPremSanc idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(c8)}} SancionarAgentes idem que el punto anterior, termina teniendo complejidad $O(1)$. \\
\textit{\textbf{(f1)}} El ciclo itera sobre el conjunto conjHippiesRodEst que tiene como máximo 4 elementos y dentro de él se define un estudiante ($O(|n_m|)$) y se elimina un hippie ($O(|n_m|)$), por lo tanto la complejidad del mismo es $O(4*2|n_m|)$ que es lo mismo que $O(|n_m|)$. \\
\textit{\textbf{(f2)}} Idem que el punto anterior, el conjunto conjHippiesRodAs tiene 4 elementos e itera sobre ellos, en este caso la complejidad queda $O(4*|n_m|)$ que es lo mismo que  $O(|n_m|)$. \\
\textit{\textbf{(f3)}} Idem que el punto anterior, el conjunto conjEstRodHip tiene 4 elementos e itera sobre ellos, en este caso la complejidad queda $O(4*2|n_m|)$ que es lo mismo que  $O(|n_m|)$. \\
\textit{\textbf{(f4)}} Idem que el anterior pero como las operaciones están acotadas a cuatro elementos la complejidad queda como $O(4*4*4)$ que es lo mismo que $O(1)$.

~

\InterfazFuncion{ProxPos}{\In{pos}{posicion}, \In{d}{dicString(nombre,posicion)}, \In{cs}{estr}}{posicion}
[posValida?(pos)]
{$res$ es la posicion a la cual deberia moverse quien esté en $pos$ dependiendo de como estén distribuidos los hippies o estudiantes en $d$}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{ProxPos}{\In{pos}{posicion}, \In{d}{dicString(nombre,posicion)}, \In{cs}{estr}}{posicion}'

	int: distCorta $\leftarrow$ DistanciaMasCorta(pos, d) $\textit{\textbf{(c1)}}$ '\ote{$\#$Claves(d)}'

	conj(posicion): conjDondeIr $\leftarrow$ DondeIr(pos, distCorta, d) $\textit{\textbf{(c2)}}$ '\ote{$\#$Claves(d)}'
	conj(posicion): conjLugaresPosibles $\leftarrow$
		$\leftarrow$ LugaresPosibles(pos,conjDondeIr, cs) $\textit{\textbf{(c3)}}$ '\ote{$\#$Claves(d)}'

	if Cardinal(conjLugaresPosibles)$=0$ then '\ote{1}'
		res $\leftarrow$ pos '\ote{1}'
	else
		itConj(posicion): itC $\leftarrow$ CrearIt(conjLugaresPosibles) '\ote{1}'
		res $\leftarrow$ Siguiente(itC) '\ote{1}'
	end if '\ote{1}'

'\ofi{O(\#Claves(d)) + O(\#Claves(d)) + O(\#Claves(d)) = O(\#Claves(d))}'
\end{lstlisting}

\textbf{Complejidad:} \textit{\textbf{(c1)}} La función DistanciaMasCorta tiene como complejidad $O(\#Claves(d))$ porque itera sobre ellas buscando la distancia mas corta a la posición que tambien tiene como parametro. \\
\textit{\textbf{(c2)}} DondeIr tiene como complejidad $O(\#Claves(d))$ porque itera sobre las claves del diccionario que se le pasa por parametro. \\
\textit{\textbf{(c3)}} LugaresPosibles tiene como complejidad en realidad $O(\#c)$ siendo $c$ el conjunto que se le pasa como parametro, pero como la cantidad de elementos del conjunto que devuelve no puede ser mayor que la cantidad de claves del diccionario se lo puede acotar estas. Por lo tanto, la complejidad es $O(\#Claves(d))$.

~

\InterfazFuncion{LugaresPosibles}{\In{pos}{posicion}, \In{c}{conj(posicion)}, \In{cs}{estr}}{conj(posicion)}
[posValida?(pos)]
{$res$ es el conjunto de posiciones a las cuales es posible moverse desde $pos$}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{LugaresPosibles}{\In{pos}{posicion}, \In{c}{conj(posicion)}, \In{cs}{estr}}{conj(posicion)}'
	itConj(posicion): itC $\leftarrow$ CrearIt(c) '\ote{1}'
	res $\leftarrow$ Vacio() '\ote{1}'

	while HaySiguiente(itC) do '\ote{1}'
		if Siguiente(itC).x $>$ pos.x AND Siguiente(itC).y $>$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x+1, pos.y)) '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y +1)) '\ote{1}'
		else if Siguiente(itC).x $=$ pos.x AND Siguiente(itC).y $>$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y +1)) '\ote{1}'
		else if Siguiente(itC).x $<$ pos.x AND Siguiente(itC).y $>$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x-1, pos.y)) '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y +1)) '\ote{1}'
		else if Siguiente(itC).x $<$ pos.x AND Siguiente(itC).y $=$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x-1, pos.y)) '\ote{1}'
		else if Siguiente(itC).x $<$ pos.x AND Siguiente(itC).y $<$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x-1, pos.y)) '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y -1)) '\ote{1}'
		else if Siguiente(itC).x $=$ pos.x AND Siguiente(itC).y $<$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y -1)) '\ote{1}'
		else if Siguiente(itC).x $<$ pos.x AND Siguiente(itC).y $<$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x-1, pos.y)) '\ote{1}'
			AgregarRapido(res, tupla(pos.x, pos.y -1)) '\ote{1}'
		else if Siguiente(itC).x $>$ pos.x AND Siguiente(itC).y $=$ pos.y '\ote{1}'
			AgregarRapido(res, tupla(pos.x+1, pos.y)) '\ote{1}'
		end if '\ote{1}'

		Avanzar(itC) '\ote{1}'
	end while $\textit{\textbf{(c1)}}$ '\ote{$\#c$}'

	itConj(posicion) itPosibles $\leftarrow$ CrearIt(res) '\ote{1}'

	while HaySiguiente(itPosibles) do '\ote{1}'
		if HayAlgoEnPos(Siguiente(itPosibles), $cs$) then $\textit{\textbf{(c2)}}$ '\ote{1}'
			EliminarSiguiente(itPosibles) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itPosibles) '\ote{1}'
	end while $\textit{\textbf{(c3)}}$ '\ote{$\#c$}'

'\ofi{O(\#c) + O(\#c) = O(\#c)}'
\end{lstlisting}

\textbf{Complejidad:} $\textit{\textbf{(c1)}}$ El ciclo itera sobre la cantidad de elementos que tiene el conjunto que se pasa por parametro. Como las operaciones que hay dentro de él tienen complejidad $O(1)$ la complejidad del ciclo termina siendo la cantidad de veces que itera que es $O(\#c)$. \\
$\textit{\textbf{(c2)}}$ La función HayAlgoEnPos se fija si hay algo en la posición que le pasamos como parametro y cuesta $O(1)$ por las estructuras que tenemos. \\
$\textit{\textbf{(c3)}}$ Idem que el primer punto, la complejidad termina siendo $O(\#c)$.

~

\InterfazFuncion{HayAlgoEnPos}{\In{pos}{posicion}, \In{cs}{estr}}{bool}
[posValida?(pos, cs)]
{$res$ es true si y solo si hay algo, ya sea hippie, estudiante, agente u obstáculo, en $pos$}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{HayAlgoEnPos}{\In{pos}{posicion}, \In{cs}{estr}}{bool}'
	res $\leftarrow$ false '\ote{1}'

	if HaySiguiente($cs$.posicionesAgente[pos.y*Columnas($cs$.campus) + pos.x].datos) then '\ote{1}'
		res $\leftarrow$ true '\ote{1}'
	end if '\ote{1}'

	if $cs$.posicionesHippies[pos.y*Columnas($cs$.campus) + pos.x].datos $\neq$ " " then '\ote{1}'
		res $\leftarrow$ true '\ote{1}'
	end if '\ote{1}'

	if $cs$.posicionesEstudiantes[pos.y*Columnas($cs$.campus) + pos.x].datos $\neq$ " " then '\ote{1}'
		res $\leftarrow$ true '\ote{1}'
	end if '\ote{1}'

	if Ocupada?(pos, $cs$.campus) then '\ote{1}'
		res $\leftarrow$ true '\ote{1}'
	end if '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Trivial, se fija si hay algo en la posición y como usamos vectores, ver en una posición de un vector cuesta $O(1)$.

~

\InterfazFuncion{DondeIr}{\In{pos}{posicion}, \In{dist}{nat}, \In{d}{diccString(nombre,posicion)}}{conj(posicion)}
[posValida(pos)]
{$res$ el el conjunto de posiciones, que representan individuos de $d$, cuya distancia desde $pos$ hasta ellas es $dist$}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{DondeIr}{\In{pos}{posicion}, \In{dist}{nat}, \In{d}{diccString(nombre,posicion)}}{conj(posicion)}'

	res $\leftarrow$ Vacio() '\ote{1}'
	itDiccString(nombre,posicion): itDicc $\leftarrow$ CrearIt(d) '\ote{1}'

	while HaySiguiente(itDicc) do '\ote{1}'
		if dist = Distancia(pos,Siguiente(itDicc)) then $\textit{\textbf{(c1)}}$ '\ote{1}'
			AgregarRapido(res, Siguiente(itDicc)) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itDicc) '\ote{1}'
	end while $\textit{\textbf{(c2)}}$ '\ote{$\#$Claves(d)}'

'\ofi{O(\#Claves(d))}'
\end{lstlisting}

\textbf{Complejidad:} \textit{\textbf{(c1)}} La función Distancia devuelve la distancia que hay entre las dos posiciones que paso como parametro, lo hace en $O(1)$. \\
\textit{\textbf{(c2)}} Como las operaciones dentro del ciclo tienen complejidad $O(1)$ la complejidad del mismo termina siendo la cantidad de claves que tiene el diccionario por el cual estoy iterando que es $O(\#Claves(d))$.

~


\InterfazFuncion{DistanciaMasCorta}{\In{pos}{posicion}, \In{d}{dicString(nombre, posicion)}}{int}
[\#Claves(d))>0]
{Para toda posicion definida en d, res es menor o igual que la distancia entre pos y la posicion.}



\begin{lstlisting}[mathescape]
'\alg{DistanciaMasCorta}{\In{pos}{posicion}, \In{d}{dicString(nombre, posicion)}}{int}'

	itDiccString(nombre,posicion): itDicc $\leftarrow$ CrearIt(d) '\ote{1}'
	res $\leftarrow$ Distancia(pos, Siguiente(itDicc)) $\textit{\textbf{(c1)}}$ '\ote{1}'
	Avanzar(itDicc) '\ote{1}'

	while HaySiguiente(itDicc) do '\ote{1}'
		if res $>$ Distancia(pos, Siguiente(itDicc)) '\ote{1}'
			res $\leftarrow$ Distancia(pos, Siguiente(itDicc)) '\ote{1}'
		end if '\ote{1}'
		Avanzar(itDicc) '\ote{1}'
	end while $\textit{\textbf{(c2)}}$ '\ote{$\#$Claves(d)}'

'\ofi{O(\#Claves(d))}'
\end{lstlisting}

\textbf{Complejidad:}  \textit{\textbf{(c1)}} La función Distancia devuelve la distancia que hay entre las dos posiciones que paso como parametro, lo hace en $O(1)$. \\
\textit{\textbf{(c2)}} Como las operaciones dentro del ciclo tienen complejidad $O(1)$ la complejidad del mismo termina siendo la cantidad de claves que tiene el diccionario por el cual estoy iterando que es $O(\#Claves(d))$.

~

\InterfazFuncion{Distancia}{\In{pos1,pos2}{posicion}}{nat}
[true]
{res $\igobs$ $|pos2.x - pos1.x| + |pos2.y - pos1.x|$}


\begin{lstlisting}[mathescape]
'\alg{Distancia}{\In{pos1,pos2}{posicion}}{nat}'

	res $\leftarrow$ $|pos2.x - pos1.x| + |pos2.y - pos1.x|$ '\ote{1}'

'\ofi{O(1)}'
\end{lstlisting}

~

\begin{lstlisting}[mathescape]
'\alg{iMoverAgente}{\In{a}{agente}, \Inout{cs}{estr} }{}'
	itDiccNat(agente, datosAgente) it
		$\leftarrow$ busqBinPorPlaca(cs.ordenadoPorPlaca, a)'\ote{$log(N_a)$}'

	// Actualizo la posicion del agente
	posicion nuevaPos $\leftarrow$ ProxPos(Siguiente(it).posicion, cs.hippies, cs)		'\ote{$N_h$}'
	posicionesAgentes[Siguiente(it).posicion.y * columnas(cs.campus)
		+ Siguiente(it).posicion.x].datos $\leftarrow$ CrearIt(Vacio())					'\ote{1}'
	posicionesAgentes[nuevaPos.y * columnas(cs.campus) + nuevaPos.x]
		$\leftarrow$ tupla(a, it)												'\ote{1}'
	Siguiente(it).posicion $\leftarrow$ nuevaPos										'\ote{1}'

	// Me fijo a quienes atrapa
	posicion posArr $\leftarrow$ moverDir(cs.campus, nuevaPos, arriba)			'\ote{1}'
	actualizarAgente(cs, posArr, a, it) 										'\ote{$|n_m|$}'

	posicion posAba $\leftarrow$ moverDir(cs.campus, nuevaPos, abajo)			'\ote{1}'
	actualizarAgente(cs, posAba, a, it) 										'\ote{$|n_m|$}'

	posicion posDer $\leftarrow$ moverDir(cs.campus, nuevaPos, der)				'\ote{1}'
	actualizarAgente(cs, posDer, a, it) 										'\ote{$|n_m|$}'

	posicion posIzq $\leftarrow$ moverDir(cs.campus, nuevaPos, izq)				'\ote{1}'
	actualizarAgente(cs, posIzq, a, it) 										'\ote{$|n_m|$}'


'\ofi{O(log(N_a) + |n_m| + N_h)}'
\end{lstlisting}

\textbf{Complejidad:} Hace busqueda binaria sobre el vector de agentes ordenado por placa. Esto cuesta $O(log( N_a)$. Luego muevo al agente, para lo cual debo calcular primero la posición. Esto cuesta $O(N_H)$ ya que debo preguntar por las posiciones de todos los hippies para decidir. Finalmente actualizo el estado del agente, fijandome a quienes atrapa. En caso de atrapar un hippie debo borrarlo del diccString, que cuesta $O(|n_m|)$.

~


\InterfazFuncion{actualizarAgente}{\Inout{cs}{estr}, \In{posicion}{pos}, \In{a}{agente}, \In{it}{itDiccNat(agente, datosAgente)}}{}
[pos debe ser una posicion contigua y sin obstáculos]
{Se fija en pos si hay alguien, si hay un hippie y fue atrapado, lo borra e incrementa la cantidad de atrapados del agente, si hay un estudiante y fue atrapado, incrementa la cantidad de sanciones}

\begin{lstlisting}[mathescape]
'\alg{actualizarAgente}{\Inout{cs}{estr}, \In{posicion}{pos}, \In{a}{agente}, \In{it}{itDiccNat(agente, datosAgente)}}{}'
	if(posValida?(cs.campus, pos) then 										'\ote{1}'

	   	if(posicionesHippies[pos.y * columnas(cs.campus) + pos.x] $\not$= "") then
	   		if(atrapado?(cs, pos)) then										'\ote{1}'
	   			// Le sumo uno a sus capturas, actualizo masVigilante y mato al hippie
	   			Siguiente(it).cantAtrapados++;								'\ote{1}'
	   			if(Siguiente(it).cantAtrapados >
	   			   (*cs.masVigilante.datos).cantAtrapados) then
	   				cs.masVigilante $\leftarrow$ tupla(a, it)					'\ote{1}'
	   			end if
	   			borrar(cs.hippies, posicionesHippies[pos.y *
	   			       columnas(cs.campus) + pos.x])							'\ote{$|n_m|$}'
	   			posicionesHippies[pos.y * columnas(cs.campus) + pos.x]
	   				$\leftarrow$ ""												'\ote{1}'
	   		end if
	   	end if

	   	if(posicionesEstudiantes[pos.y * columnas(cs.campus) + pos.x] $\not$= "") then
	   		if(atrapado?(cs, pos)) then 										'\ote{1}'
	   			// Actualizo las sanciones y las estructuras relacionadas
	   			cs.mismasSancModificado $\leftarrow$ true						'\ote{1}'

	   			itConj(agente) iterConj $\leftarrow$ Siguiente(it).itConjMismasSanc 	'\ote{1}'
	   			EliminarSiguiente(iterConj)										'\ote{1}'

	   			itLista(kSanc) iterLista $\leftarrow$ Siguiente(it).itMismasSanc 		'\ote{1}'
	   			// Me guardo un iterador para borrar el nodo de la lista
	   			// si es que queda sin agentes
	   			itLista(kSanc) iterListaAnterior $\leftarrow$ Siguiente(it).itMismasSanc '\ote{1}'
	   			if(HaySiguiente?(iterLista) then 								'\ote{1}'
	   			   	// Me fijo si el siguiente es la siguiente sancion
	   			   	nat : sanciones $\leftarrow$ Siguiente(iterLista).sanc 		'\ote{1}'
	   			   	Avanzar(iterLista) 											'\ote{1}'

	   			   	if(Siguiente(iterLista).sanc = sanciones + 1) then 			'\ote{1}'
	   			   		// Lo agrego al conjunto
	   			   		Siguiente(it).itConjMismasSanc $\leftarrow$
	   			   			AgregarRapido(a, Siguiente(iterLista).agentes)		'\ote{1}'
	   			   	else
	   			   		// Creo un nuevo nodo en el medio
	   			   		conj(agente) conj $\leftarrow$ Vacio()					'\ote{1}'
	   			   		Siguiente(it).itConjMismasSanc $\leftarrow$
	   			   			AgregarRapido(a, conj)								'\ote{1}'
	   			   		kSanc nodo $\leftarrow$ tupla(sanciones + 1, conj)		'\ote{1}'
	   			   		AgregarComoAnterior(iterLista, nodo)					'\ote{1}'
	   			   		Retroceder(iterLista)									'\ote{1}'
	   			   		Siguiente(it).itMismasSanc $leftarrow$ iterLista				'\ote{1}'
	   			   	end if
	   			else
	   				// Creo un nuevo nodo
	   				conj(agente) conj $\leftarrow$ Vacio()					'\ote{1}'
	   				Siguiente(it).itConjMismasSanc $\leftarrow$
   			   			AgregarRapido(a, conj)								'\ote{1}'
   			   		kSanc nodo $\leftarrow$ tupla(sanciones + 1, conj)		'\ote{1}'
   			   		AgregarComoSiguiente(iterLista, nodo)					'\ote{1}'
   			   		Avanzar(iterLista)										'\ote{1}'
	   			   	Siguiente(it).itMismasSanc $leftarrow$ iterLista				'\ote{1}'
	   			end if

	   			if(!HaySiguiente?(iterConj) then							'\ote{1}'
	   				// Borro el nodo anterior de la lista porque no tiene agentes
	   				EliminarSiguiente(iterListaAnterior)					'\ote{1}'
	   			end if

	   			Siguiente(it).cantSanc++;											'\ote{1}'
	   		end if
	   	end if
	end if
'\ofi{O(|n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} Se fija a quién atrapa en la dirección pasada como parametro. Todas las operaciones son de tiempo constante con excepción de la de borrar un hippie del diccString, que se ejecuta en caso de haber atrapado un hippie. Esta operación cuesta $O(|n_m|)$.

~


\begin{lstlisting}[mathescape]
'\alg{iCampus}{\In{cs}{estr} }{campus}'
	$res$ $\leftarrow$ $cs$.campus'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Devuelve una referencia a campus en tiempo constante.

~


\begin{lstlisting}[mathescape]
'\alg{iEstudiantes}{\In{cs}{estr} }{itConj(tupla(nombre,posición))}'
	$res$ $\leftarrow$ CrearItClaves($cs$.estudiantes)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Crea un iterador de estudiantes y lo devuelve en tiempo constante.

~


\begin{lstlisting}[mathescape]
'\alg{iHippies}{\In{cs}{estr} }{itConj(tupla(nombre,posición))}'
	$res$ $\leftarrow$ CrearItClaves($cs$.hippies)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Crea un iterador de hippies y lo devuelve en tiempo constante.

~


\begin{lstlisting}[mathescape]
'\alg{iAgentes}{\In{cs}{estr} }{itConj(tupla(agente,datosAgente))}'
	$res$ $\leftarrow$ CrearItClaves($cs$.personalAS)'\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\textbf{Complejidad:} Crea un iterador de agentes y lo devuelve en tiempo constante.

~


\begin{lstlisting}[mathescape]
'\alg{iPosEstudianteYHippie}{\In{id}{nombre}, \In{cs}{estr} }{posición}'
	if Definido?($id$, $cs$.hippies) then '\ote{$|n_m|$}'
		$res$ $\leftarrow$ Obtener($id$, $cs$.hippies)'\ote{$|n_m|$}'
	else
		$res$ $\leftarrow$ Obtener($id$, $cs$.estudiantes)'\ote{$|n_m|$}'
	end if
'\ofi{O(|n_m|) + O(4*2|n_m|) = O(|n_m|)}'
\end{lstlisting}

\textbf{Complejidad:} En el peor de los casos llama a la funcion definido del diccString que itera sobre los caracteres de la palabra y despues hace una llamada al obtener

~


\begin{lstlisting}[mathescape]
'\alg{iPosAgente}{\In{a}{agente}, \In{cs}{estr} }{posición}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).posicion '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iCantSanciones}{\In{a}{agente}, \In{cs}{estr} }{}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).cantSanc '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iCantHippiesAtrapados}{\In{a}{agente}, \In{cs}{estr} }{}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).cantAtrapados '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iConMismasSanciones}{\In{a}{agente}, \In{cs}{estr} }{lista(agente)}'
	$res$ $\leftarrow$ Obtener($a$, $cs$.personalAS).itMismasSanc.conjAgente '\ote{1 caso promedio}'
'\ofi{O(1) \text{ caso promedio}}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\begin{lstlisting}[mathescape]
'\alg{iConKSanciones}{\In{k}{nat}, \In{cs}{estr} }{lista(agente)}'
	if $cs$.mismasSancModificado == true then '\ote{1}'
		hacerArregloMismasSanc($cs$) '\ote{$N_a$}'
		$cs$.mismasSancModificado $\leftarrow$ false
	end if

	nat: i $\leftarrow$ 0
	bool: esta $\leftarrow$ busqBinAgente($k$, i, $cs$.vectorMismasSanc) '\ote{$logN_a$}'
	if esta = true then '\ote{1}'
		res $\leftarrow$ *$cs$.vectorMismasSanc[i].agentes '\ote{1}'
	else
		res $\leftarrow$ Vacia() '\ote{1}'
	end if

'\ofi{\text{Si las sanciones no fueron modificadas: } O(N_a) \text{. Si no } O(logN_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{hacerArregloMismasSanc}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{hacerArregloMismasSanc}{\Inout{cs}{estr}}{}'
	arreglo(puntero(kSanc)): arregloNuevo $\leftarrow$ CrearArreglo(Longitud($cs$.listaMismasSanc))
	'\ote{$N_a$}'
	itLista(kSanc): it $\leftarrow$ CrearIt($cs$.listaMismasSanc) '\ote{1}'
	nat: i $\leftarrow$ $0$ '\ote{1}'

	while HaySiguiente(it) do '\ote{1}'
		puntero(kSanc): p $\leftarrow$ puntero(Siguiente(it)) '\ote{1}'
		arregloNuevo[i] $\leftarrow$ p '\ote{1}'
		i $\leftarrow$ i $+1$ '\ote{1}'
		Avanzar(it) '\ote{1}'
	end while '\ote{$N_a$}'

	$cs$.arregloMismasSanc $\leftarrow$ arregloNuevo '\ote{1}'

'\ofi{O(N_a) + O(N_a) = O(N_a) \text{ Como máximo va a ser la cantidad de agentes la lista listaMismasSanc} }'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{busqBinAgente}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{busqBinAgente}{\In{k}{nat}, \Inout{i}{nat}, \In{v}{arreglo(puntero(kSanc))}}{bool}'
	nat: n $\leftarrow$ $0$ '\ote{1}'
	nat: m $\leftarrow$ Longitud(v) '\ote{1}'
	nat: med

	while n $\neq$ m$-1$ do '\ote{1}'
		med $\leftarrow$ $\frac{n+m}{2}$ '\ote{1}'
		if med $\leq$ k then '\ote{1}'
			n $\leftarrow$ med '\ote{1}'
		else
			m $\leftarrow$ med '\ote{1}'
		end if
	end while '\ote{$log(N_a)$}'

	if v[n] $=$ k then
		i $\leftarrow$ n
		$res$ $\leftarrow$ true
	else
		$res$ $\leftarrow$ false
	end if

'\ofi{O(logN_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{Atrapado?}{\In{}{} }{ }
[]
{}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{Atrapado?}{\In{c}{campus}, \In{pos}{Posicion}}{bool}'
	$res$ $\leftarrow$ todasOcupadas?(vecinos(pos,cs.campus)) '\ote{1}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.

~


\InterfazFuncion{busqBinPorPlaca}{\In{a}{agente}, \In{v}{vector(As)}}{itDiccNat(agente, datosAgente)}
[($\exists$ elem : As)(esta?(elem, v) $\land$ agente(elem) = a) $\land$ ordenadoPorPlaca?(v)]
{res es igual al $datos$ del elemento de $v$ que tiene a $a$ como $agente$}
[]
[]
[]

\begin{lstlisting}[mathescape]
'\alg{busqBinPorPlaca}{\In{a}{agente}, \In{v}{vector(As)}}{itDiccNat(agente, datosAgente)}'
	nat: inf $\leftarrow$ $0$ '\ote{1}'
	nat: sup $\leftarrow$ Longitud(v) '\ote{1}'
	nat: med $\leftarrow$ $\frac{inf+sup}{2}$ '\ote{1}'

	while inf $\neq$ sup$-1$ do '\ote{1}'
		med $\leftarrow$ $\frac{inf+sup}{2}$ '\ote{1}'
		if v[med].agente $\leq$ a then '\ote{1}'
			inf $\leftarrow$ med '\ote{1}'
		else
			sup $\leftarrow$ med '\ote{1}'
		end if
	end while '\ote{$log(N_a)$}'

	$res$ $\leftarrow$ v[inf].datos

'\ofi{O(logN_a)}'
\end{lstlisting}

\textbf{Complejidad:} Analizar complejidad.
